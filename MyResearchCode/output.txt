Keyword =  data structure
num =  50
Please visit this URL to authorize this application: https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=683980519633-7j9hv5avhu0llp5bonfssbt26ro2fnco.apps.googleusercontent.com&redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob&scope=https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fyoutube.force-ssl&state=Xgq5RgJkEZDaoBMAoNuX5tdOTl1t7O&access_type=offline&prompt=consent
Enter the authorization code: bum_19loj9A
DuDz6B4cqVc
SAzD-oBcmbk
YWnBbNj_G-U
oSWTXtMglKE
t0Cq6tVNRBA
jc1t0KFsOcs
z2pjGiaDUPo
BchPukWb0CU
92S4zgXN17o
pmN9ExDf3yQ
0XL1NBUv2NU
cNEz-UWxyn4
pA-8eBZvN1E
wU6udHRIkcc
ikPPdBDZnz4
f4sJ5dOeOow
qH6yxkw0u78
gXgEDyodOJU
EDCiI8AYDEo
StLSP-v3LdE
u3tzoHfK5ss
HUJAAOcOHR0
c8P9kB1eun4
R-HLU9Fl5ug
CzZ6KodVKJo
fHNmRkzxHWs
F1F2imiOJfk
['0520backup', '92S4zgXN17o.en.vtt', 'bum_19loj9A.en.vtt', 'c8P9kB1eun4.en.vtt', 'cNEz-UWxyn4.en.vtt', 'CzZ6KodVKJo.en.vtt', 'DuDz6B4cqVc.en.vtt', 'F1F2imiOJfk.en.vtt', 'gXgEDyodOJU.en.vtt', 'HUJAAOcOHR0.en.vtt', 'jc1t0KFsOcs.en.vtt', 'oSWTXtMglKE.en.vtt', 'pA-8eBZvN1E.en.vtt', 'pmN9ExDf3yQ.en.vtt', 'qH6yxkw0u78.en.vtt', 'R-HLU9Fl5ug.en.vtt', 't0Cq6tVNRBA.en.vtt', 'wU6udHRIkcc.en.vtt', 'z2pjGiaDUPo.en.vtt']
bum_19loj9A.en.vtt   hey YouTube just in case you're new here my name is YK and I was formerly a software developer at Google and now I work on this YouTube channel full time and welcome to my data structures and algorithms series number one what are data structures so a one sentence description of what data structures are would be that there are basically different ways of storing data on your computer and this sentence might not be too clear right now so let me give you a more concrete example here let's say you want to make a system that's sort of like Google Maps for your neighborhood now let's say your neighborhood looks like this so your home is here and there's a store here and another store here and so on and there are some streets too so these arrows show that these are one-way streets there are a lot of one-way streets here and so for example you can go from store to store B but not the other way around and all the other lines here there are not arrows show that they are two-way streets and let's say that you already have each place is coordinates there are latitudes and longitudes stored on your computer like this as you can see from this table you can tell that the latitude of home is forty-nine point two and the longitude of home is minus one hundred twenty three point four and so on now from this table like information you can tell where each location is exactly where each point is exactly but you can't tell how these locations are connected with streets and where the streets are exactly so you need to figure a way to store that information somehow on your computer and there are actually a few different options for this one of those options will be to store all possible paths in a list like format so for example one of those paths will be from store a to home and another one will be home to store a and yet another path will be store a to store B and with that method your data might look like this and from this list like information you can tell that as we saw earlier you can go from home to store a and from store a to home and home to store B and so on but you can't go from store B to home because this is a one-way street and so there's no path from store B to home in this list okay so that's just one option another option might be to list each of these places and for each of those places just list all the places you can go from that place and with that method your data might look like this instead as you can see here we have table like information again where on the left hand side we have all the places listed home store a store B school and then intersection this one right here and on the right hand side for each of those places we have all the places you can go from there so from home you can go to store a store B and intersection as you can see here and from store a you can go to home or store B so these two methods are basically two different ways of storing exactly the same set of data and as you can see they have sort of different structures and so these are simplified examples of what data structures look like now if you're already familiar with data structures you might notice that the first method corresponds to the array or a list data structure and the second method corresponds to the hash table or hash map data structure okay so that's one simple example of what data structures are but this video series is called data structures and algorithms so what are algorithms one way to define what they are would be that there are the operations we can perform on different data structures and the sets of instructions for executing them so one example here might be something like this coming back to the previous example we had let's say you want to find the shortest path from home to school so in this problem by hand is pretty easy pretty much right away you can see that there are three potential paths from home to school one of them is this one just go to store a store B and then school another one is this one store B cool and another one the other one is from home to intersection to school and for these three paths just compare the distance that you need to travel for each of these paths and then pick the shortest one and to compute the distance these paths you can for example use the longitudes and latitudes the coordinates of each of these places and find the distance in kilometers so solving this problem by hand is pretty much trivial but if you want to turn this into something a computer can understand you need to be much more systematic about it so to make this strategy something a computer can understand easily you might come up with a set of instructions like this one first of all find all the places you can go from home so in this example that's store a store B and then the intersection and then from each of those places find all the paths you can take from that place so from store a you can go to store B and from store B you can go to school and from intersection you can only go to school and as you go keep track of the distance you've traveled so far for each of those paths and keep repeating this process until you get to the school then if you happen to find multiple paths that allows you to go from home to school then compare the distance that you've traveled for each of those paths and finally find a path with the shortest distance traveled and then pick that as the shortest path okay so that's the result we were looking for in the first place and this is a good example of what an algorithm is basically you have a problem you're going to solve in this case finding the shortest path from home to school and then you have a set of systematic instructions for solving that problem now one thing to note here is that depending on what data structure you're using to store the data that you're performing the algorithm on your algorithm might look slightly differently you might even have in some cases completely different algorithms for solving the same problem depending in this particular example we talked about two different options for storing the information about where the streets are and how they connect different locations the first option was to just list all possible paths and remember that the first step in our algorithm was to find all the possible places you can go from home and to do that with the first stair structure this one right here you might actually need to go through the entire list because in this particular list we have three paths here from home but it's possible that we have another path from home right here at the end of the list so you need to go through the entire list just in case on the other hand if you use the second data structure that we discussed we have home listed right here as a group so as soon as we find the home row in this table you won't need to go through the entire table anymore so in this particular example using the second structure actually makes it slightly easier to implement the algorithm that we discussed now there are structures and algorithms are really important to learn because they'll help you write efficient software as a software developer so for example when I was working at Microsoft as a data science intern I had to write this piece of code to retrieve some data and when I wrote it originally it was taking like seven to ten hours and basically it was too slow because we didn't want we didn't want to wait that long so I rewrote it using my knowledge of data structures and algorithms and after rewriting it the new version only took like five to ten minutes to load that data so that's why learning them is important and it's actually useful in many practical situations that you might encounter as a software developer - okay to give you an even better idea about what data structures are like let me give you another example here let's say you're hosting a party and you're expecting a bunch of people and this example is gonna be a little bit silly but just follow along and you're gonna see why I'm talking about this particular example anyway let's say that each person come to the party we'll bring sort of like a small ball with them like a ball that can fit in their hand and this ball will have their name written on it so when David comes to the party he'll have a ball with David written on it and when Kevin arrives to the party he'll have a ball with Kevin written on it and so on and this is just a silly little system that you came up with for keeping track of who came to the party in which order because writing now each person's name would be a lot of work you're just too busy hosting a party so as someone who's studying computer science let's say you're trying to come up with an efficient system for storing these balls so that you can keep track of who came to the party one idea you have is this one you get a very long box with 100 partitions a lot of partitions and each partition let's say has exactly the same shape you know 10 centimeters by 10 centimeters let's say and every time someone comes to the party you're just gonna put that person's ball with their name written on it in the order they came to the party so David's ball will come in here and Kevin's will come in here and so on and this is actually sort of like a data structure that's realized in real life and this actually corresponds to the data structure called array in computer science and here's another idea you have you get a bunch of boxes and this time instead of getting a long box with many many partitions you want to get individual boxes that are connected with strings so the first box is connected to the second box with a string and that's connected to the third box with a string and so on and just like before you want to put these tokens with participants names written on them in these boxes just one by one in the order they came in so David's token will come in here and Kevin's ball will come in here and so on and this sort of data corresponds to the linked list data structure in computer science okay so the natural question here would be which use for this party well it actually depends because it highly depends on the particular situation and the nature of the party really and each data structure has advantages and disadvantages okay think about this situation let's say 100 people showed up to your party and you're pretty happy about it but suddenly you realize that the 98th person is Paul had been misspelled that person's name had been misspelled so you want to fix that with the array data structure it's actually pretty easy you just need to find the 98th partition and that exact location can be calculated easily because you know that each partition is ten centimeters wide so you just need to find ten centimeters times ninety seven actually which is nine hundred seventy centimeters so you just need to walk over from the beginning nine hundred seventy centimeters and then you can find the 98th person's token pretty easily you just need to replace that with the correct token with the link list data structure though doing the same thing would be slightly more tricky and that's because finding the 98th person or finding the 98th box here would be much harder and the reason for that is because these strings are pretty soft and they can be pretty much any lengths so each box can be in any location relative to the previous box so this first box might be in the living room and the second box might be in the kitchen and so on so to find in 98th box what you need to do is you need to count them one by one so you need to say okay this is the first box and then this is the second box and let's find the third box fourth and so on until you get to the 98th person at this point you might say well the array data structure is a better one then well not necessarily so think about this situation let's say you have 100 people showing up to the party suddenly five more people show up that you didn't expect with the linked list data structure it's pretty easy to deal with that you can just add five more boxes find five more boxes somewhere and then five more strings and just add them to the last box you had in the linked list data structure and then store the five people's tokens in those boxes with the array data structure though it's a little bit more tricky one option here would be to get another box with let's say 100 partitions again and store those people's tokens there and use the two boxes together or you could destroy the first box you had and then get a box with even more partitions let's say 200 partitions and then transfer all the balls you had for the first 100 people to the new box and then after that add the additional five people's tokens in the new box and in general if you have no idea how many people are coming to the party let's say anywhere between 5 to 1,000 people the linked list data structure might be slightly more convenient than the array because linked lists are so much easier to resize than it is to resize a race ok and this was another simplified example of what data structures are like on a computer and this sort of gives you a rough idea about how to actually start thinking about them and throughout this course I'm going to introduce you to even more data structures and this time I'm going to explain them in a much more technical way using concepts like classes objects memory and maybe even some code snippets too now if you're just getting started with data structures and algorithms one thing to keep in mind that's actually really important is to apply what you've learned through solving problems and the reason I say that is because it's so common for beginners to learn these concepts and not actually be able to use them in a real-world situation because they haven't had enough practice and actually this video sponsor brilliant org has an interesting website for learning these concepts in a sort of a new way ok to show you what I mean let's take a look at their computer science fundamentals course right here which I would recommend for you guys and let's go into the intro to algorithms section and you can see that it covers topics like arrays searching insertion sort and Big O notation and in the arrays section they have a bunch of explanations about the topic and as you continue you'll give you a quiz to test your understanding of the topic so it's definitely an interesting way to learn computer science concepts by solving problems okay if you want to check it out for yourself just go to brilliant org slash CS no joke and going to this link will actually help support this channel and the first 200 people will get 20% off the annual subscription and actually I'm super excited about this because they're the first sponsor I have on this YouTube channel and I feel like I'm becoming a professional youtuber finally so thanks for that brilliant ok as always I'm YK from CS dojo thanks for watching and I'll see you guys in the next video 

===[=]===


DuDz6B4cqVc.en.vtt  Hi, I'm Carrie Ann, and welcome to the intensive computer science lessons!  In the last episode, we discussed a few classical algorithms, such as ordering a list of numbers  And finding the shortest path in a graph.  What we did not talk about much about is how to store program data in a device memory  Computer  You do not want your data to be like John Green's bedroom in college, with eating and dressing  The leaves are scattered everywhere.  Instead, we want our data to be organized, that is, to be arranged, allowing things  Be easy to retrieve and read.  For this, computer scientists use data structure!  an introduction  We have previously provided one of the foundations of structured data, tables or so called lists  Radiology in some languages.  This is a series of values ​​stored in memory.  So instead of just one value being saved to a variable, such as' j equals 5, we are  We can define a whole string of numbers, and save that in a tabular variable.  To be able to find a special value in this table, you must specify a serial number.  Almost all programming languages ​​start tables with a serial number of 0, and use as a general shape rectangular brackets  Set to use the table  So, for example, if we want to add values ​​in the first and third positions of the table  'J', and save it to variable "A", we write a line of code like this.  How a table to be stored in this memory is very clear  Simply put, to say that the translator chose us in the 1000 site memory  The table contains 7 digits and is stored one by one in memory as you can see here  That is, when we write "j" with the serial number "0", the computer goes to location 1000 in memory with 0  Offset we get the value 5.  If we want to retrieve the "J serial number 5", our program goes for 1000 site in memory,  With a displacement of 5 degrees, which in this case we find value 4.  Easy to confuse number V in table with serial number 5.  They are different  Remember that the serial number number 5 is the sixth in the table because the first digit  Is the serial number holder.  Tables as data modifiers are numerous uses, always used and there are several applications  Which makes them do useful things.  For example, almost all programming languages ​​are accompanied by prearranged instructions  Once you enter the table, you will receive a salary  So there is no need to write an algorithm from scratch.  Symbol strings are very similar to them, as they are tables of symbols such as letters, numbers  Punctuation marks, and other written symbols.  We talked in Episode 4 about how computers store characters  Most often, to store the string of symbols in memory, you can only put them between "".  Although it does not look like a table, but it does  Behind the scenes memory is so  Note that the string ends with zero in memory.  It is not a zero symbol, but the value is 0 in the binary system  This is called an empty symbol, symbolizing the end of the string in memory.  This is important because if you use an instruction such as "Show Content" that reveals a string of symbols  On the screen, it shows each character in the order starting from the first location in memory  But he needs to know when he stops!  On the other hand, it shows everything in memory on the basis that it is text  Zero Allows instructions for symbol strings to be defined when to stop  Because computers deal with text often, there are many special applications  By dealing with symbol strings  For example, many programming languages ​​have the function of merging symbol strings, or "strcat"  Which takes two strings, then copies the whole second and adds it to the end of the first  We can use tables to make single-dimensional lists, but sometimes you want to use  Two-dimensional data, such as the number grid in the scheduling program, or pixels  On the screen of your computer.  For this, we need matrices.  You can think of a matrix shape as a table of tables!  Even the 3x3 matrix is ​​really a table of size 3, with each index storing a table of  Size 3.  We can select the matrix like that  In memory, are intertwined with each other  To access a value, you need to specify two indicators, such as "J with serial number 2" with the serial number  1 "This determines for the computer that we are looking for an item in Table 2 at position 1  This gives us a value of 12  The good thing about matrices is that they are not limited in 3x3, but we can create them any  The size we want - we can also make it from any number of dimensions we want.  For example, we can create and access a five-dimensional matrix  That's right, you now know how to access a five-dimensional matrix - tell your friends!  So far, we've stored numbers and letters on our tables or matrices  But it is often helpful to store a set of variables with some  For example, you can store a bank account number in addition to the balance  Groups of such variables can be grouped together in a single register  Now we can create variables that are not just individual numbers but composite data  Structures are capable of storing several types of data together in one.  We can create tables for the records we know where they are automatically grouped together  in the memory.  If we use, for example, "C with a serial number of 0" we get all the records stored there, and  We can withdraw the specific account number and balance data we want  This is a table of trappings like any other table, which is created with a fixed size that you can not  Expand it to add more items.  Also, tables must be arranged in memory, making it difficult to add a new element in the middle  However, structured data structures can be used to build more complex data structures  Where we avoided these restrictions  Let's take a look at this structure that is called "node"  It stores a variable, such as a number, and also a pointer  The cursor is a special variable that refers to a location in memory and hence it is called,  Using this structure, lists can be created so that the structure is flexible  Many nodes can be stored.  This is done by having at the end of each node a handle for the next node in the list  Let's imagine we have three nodes reserved in memory, at locations 1000, 1002 and 1008.  May be distant from each other, because it was created at different times, and other data  They can be between them.  Therefore, you see that the first node contains the value 7, and the location is 1008 in the index  Next  This means that the next node in the bound list is located in memory location 1008.  By noting down the bound list, to the pro node, we see that it stores the value 112 and the index  To another node in place 1002.  Accordingly, we find the node containing the value 14 and the index return to the first  Node in place 1000.  And from it make the list bound to annular, but can also be terminated  Using the value of the cursor is 0 - the null value - that would indicate that we have reached  End menu.  When programmers use bound lists they rarely look at the values ​​stored in the next of  Indicators.  Alternatively, they can use abstraction for linked lists, which look like this, which is  Much easier to imagine.  Unlike tables that need to be resized in advance, linked lists can be extensible or  Default.  For example, we can customize a new node in memory, and enter it into this list  By changing the following indicators.  Linked lists are easy to rearrange, expand, reverse, and so on.  This is very nice!  It is very useful for algorithms like sorting, which we talked about last week.  Because of this flexibility, many more complex data structures were built on top of the associated lists  The most famous are queues and stacks  Queue - Like the queue in the post office - the order is by arrival.  The person who was waiting longer, gets the service first  No matter how frustrating so that you just want to buy postage and person  Who in front of you seems to want to send 23 packages  However, regardless of this behavior is called first present departures first or FIFO  This is the first part.  It is not about 23 expulsion  Imagine our index, its name (Post Office Queue), which refers to the first node in  Our linked list  Once you finish the Hank service, we can read from your next sign, and update the index  "Post Office Queue" refers to the next person in the queue  We've successfully removed Hank from the list, it's gone, it's over  If we want to add a person to the list, this will be added to the string and we must pass each  The linked menu until we reach the end, then change the next cursor to point to  The new person.  With a small change, we are able to link menus as stacks, which are LIFO  That is, the last present, departing first  You can imagine like a bunch of pancakes .. Just as you bring them, you add all the time up  the group  When you want to eat one, take it from the top of the group  Tasty!  Instead of adding and removing, the data is compressed and dragged to and from the collection  Yes, those are the official terms!  If we update the structure of the node, it contains more than one index, ie two, for example, we can make trees  So that it has another data structure that is used in many algorithms  Again, it is rare for programmers to consider the values ​​of indicators, rather than perception  Trees like this: The top knot is called the root node.  The contract that goes beyond the other contract is called children contract  As you would expect, the nodes that are above the children are called the mother contract.  Does this example mean Thomas Jefferson is Aaron Pour's father?  I'll leave it to your imagination to make a decision.  Finally, the contract that has no children where the tree ends is called a paper node  In this example, a contract can have two children, and for this reason, a structure  This data is called a binary tree.  You can easily get a tree with three, four, or any number of children with a modification  Data structure depending  You can also get a contract tree that uses the associated lists to store the nodes to which it refers  An important property in trees - whether in fact or in structuring data is that  There is a one-way path from roots to leaves.  It is strange that roots are associated with roots-related leaves,  Data that links randomly, which include things like repetitive instructions, we can use the graph  As a structure instead.  Do you remember our diagram of the cities associated with the ways in the previous episode?  They can be stored as a knot with many indicators, much like the tree but there is no concept  For roots and leaves, children and parents ...  Anything that can point to anything!  This is an overview of many basic data structures  Used in computer science.  On top of these infrastructures, programmers have built all sorts of smart variables, with the  The characteristics are slightly different - data structures such as red-black trees and heaps, and we do not  We have time to cover up  These different data structures have useful properties for certain accounts.  The right choice of data structure makes your work easier, forcing you to think  About how you want to organize your data before you start it  Fortunately, most programming languages ​​come with fully packed libraries with ready-made data structures.  For example, C ++ has a general template library and Java has a Java template library  This means that programmers do not have to waste time programming things from scratch  Alternatively, the enormous capacity of data structures to do more interesting things can be used again  Let us work on a new level of abstraction!  See you next week.  

===[=]===


oSWTXtMglKE.en.vtt   hi I'm Gail Locke McDowell author of Kraft encoding interview in this video I'm going to cover trees a tree is best thought of in this sort of picture you have a root node at the very top and it has child notes and each of those child notes they have child nodes themselves and so on and so on very often when are talking about trees we talked about binary trees a binary tree means that each node has no more than two child nodes that is that each node has a left node and a right node of course one or one or both of those could also be null very often when we're talking about binary trees we actually want to talk about binary search trees a binary search tree is a binary tree which fulfills asa civic ordering property so on any subtree the left nodes are less than the root node which is less than all of the right notes this ordering property makes finding a node very very fast because we have a pretty good idea of where it would be so suppose we're looking for 17 in this tree we can say okay is 17 bigger or smaller than the right than the root node well it's bigger than the root node so let's go to the right now is it bigger or smaller than that next node there well it's smaller than that node so it must be on the left of it and so very very quickly we can start to zoom in on where that node will be because it each operation we've chopped off hopefully about half of the nodes and we do that over and over again and very very quickly we find the node we're looking for so makes finds very very fast but how do those elements get in there in the first place well let's talk about how inserts work inserts work much like finding an element works we start with some element want to insert like say 19 and we say is it bigger or smaller than the root well it's bigger so let's go to the right now note it's smaller so let's go to the left I'm going to this over and over again until we get to an empty spot or no node and then we say okay that's where we should insert our new element now the one problem here is that if we get elements in a particular order we could get really imbalanced suppose we have a new binary search tree and we just follow the properties of insertion so we insert one and then two to its right and then three to its right and four to its right we're going to get this data structure that looks less like a tree and more like a long list and then inserts and finds will no longer be so fast there are some algorithms that can ensure that our tree stays balanced that is that roughly the same number of nodes will be on the left side of the subtree and on the right these algorithms get pretty complicated so we're not going to go into the details here but it's worth knowing that they're built into a lot of programming languages and in a lot of cases and interview questions you'll just assume that you have a balanced tree the last operation to talk about is traversing or walking through a tree so there's three common ways we walk through tree we can do an inorder traversal a pre-order traversal or a post order traversal a pre-order traversal means that you visit the route first and then you visit its left nodes and it's right notes in an inorder traversal you visit the left notes first then the current node and then you go to the right nodes in a post or adverse 'el the root node comes up so you visit the left nodes than the right nodes then the current root node typically in binary search trees we want to do inert reversals because that actually allows the nodes to be printed in order so for example on this tree here it was just a 1 a 2 and a 3 the nodes in an in order traversal will actually print it out in the order one and two and three so typically we'll see in art reversals now that we've covered the basic operations let's take a look at the code for binary search tree to implement a binary search tree we'll need a class node that has pointers to the left node and the right node and then some sort of data presumably and I'm going to give ourselves a constructor just to make our lives a little bit easier okay so the first method I'm going to add is an insert method and this is going to take in I'm going to call it value here this is going to take in a node there tip taken a node value and look to the left and the right to see where we want to insert it so first if value is less than or equal to the actual data of our node then we should insert it on the left side if there is no left node yet then this becomes my new node otherwise then I ask my left to insert it and I push that down the recursion stack and then otherwise if value is bigger than data then myself then it should be inserted on the right side and so if there is no right node put this as my right node otherwise ask my right to insert it okay so that's the basics of insert okay so let's walk through this code on an example so we have the simple tree and we want to insert the value eight so we call ten insert of eight and eight is smaller than ten so we go to the left and call left insert of eight so five dot insert of eight eight is bigger than five so we go and we don't have a right child and so we set 5s right child equal to eight the next method I'll do is find so find is going to operate recursively just like insert in fact it'll be somewhat similar in a lot of ways and it's going to want to return a boolean I'm actually going to call this contains because we're not really finding the nodes much as checking if the tree contains it okay so first of all if I'm their return true otherwise if value is smaller than data that it should be on if there is no left node then I know the answer is false otherwise if there is a left node go ask my left node what the answers okay now I do the same thing on if welcome to student else if right is null if there is no right node the answer is false otherwise go ask my right child and return its answer all right so that's it recursive plantation of contains so let's walk through this function imagining we're trying to find the value eight that we adjust insert it so we call ten that contains of eight eight is smaller than ten so go to the left and then we do five dot contains of eight five is smaller than eight and so we go to the right and then of course we see that eight in fact equals eight and so we return true all the way up the stack final method that'll implement is a inorder traversal typically I'm going to print all of the nodes in the tree so I just call this print in order and this is actually very simple first if my if I have a left child then I do my in order to running first of my left child then I print my own data and then same thing Li right if right is not null then I do right dot print in order so remember the inorder traversal z' do the left child myself and then my right child so that's exactly what the code here does so that's how we do an inorder printing let's walk through what this code does so we're going to first call ten dot print and order ten is going to say left print and order first that's a very first thing that's going to happen then we're going to print the route and then it's going to say write dot print in order so we're going to recurse down and five so we can get five dot print in five is going to say okay print got nothing on the left to print so print me next and then call write dot print in order where eight will get printed and then we're going to go back up to ten and ten is going to get printed and then we're going to go and go down to the right in that third step and print 15 so that's how an inorder traversal works if we want to do a pre or post order traversal we do a very very similar thing to send a slightly different order a pre order traversal means that the route gets printed first so we'd print the route then print the left sub-tree then print the right in a post order traversal the route gets printed last so we'd print the left then print the right and then we print the root note so it's a pretty natural translation of the algorithmic concepts a lot of times in interviews people get kind of intimidated by the idea of implanting a binary search tree they just assume it's something really challenging but if you understand the concept pretty well you can just take that and just translate it fairly directly into the code just be really careful about the null pointer checks so now that we've gone through the basic operations while you try out these concepts on a new problem good luck 

===[=]===


t0Cq6tVNRBA.en.vtt   hi I'm Gail Locke McDowell off of crack and coding interview today we talk about topics that a lot of candidates forget about heaps heaps come in one of two forms a min heap or max heap will just focus on min heaps today because a max heap essentially at verse in a min heap the elements are all smaller than their children so the root node will be the very smallest element and then looking down the tree down the heap the elements get bigger and bigger and bigger so that's the basics of what a heap is but how do we actually create and maintain such a data structure so let's start with just insertion so we insert an element it always goes in the next empty spot looking top to bottom left to right so we go first we insert an element here and then here and then here and then here and so on through the tree through the heap so that's how insertion works but then of course what happens if that's not really where the element should go well what we can do is we can insert the element there and then bubble it up too until we get to the right spot so we take the inserted element we compare it with its parent if it's out of order swap them and then keep going up the tree in this process now what about removing the minimum element so so we know the minimum element will always be at the root node and so that's easy to find but then if we want to remove it we might have an empty spot so so what we do here is we remove the min element there so we take out the root and then we swap that value at the root with the last element added and then of course that element might not be at the right spot so we take the root element and bubble it down to the next spot so we compare the root with the it's children it's left child and the right child and then swap it with the smaller of the two and then we keep going down the tree until the heap property is restored so that's how a tree operates let's think about influent how a heap operates let's talk about implementation now so implementation is kind of interesting you might have assumed that we've implemented as a simple class node with a left node and a right node and certainly we could do it that way but and even there's an even better way of employing it note that when we add elements to the heap they're always going to add it in a very particular spot there aren't going to be any gaps in the heap so we have the zeroth element here and then the first second third fourth etc and so that means that we can actually use it an array instead to store these values and that makes it very compact and a simple simple equation can map from an index to its left child it's right child or to its parent and so we can still get to the left and right child but we don't need to have this overhead of a node class so now that we've covered the basics of what a heap is let's turn to the actual code for this well implant a min-heap with a simple class that wraps this items are right this is going to be an array of a fixed length but if it gets too big we'll increase the capacity now I'm going to get a little bit of a head start and cheat a little bit by just adding in a whole bunch of filler simple helper methods so these are just simple methods that get the left and right child or the parent index actually you know check if they exist we actually get the values themselves so I'm just getting a little bit of a head start here and I'll get another little bit of a head start by adding in two extra methods here one is a swap method that swaps the values of two indices and then another one is an ensure extra capacity method now this does is it checks if the array is full and if so it creates a new array of double dot size and it copies all the elements and this by the way is the basics of how an ArrayList operates now let's turn to the real code the first method method all implement is a peek method and this first it checks if the array is empty if so we turns an exception because there's nothing at the front otherwise it just returns the first element in the array which will always be the minimum element and essentially the root of the heap this method will do is a pull method now this does is actually extract the minimum element and actually so it actually removes it from the array so first we'll check if the array is empty if so throw an exception otherwise I need to actually get the value so item is items of zero then I need to take the very last element in the array and move it into the very first element then I need to shrink my array or shrink essentially the size of it and then I need to go and actually re heapify so I removed the root element so I need to keep a fied down and I'll go fill this in this method in shortly so in this case if we remove the ten the minimum element it's going to get deleted then the 17 is going to get moved up to where the tennis so see in the array that's like this so the 17 gets put in here and then we go and adjust the heap to shift elements down as needed my next method is going to actually add an element in here so first thing I want to do is we want to make sure there is capacity so in calm I ensure extra capacity method then I'm going to add my element into the very last spot so items of size equals this new item then increase my size and then I need to actually keep if I up so I need to fix the heap looking upwards swapping each element with its parent as necessary so in this case if we want to add an element say 8 we don't add at the very last element and then we'd go and adjust our heap moving things up as necessary now for the real fun I need to actually implement these heapify methods so heapify up is going to start with the very last element added which is that size minus 1 and then it's going to walk up as long as there's a parent item and as long as essentially I'm out of order so as long as my parent item is bigger than me then hey things are out of order so swap my parent index swap my value with my parent and then walk upwards so let's walk through this on the 8 that was inserted so what we do here is we'll compare 8 to this 15 it's out of order so we'll need to swap those values so 15 goes down here and 8 goes up here or on the array it'll look like this then we compare this 8 to the 10 and then that's still out of order and so we'll go and move the 10 down and swap the 8 up there and now we've returned to the root prep to the heat properties we have a at the top 10 and 20 below it then 17 and 15 below that heapify down is a little bit more complicated but it's still quite manageable first we're going to start off with our root element which that index 0 and then we're going to say well as long as I have children keep walking down and trying to fix up my heap now I only need to check if there's a left child because if there's no left child then there's certainly no right child then I'm gonna set this smaller child index equal to the smaller of the left and the right child so I'm going to stake it guess with set it equal to the left child and then I'm going to say hey if there's a right child and my right child is even smaller than my left child smaller child index should equal my right child now what I'm going to say remember I'm looking downwards on the heap so now I must say is hey if items of index if I'm smaller than the smaller of my two children then everything's good and everything's back in order here and I can just exit if that's not the case then our heap is still out of order and then I need to swap my value with my smaller child and then move down to my I'll just actually move this out here alright so that's the basics of how heapify down works let's walk through this on an example I'll make this example slightly larger so if we do an extract min such that 2010 gets removed then we move ten we replace it with 25 I'll do it on the array to shouldn't see what's going on there then we compare 25 the route and replace it with the smaller of its left and right child so we swap the 25 and the 15 so 25 comes down here 15 comes up there and we can do it down here too so 15 goes here 25 goes here then we compare 25 to 17 it's still out of Orsat order since 25 is bigger than 17 so we do 17 comes up here we swap those and 25 goes down here so now we have a heap again that looks like 15 17 20 and 25 and as you can see our min heap property has been restored so now that you understand what if he bids and how it works why don't you try out using a heap on a new problem good luck 

===[=]===


jc1t0KFsOcs.en.vtt   before learning any language learn data structures oh-ho-ho I know you're pushing there you might be thinking what is data structures and what is so important let's find out welcome back aliens my name is Ivan 20 and let's get started we are living in an Information Age now what does that mean it simply means that everything around you it's all about information the IT industry which you are working with its IT which is information technology right so what they need is information but we have to store that data somewhere right and that's important avoid data how can you store that data because after that after processing that data you will get information right but how do you store that data no data can be of different type right it can be a normal data it can be a complex data so it's all about how to store it now why is reading is so important we can simply fetch data and put it somewhere right take a file put your data there no it's not that simple it's not just about storing data it's also about how can you fetch that data in efficient way how can you process that data in efficient way so with that data you will do lots of thing so you have to build a solution in such a way or if you have to store your data in such a way that it will be easier for you to fetch it to process it and to you know again shut it somewhere and that's why we have this concept of data structures so before learning a language if you understand what these data structures it will be easier for you to understand how that language works right in fact if you have learned any programming language before maybe C or Python or Java in that we use certain things for us arrays we use least so to understand those concept data so it is very important so data structure is all about how can you structure your data so that you can store it and use it efficiently again there are certain algorithms you can you can implement on that if you heard about this concept of searching techniques we have sorting techniques so we can apply all those techniques only when your data is properly structured now how do we store that data so what we have a concept called as abstract data type it simply means you can store your data in you to work in future example we have a concept of least so if you want to save data in sequential format we can actually use lists we also have a concept of stack so let's say if you want to sort everything sequence format we can cover list maybe you want to you know when you say windows tab or all tab in Windows or in any OS it will show the recent applications right now if you remember the first app it shows you is the last which you have accessed which means last in first out so at that point we use stack some sometimes we have to track each and every note so we simply use linked list all other other concepts one more thing the least fancy which are talking about that's an abstract concept because every language have a different way of implementing it and the actual implementation like link list we have at least in Java we have those two things so data structure is all about how do you store your data now push our eyes why it is so important now I mean of course it was important before as well but nowadays we have this boom of data structures right everyone want you to know data structures in fact if you go for the job interviews as well so initially they used to ask about programming language they used to ask about mathematical things now they talk about data structures they will ask your question based on data structures and talking about all the companies there's a might of Google Facebook or Apple they will start asking you a question on on data structures but why why now it's because the world is changing yeah thanks to this concept of big data every company they have huge amount of data with them how do you process them how do you store them so they we have different frameworks like Hadoop spark to process the data and the base of all those things is data structures if you understand it has structure it will be easier for you to understand the beta beta frameworks thanks to AI you know machine learning how will you implement AI if we don't have data and to store the data we need data structures right so the base app for everything is data structures so it's important for you now to understand data structures if you want to get into big companies and plus there is one more thing here you know the you're learning data structure will be helpful for you when you start learning different languages because every language have their own way of implementing it maybe Python or C or Java so they have some inbuilt things you can use it only when you know how that works so that's how you should be data structures and data structures is all about storing data and using it efficiently right so in the coming upcoming we'll talk about how do we implement some data structures and what are the algorithms available so that you can implement it I hope you like this video let me know in the comments section if you liked it and click the like button if you really enjoyed it and this is Chi power for the videos thanks for watching 

===[=]===


z2pjGiaDUPo.en.vtt   in computer science data structure is a study of various ways of organizing data in a computer so that it can be used efficiently invariably the information contained in a data structure is manipulated by a systematic and step-by-step process which is called algorithm the manipulation of data structure may involve such operations as adding an item searching for a particular item deleting an item rearranging data items in different ways thus data structures and algorithms are closely linked together and play a complementary role in many applications over the years data structures have gained significant importance because of their usage in several disciplines data structures are an integral part of modern operating systems compilers database management systems data communication and assistant software likewise algorithm together with associated data structures have widespread use in several applications including image processing digital signal processing simulations numerical computations cryptography data compressions and genetic studies in this introductory unit we shall introduce basic terminologies and concepts concerning data structures data types all programming languages provides some built-in data types which are useful for efficient coding of programs the predefined data elements are separated into two classes which are known as primitive and composite a primitive data type defines a set of values and operations that can be performed on these values the familiar primitive data types are integers real numbers characters and boolean which is supported by almost all programming languages a boolean type can have only two values two or false the basic operations on these values are and or and not an integer type can assume different set of values depending on implementation in a particular language the set of basic permissible operations on an integer type are for example arithmetic operations and comparisons operations the primitive data types are also called atomic are irreducible because these can not be expressed in any other basic types the primitive data types are always supported by the underlying hardware features and to a lesser extent by the compiler systems this means that the range of values and allowed operations depend primarily on the hardware circuitry in general the number of bits allocated to each type decides the range of values for example an integer type is often implemented using a 32-bit storage representation with one bit reserved for sign in this way the integer type can have a range of values over a billion characters are implemented by using 8-bit for ASCII and app stick representation and sixteen bits for Unicode the late representation allows a range of values of a 65,000 for encoding characters the operations on primitive data types are often included in CPU instruction set when such support is lacking the compiler depends on built-in software routines a notable example is the implementation of floating-point operations on small computers which do not have floating-point circuitry the real numbers are manipulated using software instructions of course this approach considerably reduces the computational speed often by a factor of 100 mm different programming languages provide a variety of primitive data types which are identified by language specific keywords for example Java defines 8 primitives an important feature of Java primitives is that each data type is made up of a fixed number of bits which is independent of a particular implementations for example an int type always consists of 32 bits and character of 16 bits on all platforms C C++ provides an assortment identified by the syntax int float character double the numeric type may be further qualified as short or long signed or unsigned C does not support boolean data type instead numeric 0 and known 0 values are interpreted as false or to further the size of C C++ data type varies with platform dependent Visual Basic provides supports for all basic types identified by the keywords integer long single double byte and boolean the primitive types can be created as local or global with each type preceded with the word public or dem composite data types are larger and more complex data types which are defined using combinations of primitive types the common examples of composite types are arrays vectors and strings an array is a collection of homogeneous data almost all programming languages support arrays as built-in data types we shall explain the detailed properties and uses the phrase in a subsequent unit vectors are essentially a mathematical representation of arrays they differ from ordinary arrays in their implementation for example Java provides vectors as an array of flexible sized strings are combinations of characters the support for strings as a built-in datatype varies a great deal with the programming languages if string is defined as a primitive data type string data is stowed in an array of characters with a special delimiter this is the approach followed by C C++ adder and Pascal in C C++ for instance a string is represented as array of characters with the null character in the last position Foton 90 and visual basic provides support for strings as primitive datatype with associated operations of assignment join comparison and substring references in java strings are supported as built-in type of string class data structure the built-in data types provided by programming languages are adequate for solving simple problems in fact all computer applications in early days dependent exclusively on the built-in elements of the host programming languages for disturbing and processing of different data types this was particularly true of numerical or scientific oriented problems with the dramatic increase in the use of computers in various disciplines it was realized that the primitive data types were not sufficient or powerful enough to solve advanced problems involving complex structural relationship among data items the need for new data types was further exacerbated by the recent paradigm of object oriented approach to problem solving data structures are meant to serve these needs simply stated a data structure is a programming construct that Stowe's a collection of data items at first sight data structures might appear as an extension of composite data type this is true in a limited sense actually there are two subtle differences first the term data structure and campuses composite data type defined in a programming language it may even be a user-defined type to serve a particular application need second and more importantly a data structure implies some kind of organization or relationship among the constituent data items for example a character string whether defined as an array of character are treated as primitive type has a definite order of organized characters and alteration in the order changes the memory and characteristics of the original string on the basis of structural relationship the data structures are classified into two types linear and nonlinear a data structure which organizes data elements in a sequence that is one after the other is referred to as linear array is a common example of linear data structure that exhibit linearity other examples are linked lists stack and queue we shall dwell at length on these data structures in later units here we briefly introduce these types a linked list consists of data items called nodes each item contains an information field and a link field pointing to another a stack is a data structure which works on the principle that last item added to the collection becomes the first item that can be taken off like a pile of trays it is also called lympho last in first out data structure Accu is a data structure in which an item can be added at one end and an existing item in the collection can be removed from the other end it works on the principle FIFO first-in first-out in a nonlinear data structures the relationship between the elements is more complex it can be for example hierarchical that is one element may be linked to more than one element in the collection further the linkage may be single or bi-directional the nonlinear types are also referred to graph data structure common examples of nonlinear data structures are trees and graphs a tree is a data structure consisting of a set of data items called nodes which contain an information field and linkage to one or moded items in a hierarchical order there are several variations of trees some useful types are referred to as binary trees AVL trees red and black trees splash trees B trees and heaps we shall study their properties in a later unit a graph is a set of data items called vertices are nodes connected by lengths edges or arcs you 

===[=]===


92S4zgXN17o.en.vtt   in this lesson and in this series of lessons we will introduce you to the concept of data structures data structure is the most fundamental and building block concept in computer science and good knowledge of data structures is a must to design and develop efficient software systems ok so let's get started we deal with data all the time and how we store organize and group our data together matters let's pick up some examples from our day to day life we were organizing data in a particular structure helps us we are able to search a word quickly and efficiently in a language dictionary because the words in the dictionary are sorted what if the words in the dictionary were not sorted it would be impractical and impossible to search for a word among millions of words so dictionary is organized as a sorted list of words let's pick up another example if we have something like a city map the data like position of landmark and road network connections all this data is organized in the form of geometries we show the map data in the form of these geometries on a two-dimensional plane so map data needs to be structured like this so that we have scales and directions and we are effectively able to search for a landmark and and get route from one place to another and I'll pick one more example for something like daily cash in and cash out statement of a business what we also call a cash book in accounts it makes most sense to organize and store the data in the form of a tabular schema it is very easy to aggregate data and extract information if the data is organized in these columns in these tables so different kind of structures are needed to organize different kind of data now computers work with all kind of data computers work with text images videos relational data geospatial data and pretty much any kind of data that we have on this planet how we store group data income in computers matters because computers deal with really really large data and even with the computational power of machines if we do not use the right kind of structures the right kind of logical structures then our software systems will not be formal definition of a data structure would be that a data structure is a way to store and organize data in a computer so that the data can be used efficiently when we study data structures as ways to store and organize data we study them in two ways so I'll say that we talk about data structures as one we talk about them as mathematical and logical models when we talk about them as mathematical and logical models we just look at an abstract view of them we just look at from a high level what all features and what all operations and define that particular data structure example of abstract view from real world can be something like the abstract view of a device named television can be that it is an electrical device that can be turned on and off it can receive signals for satellite programs and play the audio video of the program and as long as I have a device like this I do not bother how circuits are embedded to create this device or which company makes this device so this is an abstract view so when we study data structures or or as mathematical or logical models we just define their abstract view or in other words we have a term for this we define them as abstract data types an example of abstract data type can be I want to define something called a list that should be able to store a group of elements of a particular data type and we should be able to treat the elements by their position in the list and we should be also able to modify element at a particular position in the list I would say store a given number of elements of any data type so we are just defining a model now we can implement this in a programming language in a number of ways so this is a definition of an abstract data type we also call abstract data and data type as ADT and if you see all the high-level languages already have a concrete implementation of such an ADT in the form of arrays so arrays give us all these functionalities so arrays are data types which are concrete implementation so the second way of talking about data structures is talking about their implementation so implementations would be some concrete types and not an abstract data type we can implement the same adt in multiple ways in the same language for example in C or C++ we can implement this list ADT as a data structure named linked list and if you have not heard about it we will be talking about them a lot we will be talking about linked lists a lot in the coming lessons okay so let's define an abstract data type formally because this is one term that we will encounter quite often abstract data types are entities that are definitions of data and operation but do not have implementations so they do not have any implementation details we will be talking about a lot of data structures in this course we will be talking about them as abstract data types and we will also be looking at how to implement them some of the data structures that we will talk about are arrays linked lists stack queue tree graph and the list goes on there are many more to study so when we will study these data structures we will study their logical view will study what operations are available to us with these data structures will study the cost of these operations mostly in terms of time and then definitely we will study the implementation in a programming language so we will be studying all these data structures in the coming lessons and this is all for this introductory lesson thanks for watching 

===[=]===


pmN9ExDf3yQ.en.vtt   hey guys in this video I'm gonna give you an introduction to erase and a quick overview of how memory works and this video it's gonna be split into three parts first of all I'm gonna cover the basics of arrays and this part is gonna be pretty basic so if we already familiar with erase don't worry about watching this part and in the second part I'm gonna cover what memory is as opposed to storage and finally I'm gonna cover how integers and integer arrays are stored or memory arrays and memory or two of the fundamental topics in data structures and algorithms so let's get started okay so first of all what is an array an array is basically a collection of items of a single type so an example would be this one which is an array of integers or this one which is an array of strings and it's not usual for an array to have multiple types so it's not usual for us to have something like this where this array has both strings and numbers inside and let's take a look at some code snippets in C here to see how you can use arrays in practice I'm only gonna take a look at C here but it's gonna be pretty similar to other languages too like Java this line int sample array square brackets 5 equals 2 4 6 and so on says create a new array with five integers and then populate it with the elements 2 4 6 8 and 100 and you can visualize this array as a box with 5 partitions because this array is able to contain 5 integers if you want to change some of the elements in this array of course you can use code like this the first line says change the first item of this array to 20 and then the second line says change the second element of this array to minus 5 so after executing these two lines of code sample array will look like this you can see that the first two elements have been changed but not the other three elements and of course here the index of the array starts at 0 instead of 1 and it's not necessarily the case with all the languages but this is what we're going to use throughout this course - now what if you already have five numbers in this array and you wanted to add two more numbers let's say two and three after the fifth item you might say well why don't you just add two more partitions at the end of this array and then put those numbers in there but actually you can't do that and to understand why that's the case why you can't add more partitions at the end of this array I'll need to give you a quick overview of how memory works on a computer okay so what is memory exactly for me to explain what it is the first thing you'll need to understand is that there are mainly two mechanisms for storing data on your computer the first one is memory or it's sometimes called RAM and the second one is storage which has different types for example a flash drive hard disk or a solid-state drive now the biggest difference between storage and memory is that the data on storage is permanent while the data on memory is not what I mean by that is you know if you think about your laptop when you turn off your laptop the data on storage will still be there but the data on memory will disappear as soon as you switch off your laptop so if you think about the bunch of photos you have on your laptop you know when you turn off your laptop and turn it back on again they should still be there right and that's because they're on storage and not necessarily our memory so like I said the data on memory on the other hand just disappears when you switch off your computer have you ever had an experience where you started working on an essay or you started drawing something on your computer and then suddenly you just lose all your progress because your computer crashes and then it shuts down and that's probably because those documents were on memory but not necessarily on storage so when you you know work on those documents and when you hit the Save button that finally becomes a file on your computer on storage this time so that the next time you know your computer crashes it's still gonna be there so at this point you might say wait why do you need these two separate mechanisms then why can't you just store everything on storage well the thing is reading data from and writing data into storage is pretty slow it's sort of like walking all the way to the file cabinet you have in the basement to retrieve you know the files there whether there are photos or documents it is necessary sometimes because that's where you have those documents but if you do it too often it's just gonna take too much time and that's actually where memory comes in memory is sort of like a temporary desk you have in your room so once you retrieve those documents you know from your storage whether they're text documents or photos you'll be able to put them on your desk or on your memory and once they're there it's gonna be so much faster to work with them and the reason it's so much faster is because it's so much quicker to write data into and read data from memory than it is with storage and then once you finish working with those pieces of data on your memory once you finish editing them and modifying them then you can bring them back to your storage so that you can save them they're more permanently as computer files again so that's the gist of how memory and storage work together with files and the way they work together for applications is actually pretty similar so when you have applications on your computer they're stored on storage originally and you can easily tell that's true because when you you know turn off your laptop and turn it back on again those applications are still gonna be there but when you launch one of them let's say Google Chrome it's gonna be loaded onto memory so that it's faster to use and you know faster to access there and so if you start running too many applications at the same time you know they're all gonna be loaded onto memory and you might actually start running out of memory space and that's why you know that's one of the reasons to many applications at the same time on your computer might actually slow down your computer and let's now see how this whole thing actually looks on my computer since I'm using a Mac if you want to get an idea about how much memory I have you just need to click this Apple icon and then about this Mac and you can see that I have eight gigabytes of memory here now what about storage for storage I have 251 gigabytes and actually one feature of storage is that it's usually much bigger than memory and actually on the Mac there's a way to get a rough idea about how memory is being consumed you can just open Activity Monitor I think there's something similar for Windows 2 and here you can see that for example Dropbox is using about two hundred forty megabytes of memory and Google Chrome's using about 100 megabytes of memory and what happens if I go to Chrome and quit this application it should stop consuming so much memory right let's see if that works I'm gonna quit Google Chrome and it's no longer here now how is all of this related to programming and in particular using a race to understand that let's take a look at this piece of code in C this line int a equals 1 when you compile and execute this line of course a variable called a is created and the integer 1 is assigned to that number and this integer 1 is stored on memory and not on storage and that means that when you turn off your computer after executing this code this integer 1 will just disappear because everything on memory of course disappears when you turn off your computer but how is this integer store on memory exactly for me to explain that you'll need to understand two things the first one is that each integer when it's stored on a computer it's often expressed as 32 ones and there's so for example the number one can be expressed as a bunch of zeros and then one at the end actually that's 31 zeros and then one one at the end and the number two then one and then there again that's actually 30 zeros 1 1 and then 1 0 and just like that pretty much any integer that you might encounter in real life whether they're 100 or 200 or minus 223 each of them can be expressed as thirty-two ones and zeros now each of these zeros and ones is called a bit so a bit is either 1 or 0 so we say each integer can be expressed with 32 bits and you don't have to worry about how it's converted exactly if you don't know about it yet but just know that pretty much any integer within a reasonable range can be expressed with 32 bits or 32 ones and zeros okay the second thing you'll need to understand is a simple model of memory memory can be thought of as a long tape of bytes now what is a bite a byte is basically a small unit of data and it consists of eight bits so each byte might look like this Woori has eight bits or this one now you can visualize the simple model of memory along table bytes like this so this is the long tape and each of these compartment represents each byte so you can sort of imagine a bunch of bits eight bits to be exact being crammed into each of these compartments and then you can store bytes which are of course small units of data in these compartments to represent anything you want to represent on your computer now your computer needs a way to find any particular byte very easily and you want to be able to do that because you want to be able to do things like store two bytes in these two compartments and then store four bytes right after that and maybe retrieve two bytes from the first two compartments and your computer achieves it by assigning an address to each byte and each of those address is represented by a sink integer so in this hypothetical example we have the address 124 despite and 121 for this byte and so on at this point you might say wait why do we have these particular numbers 120 121 and so on representing the addresses for these bytes well the answer is you know I came out with this arbitrary number 120 to represent the starting address for these bytes but in reality you don't have to worry about it and you know how to worry about it because the operating system determines what this starting address will be for your particular application so basically the operating system whether it's Mac or Windows this size well your application should live over here in memory and then someone else's application let's say Google Chrome should live over here and so on but the important thing to understand here is that even though the starting index 1 to 20 is arbitrary here the way you have consecutive addresses 1 to 20 121 122 and song that's exactly like a real system on your computer anyway like I said earlier each integer can be represented with 32 bits sometimes depending on the environment it's stored with 64 bits instead but let's just say 32 bits for now and the question I have here for you is how many bytes do you need to store each integer well that's pretty simple because you have 8 bits in each byte so if you have 4 bytes you can store 4 times 8 bits which is 32 bits which is just enough to store each integer so how can we store an integer on memory you might say wait why don't you just take 4 bytes the four consecutive bytes right here and then use that to represent an integer and that's exactly what a real computer does so in this particular case when you have int a close one one is first of all converted into 32 bits zeros on ones and those bits will be split into these 4 bytes and then they're gonna be stored right here on those 4 bytes if you have one more integer for example int B equals three right after this line that variable will be stored on those four bytes right after the first four bytes so that's how integers are stored on memory but actually the idea is gonna be the same for things like this mouse or characters you might need a different number of bytes to store each different type of data 2.3 or a or whatever but the idea of using consecutive bytes to store each piece of data is exactly the same anyway what if you wanted to store an array of integers instead of single integers to see how that can be done let's take a look at some more code in C here and let's say just like before we have int a equals 1 then that integer a or 1 will be stored let's say in these 4 bytes from 122 123 and let's say right after this line we have this line in sample racecar back at 3 e goes 5 3 and 20 this array will actually take 12 bytes right after the first 4 bytes so that's from 124 to 135 right here and we need 12 bytes because we need to be able to store three integers so that's of course 3 times 4 equals 12 bytes and the first number 5 will be stored in the first 4 bytes so that's from 124 to 127 right here and the second number 3 will be stored in the 4 bytes right after that naturally so that's from 128 to 131 and then 20 will of course will be stored in the last 4 bytes right here now the question we asked ourselves earlier was why can't we just add two more numbers let's say 1 and 2 to the end of this sample array you know if you look at this model of memory it looks like we'll be able to just allocate 8 more bytes over here and then use those 8 bytes to store these two integers but actually you can't do that to explain why you can't just do that why you can't just allocate more memory allocate more bytes right after this array I would actually need to explain a little bit more about how memory works exactly but let me give you a more simplified argument here instead the simplified argument here is that after this line after allocating 12 bytes for this array we don't know what's gonna be right after that in this memory space so for example you might have this line int C equals 4 right after this line in that case this number 4 would be stored in these 4 bytes from 136 to 139 and when you store an array you need a bunch of consecutive bytes and that's basically why you won't be able to just add more bytes to this array and actually if you wanted to still add 2 more numbers to this array what you would need to do is you will need to create an entirely new array you know over here in memory and you would need to make that array longer than the original array you know let's say length 5 instead of length 3 and copy over these numbers one by one to the new array and you would probably create this array dynamically and this word dynamically is important but if you don't know what it means exactly don't worry about it for now and then if you wanted to add even more numbers let's say three more numbers to the new array that's longer than the original rate then you would actually need to create a new array again which is even longer than the second array and then copy over all the elements to the new array again so you might think this whole strategy is a little bit awkward because you need to keep creating new arrays and maybe keep deleting the old arrays but that's actually what's used in practice often so if you wanted to create sort of a resize of all array you know a kind of array a kind of new array you might say that can accommodate as many elements as you want to put in there this is one strategy for doing so for this you know resizable ray you can initialize it as a small array let's say ten elements and then when you want to put in the eleventh element you can make a new array that can accommodate you know twenty items instead and then copy over old items to that new one and then keep going like that you know 28 forty elements and then length eighty and so on and this is actually the essence of how many sort of resizable arrays work in different programming languages so for example in Python you might see you know the Python lists and in Java you might have used the array list they might not look like resizable arrays when you look at them or when you use them but actually if you look at the source code if you you know sort of look inside a hood that's how they are implemented okay so this was actually a somewhat simplified explanation of these topics arrays and memory and you'll be able to actually start using them to start building more complex data structures that you got to learn throughout this course like hash tables and trees and by the way when I was doing some research for this video I actually used this video sponsors website a lot and it's called brilliant org so for my research I was using this computer memory course and the section I used the most is called linear memory model which is in the introduction to memory chapter this linear memory model section basically gives you a more detailed picture of what I explained in this video about memory and it comes with a bunch of practice problems too like I said in my last video applying what you've learned is through solving problems is a good way to solidify your understanding of the topic and personally I found that going through this section helped me refresh and solidify my understanding of how memory works and this linear memory model section actually assumes that you're already familiar with binary and hexadecimal numbers so if you want a quick refresher on those I'd get started with the previous section instead and that one is called binary this mode and hexadecimal if you want to check it out for yourself you can go to brilliant org /ch dojo okay as always i'm YK from CS dojo thanks for watching and you know hopefully you can keep what you've learned in this video in your memory as well as your storage I guess anyway I'll see you guys in the next video 

===[=]===


cNEz-UWxyn4.en.vtt   hello everyone and welcome to today's session on data structures now we've already done a session on data structures I'm tying back in which we discuss about the very basic nitty-gritty details of why we use a data structure what's the point of having a data structure what is a data structure the different different types of data structures etc you know all those details went in there now in this session I'll walk you through n commonly asked questions in data structures now these questions are like very basic questions again which a fresher is generally asked about when he is going for a technical interview so just to test the waters rate whether he knows about data structures or not what are data structures etc check try to test his basic knowledge and once you know what it it has structure is how it works in functions in what all operations can be performed on it it is very easy to write an algorithm on a data structure or write a program based on a data structure so we'll get you familiarized in this session with the basics of what all can be done with the data structure what the basic questions can be asked in an interview and data structure so that you get prepped up for your interviews coming and also this will lay a basic foundation ground for you to go ahead and deep dive more into any of these data structures feed linkless be it stag beat queue or three anything so once the basics are covered once your foundation of the building is strong then you can go ahead and build more and more and more structure on top of it so the session will basically deal with the founding or foundation of data structures so starting off I see many of you have only joined Akshay Thomas such meter it a little sad right so hi and let's start of the sessions without any further ado and one more thing that I would like to stress on before I start this session on data structures is that coding while is one thing the more you practice the more you will understand it but detail structure for understanding it better what you need to first do is understand the structure of the data that you are going to follow how it's going to operate so let's if we are talking about Q how data is going to be inserted in a Q how it's going to be deleted from the Q the basic you know functionalities you should be aware of to distinguish between one from the other and once that is there once the picture the basic layout is clear then implementing those data structures in your programs become fairly simple and easy it's like cakewalk after that because you know basic programming you know loops you know you're right rations and you know the foundations of data structures right so mixing them together and getting done what you really want to do then becomes fairly simple so let's go ahead quickly jump onto the session so the very first thing that anybody asked or would want to know about when they are talking about you know data structures in detail would be what do you understand by data structures right what is your understanding of data structure what why data structures are used basically to be precise right so the very simple example that I like to quote and relate it to real life while explaining data structure is you can see this image of a room okay and the image of the room has a lot of things spread episod here and there great your laptop is somewhere your photos are somewhere your books are somewhere twice or some of the clothes are all spread around fine a very chaotic room to be precise now in this chaotic room if someone asks you to go and find a particular book or find a particular kind of shirt or t-shirt for you to wear it is going to be like a madness in there for you you will be searching here there everywhere because you don't know what is where the things are not organized properly for you to pick up what you want right so as soon as you enter the room the situation is going to be pretty chaotic and dramatic in there and this is how you're going to be figuring out what is where because assessing what you actually really want to assess is going to be very difficult in a situation like that now consider a completely opposite situation when the room is neat and clean your clothes are nicely folded and organized in piles in your cupboards your books are in the bookshelves your toys are in the toy wardrobes everything is nicely laid out in the room now if someone again asks you to go ahead and search for something in this situation in an eating clean room where everything organized and put in a nice pile it's it's really simple for you to you know go ahead if you have to go search for a book you will directly go to your book rack it's all laid out nicely section by section so you'll go to the section for which you want to pick the book take it out and be done with it similarly if you have to pick your clothes you know your cupboard where it is go ahead open it all the shirts are nicely laid out in front of you pick whatever color you like and be done with correct so similarly what data structures do I they are like this organization of data for computers so that number one the computers can handle the data on ISIL and number two you can assess the data easily and fast whenever you want to assess the data Craig sorry for the no audio and so that you don't have to wonder about where the data is and you know what is happening with the data and you simply have to so data structure as you can see on the slide now I think mmm the audio problem is fixed I hope now you will be able to hear me so a data structure is simply a way of collecting and organizing data in a computer so that it can be used efficiently right so that you can go ahead and you don't have to wonder about happy sadly where my data is what I have to search for you don't have to you don't worry about when you're looking for the data so data structure helps organize this data in your computer systems so that you can go ahead and efficiently and utilize this data you can assess the data faster that is the simple mechanism or the simple purpose of having data structures in the programs right now that is why we use data structures now what is a data structure we'll look at so the basic type of data structures as we discussed anything that can store data can be called a data structure right you are simply organizing your data together so from primitive data structures like integer float boolean care etc to abstract data structures like link lists tree graphs all fall under the category of data structures now before I jump further into the questions I have a few questions here from you Rogers asks can you please tell me the topics that will be covered in this session Roger will be covering stack trees graphs and as well as queues so basic introduction of all these four things and what is going to be covered in detail is depending on different different data structures like traversals insertions deletions etc basic functionality of dealing with every type of data structure okay Naga Lakshmi has us it is a specialized data for storing organizing and retrieving data that's correct data structures allow you to store data retrieve data as well as organize the data based on your requirement so you choose which data structure to use based on what requirement you have write further down find the audio is perfect now so I'll go ahead with further questions and go ahead with stack at any point of time if you guys have any doubt keep posting it on the chat and we will keep discussing it simultaneously so moving on after the basic types of data structure let's start off with the second most frequently asked question what is a linear and what is a nonlinear data structure so how do you differentiate between linear and nonlinear data structure now I want you guys to quickly drop in a chart whatever linear or non-linear data structure you know or what do you understand by linear and non-linear data structures someone Rita is asked when can we watch this session later of course I'm Amita you can watch this session later you can go to the YouTube channel and there you can go ahead and check this session so go to the YouTube talentsprint IIT channel you'll get this particular video at the very front once the session is done three dancer that's a nice name he's asking please elaborate ADT okay we saw a DD I think abstract data types you are referring referring to so AD these are the abstract modes of organizing your data like linkless tree graph so there isn't actually a linked list or a tree or a graph that is how you represent your data using whatever you have at hand so you can create a linked list using arrays you can create a tree also using arrays depending on what you are creating it's it's an abstract concept it is the layout that you have in front that tree okay does this assist this is how you will stroll good tree now how it's actually done is what is done using the primitive data types or our loops or I trations etc but these abstract concepts of storing your data so that the assessing of data and the retrieval of data and the manipulation of data becomes faster in easier that is what we call as abstract data types all right so moving back to linear and nonlinear I see many of you have posted your comments let me just quickly walk through that which data structure big company used Rahul fadila is asking like Google Amazon Flipkart Rahul there is no particular data structure being used by a particular company depending on what project you are working on what is the requirement of the project what component you are developing whether it is server side component or whether it is dealing with customers or you are creating a software you are creating a website all these requirements come into picture when your project managers actually are deciding that which are even developers senior developers decide that which data structure is going to be used so all these things come into play when you are deciding what data structure is to be used what database is to be used what language is to be used it's decided at certain level right then it comes down to developers that okay using this Diseases technology you have to create this project correct so there is no one such data structure that any company uses any company can work on multiple data structures or even single data structure depending on the requirement of the project or requirement of the software that they are making so ideally big picture you need to be aware of all the data structures you cannot get away with knowing just one data structure right okay Prem Kumar says linear means sequencing like area linear is sequencing like array data is so far up sized data is organizing in linear way okay that is a very abstract statement sort of data is organizing in a linear way I am NOT able to if I would have been your interview I am NOT able to make out anything from this sentence what are you trying to say so I think you need to rephrase your sentence and then let me know Raju but Val's say stuck okay stack is what raju argot says array linkage stack q linear and non-linear tree graph that is a perfect answer so far stack and Q are linear data structure Thomas is also correct graph there is a question mark Anil Kumar says graph question mark graph is okay so for all of you out there if you don't know by now linear data structures are organized in linear way so when you see an array you see one two three four the data is organized in a linear way if you see a linked list again one node pointing to the other to the other to the other again linear way organization right now moving on to graphs all trees there's one node there are two China's there are three China's there are five child nodes so you see the structure of a tree or a graph for that matter is very happy hard structure you don't know which route to follow what to do top down bottom left right center so those are called grafts entries are nonlinear data structures right so graph Anil Kumar's a graph question mark graph is a nonlinear data structure anilinium in sequence yes assessing of data in a linear way all trees are nonlinear someone with a said that's true someone with our linear data structure traverses the data elements sequentially okay this is from Ramat elements sequentially which is true one by one you traverse through a linear data structure in which only one data element can directly be reached that's again right so let's take for example a linked list you at a particular time point in time you SS one date then you move on to the next node you get to the know the value of the next data then you move on to the next thought you get to know of the value thanks data same thing happens in the tree structure as well when you're pointing to one particular node you know the value of that particular node right but in tree you can move back left right you can go back to the parent you can go to the left rail you can go to the right child but in a linked list you can either go forward or backward in the same sequence it's sequential right that is why it is called linear and what else do we have Naga Lakshmi said dear I cannot be assist in linear way then it is called nonlinear that's again correct Balu is also correct finds most of you are aware of linear and nonlinear concentrate that is what I am getting from your answers here linear data priyanka says linear data structure means data is stored in linear manner and we have to go through each node and it is organized in a linear way so upset data is organized in a linear way yeah so that's all that you assess sequentially the data is organized in a linear way and that is the difference between linear and knowledge you know if you have to classify your stack your Q your linked lists fall into linear and your graph entry fall into nonlinear fine now further moving on to the next one link list all right so go ahead I will take a pause read out what's written in there and then I'll explain to you link list Gokul adapt I hope I am pronouncing the name correctly is what is the Q Gokul will take a look at Q in a white and sweet answer ask me another question what is data abstraction data abstraction is not a data structure concept basically it's an oops concept where you hide a relevant data and just show the relevant data to your programmers or to the customers so let's say you don't want someone to bother about what is going on behind the scenes you hide your data and that is a oops concept Java just joined hi jaywant so nib is asking tell me some of the websites where I learn Java easily Sandeep the best way and the easiest way to learn Java would be download JDK download eclipse and start writing a simple hello world program and you know Eclipse comes with this help tooltips right where you can go ahead and check what how to learn the volge our documentary learning is there in Eclipse itself so go ahead download eclipse get yourself familiarize with how to use Eclipse you can watch the tutorial that we have on how to use Eclipse and that one thing only downloading that Eclipse and sitting on the Eclipse for half an hour using the help tool from Eclipse itself is good enough for anybody to learn Java programming such media is asking how to apply for technical jobs Sushma you can if you are in a college I hope you have campus placement options where companies come in your colleges and higher so be prepared for that create a nice resume you can upload it up on portals like nakri or monster and then you can also be part of exams like Co Cube's etc where when you get a decent score companies call you up for interviews so try all those options Javon says download documentation related to Java you can do that as well but most of the documentation related to Java would also be present in Eclipse itself so you don't even have to bother about downloading the documentation I'm hoping you guys have all read this once I'm done with the comments we'll come back to a linked list degree finally students what have to prepare for technical round okay so now angle Laxmi is asking final year students what do you have to prepare for technical rounds so if you are a final year student it is expected that first off whatever you have studied from first to fourth you're like if you have started with C in the first year and data structures you would have studied you would have studied data algorithm you would have stayed studied networking is well if you are an engineering grand so all those topics and courses should be at least theoretically strong and sound in your head apart from that if you have done any course or any internship during your third year you should be well thought of with what project you created what internship you did what work you did in your internship etc all those details should be very clear to you because you have worked on it and you're projecting it in your assuming that you have worked on it so if some question is asked around those topics you should be very clear and confident about okay I did this and I am aware of what I worked on apart from that I think any programming language a solid knowledge right so if you say a posse Arthur you should be very well aware of all the things that can be done in C if you are asked to write a simple program in C you shouldn't hesitate doing that go ahead be confident sit on your system and write the program be done with it or if let's say you're not very confident with C because you read it in first year and maybe in third year you worked on Java such as project Java here as you may see the Carnegie's or Athenian you say you are familiar with Java you understand Java bit better and you are aware of this is this is concepts in Java right now Java is also very vast language so if you are not aware of some topic someday tree you haven't touched so far be very clear about that that okay this portion of Java I'm not aware of this is what I know so the interviewer will be considerate enough and you know he will appreciate the fact that you know what what your solid points are so he asked you questions around that only so that's all keep practicing coding if there is a coding round happening you should be able to clear that to reach the personal interview rate so do that okay sort of ask me a question I have a doubt the way of assessing of tree is linear way that why we called tree assessing is not a linear way accessing tree is this so see you're confusing way of assessing with the format the sequential and non sequential format now way of assessing will of course be linear because you are let's say start assessing from the root node if you are at the root node then you'll jump onto either left or right whatever you decide you will ultimately be sequential only but you have two options left or right now similar in a linked list when you have to move on to the next they go left right there's one next right so that is what I mean by sequential you go ahead one after the other after the other there's no left right like in graph one node can have three four nodes attached to it now depending on your requirement what you want to do or depending on your programming where you want to go decide in that lawn non linear structure way to go right but in linked lists one after next after next after next that is what we mean by linear and nonlinear okay which chattels results which way I can prepare for logical programming logical programming is a very abstract concept tattoo and see if you have to do any kind of programming it's all about your problem-solving skills comes down to boils down to your problem solving skills so if you are given a problem how easily and quickly can you break it into small small problems that can be easily solved and the output of first small problem can be used as input to second then so on and so what and then finally you get your result right that is how any big or small program is written so programming is nothing but your ability to just you know sort out the problem divided into a smaller chunk of problems and then get it done right so logical programming again practice I would say go ahead and practice more of logical programming questions keep programming on a clip so that you get to know where you are missing out if you are writing a program and you get ten arrows in your first program don't panic out it's a good step to get ten errors in your program because then you will know why these ten errors were coming and then you will know that in your next program you have to avoid these ten errors and maybe that in your next program you will get 15 more new kind of errors but then those 15 errors also you will get to know K this is how we are not supposed to do things and that brings you closer to how you are supposed to do things one step closer what you're actually supposed to do right okay Thomas has asked can we please talk okay Thomas let me go through the chat very quickly and we'll come back to this so let me first go ahead and go to link lists guys I agree with Thomas this kind of questions let's take up towards the end of the session and keep it restricted to data structures so that those of you who have to quickly leave off can get done with the session then get going fine so moving back to linked lists I hope you all read this link is a linear data structure very common data structure which consists of group of nodes in a sequence which is divided into two parts correct as you can see there are two parts in each node there is a data part and there is an address part right now the data part is the value that is stored in that particular node and the address part is the part that takes you to the next node in the data structure this is the basic structure of a linked list now they can be different type of linked list right we have singly linked lists doubly linked lists and circular linked lists let me explain to you what is singly circular linked lists so what happens in a single linked list we have a header node or sometimes also referred to as a null node that points on to your first node correct now let's say the data is 45 and then it has the address of the next node points to the next node now in the next node again you have data 25 and address of the next node right and similarly let's say this is your last node 13 which also has the address of the next node but since this is last note the next note would be not so once you reach null you know that you have reached the end of your linked list all right so why is it called single linked list because you're moving from one direction to the others you have the address of going from this node to this node but the other way around you don't have anything that is why this is called a singly linked list now a doubly linked list what it has again it will have a head or null which would point you to the first node that is 45 okay an address this is the simple note that we have seen so far but what happens in doubly linked lists doubly linked lists doesn't have a node like this the node structure changes a bit in W a linked list how it becomes this so your value goes here address next address previous now if you want to go back to previous the previous address address of this node is also present and the next address is also present again next let's say 25 address of the next node and address of the previous node so now if you are at this node 25 and you want to go back to the previous node you can go back using this previous nodes address correct and also similarly next node let's say null this would also have the address of the previous node so if you want to traverse back and forth that can happen in our doubly linked list now what is a circular linked list so circular linked list can be a single linked list or a double linked list but the whole point is that instead of pointing to this null here it points 245 that is how it becomes a circle can happen here also let's say 45 with previous address and next address 25 correct with previous address and next address so this points here this points here right now let's say we have a 13 I'm drawing it in circular format just so that you can be clear next and previous so previous points here next points here and now this next is pointing back to the first node and this points back to this this becomes a circle oil doubly linked list correct so the simple funda is that you have basically two type of linked list singly linked list doubly linked lists single linked lists you go in one direction only W linked list you go back and forth correct both ways and either one of these can be a circular linked list if you are the last node is pointing back to the first node so either one of this becomes a doubly linked list now moving on to next in social and deletion so if you have to insert and delete nodes from your linked list how do you do that so any pointers simple one-liners if you guys can give me and then I will go ahead and explain to you how it's done meanwhile there's too much going on the chat let me just go back quickly linked list insertion and deletion anyone has any answers quickly pointed out difficulty level of technical round and imposes it is pretty simple if you are through with your concepts C Java be and I think that's good enough Shivani for you to get through Infosys can you please tell me which scenario trees data structure will be preferred and when graph like structure will be preferred drinka or deciding between data structures is based on two three factors let's say if you have to decide between what are two options you have here tree and graph now if there is some data that is hierarchically organized like you have a root node that has two chains which further have chains which further have chains right that kind of structure like let's say you have to talk about animals mammals right let's say you talk about mammals now mammal classification that you do can be done in a tree structure correct so that tree structure can be used for scenarios like that or let's say um if you want to talk about four wheelers if you want to create a class of four wheelers now for willow is heavy vehicle lightweight wykel then heavy vehicle you might have trucks or buses and light weight you have cars etc based on that it goes deep down entry here IQ right so that is if you can replicate your scenario to a tree you go ahead with the tree data structure that is the easiest way to decide whether you want to go over the tree or you want to go with a graph now let's say if you want to replicate all generally the all the graph problems that we see are you don't know traversal or root problems this route to this route the shortest path this longest path that kind of problems are generally graph problems so those kind of scenarios if you want to replicate in your program in a way that is done using graphs so try to relate the scenarios with whether it's replicating a tree structure or it's replicating a graph structure that's the to decide which kind of data structure you want to use now next if you cannot do that then it depends upon which data you want to you would want to assess most like some data structure is a last in first out so if you want to keep a track of what data is last inserted because that data would be the most worked upon you would use the last in first out but if the first in data is more important to you that data would be more often used and assessed and manipulated then you use a first-in first-out correct so depending on your all these requirements what data structure is to be used is generally decided in a program in any coding situation that you are okay I hope you got an answer to this question Gokul is asking what is the data structure Gokul I think you joined in late data structure is simply put a way of organizing your data in the computer systems so that it makes it easy and efficient for you to use the data if you randomly dump the data you will have to go through a lot of trouble to assess the data the way you want using the concept of data structures it is simply a way to you know make your job easy to assess and manipulate this data easily and at a faster pace correct that is the simple put definition of data structures please tell how I learn pointer concept pointer concept is fairly obsolete I think nobody these days is asking more 4.0 concept but still if you want to learn pointer concept and I think the good way is to go ahead and work on C write a few programs on pointers and check you know add delete a few lines here and there in check what is happening to the point of values pointer address and point of value when you do that and that is how you will be quickly able to understand that okay if you add to this is happening to the pointer value if you add to to the address of the pointer this happens you know do those simple simple calculations on a pointer in your program and that output will help you understand that okay if I add 2 to the pointer value this is changing if I add 2 to the pointer address this is changing so then later on if you have a program where you see okay pointer value this is some operation performed you are simply able to and easily able to calculate okay this is how I saw it and this is how it should work right so write a very simple program and keep doing this additions deletions and operations on pointers that will help you understand pointers a lot faster than anything else okay like she says I'm from EC stream I don't know about yes how can I prepare for it anybody from any stream can prepare for deals data structure is a fairly simple concept at least theoretical knowledge if not programmatic knowledge of data structure is very easy to understand it's a very simple concept step by step go through what is the data structure how it is assessing how it is deleting values how it is traversing through the values and you're good to go all right power said in a linear data structure we can know in which position B are add / remove element in non linear also Thomas you can know which position you are and where you have to add or delete correct you can go back up to the parent element you can go to the next element it is just about implementation so adding deleting happens in all the data structures Q's also add delete elements Stax also add delete elements and you traverse through all these data structures so that way there is no difference between linear and non-linear you assess all the elements in both linear and non-linear you add elements in both you delete elements from both right it's just about sequential representation and non sequential datian okay oh I was a McGinnis graph using adjacent list or matrix then how is how it is nonlinear we can SS graph using adjacent list or matrix so that is not the point again this point I think I explained previously it's not about how you're assessing see eventually entry also you go from root to let's say the left node then the for the left node so in the end it is again happening sequentially now whether you use adjacency list or uses you know matrix to represent your that nonlinear data that is immaterial but the representation of data that is that is nonlinear because you have multiple you know options to move forward to in both graph and the street data structure it's not about how you are representing your data structure it's about how they are designed and you know presented rad sees a session on collection framework or a trance entry either we will left or right node where this is already happen in DQ entry sorry I can again I'm gonna again not able to understand what you're trying to say entry either we go left or right node but this already happens in DQ I'm not getting what you are trying to ask okay moving on to the next one sort of you need to start framing your questions better circular linked list so okay you are comparing tree with a circular linked list how is a tree being compared to a circular linked list see in a circular linked list what is happening is node 1 node 2 node 3 pointing back to node 1 that is forming a circle right in a circular linked list 1 2 3 and 3 pointing back to 1 that is a circular linked list now what is the tree a root node then chie known then for the child node now these child nodes are not pointing back to the root node you have to keep that in mind and even if they do first off that would become a graph that would not remain a tree the basic point of a trees you have a root node which has child which has falled the child which is further joined this those circularity in a tree in a like circular linked list you have this circularity so first node pointing to the second node second node point into the third node and third node pointing back to the first node that is how the circular linked list is different from tree i am i hope you are getting this clearly can we get a question in an interview in which we have to write a program on linked list I mean generally you don't get you are not if you are refresh you're not answer write a program on linked list you're generally asked for algorithms to work on linked list and even if you are asked to write a program on linked list maybe during a third or fourth round of a technical kind of company like Oracle or Amazon then you very well might have to write a program all right what do we have after that okay let me go back to link list insertion and deletion now so link list insertion and deletion let's say insertion can happen in three ways right let me go back yeah so first option is you have to insert an element at the first node so let's say this is node one pointing to node two pointing to node 3 this is pointing to null and this started from the first node that was none right now if you have to insert an element on the first node what are the few things that you have to do so number one there is a note coming here in between right so let's say n zero now if this is the first node this cannot point to the N 1 so this will have to go and the pointing will change like this null will point to this since this is the first node now and this will have the address of this making it again a sequential structure null pointing to n o then N 1 n 2 n 3 n 4 and so on correct now let's say if we have to insert an element at the last position again what will happen is n 3 is your last let's say you have to insert n 4 at the last what will happen is and 4 if n 4 is the last element info should be pointing to null and n 3 should be pointing to n force right so again this link will go and what will happen is n 3 will point to n 4 and then n 4 will point to null since n folds the last element now if you have to insert any element and some medium place in the middle of you know the link list so depending on where you have to insert that let's say between n 2 and n 3 we have to insert another X element what do we do the simple logic is you get rid of this pointing great the address at n2 I'm sorry the address at n2 that was earlier pointing to the address of node 3 will now point to the address of node X and the this address that we removed we will make X point to n 3 so that is how insertions happen in linked list now let's talk about deletion correct how do we delete n1 n2 n3 okay pointing pointing now if we have to delete n2 correct there is nothing now ideally this null node is doesn't have a value it's just a representation that we have reached the end of the list now some representations have a null node at the beginning to represent a head starter others don't so this is not amended and again this is not a mandatory present in most of the languages it is just a symbol to say now if null is not even there this is the last there is no further address it will have a address to the next one if this address value is not present then it is automatically obvious that there is no further node correct so having these nulls at the start in the in the end is just a you know pointer to tell that that is the start header in the end of the linked list so we were deleting n2 now if you delete n2 this address is gone so the address of n1 should point directly to the address of n3 so what we do is we take this address of n3 from n to node that is n to address and we assign it to the address value of node 1 so that node 1 can directly point to node 3 now after enter deletion n 1 points 2 &amp; 3 alright that is what happens when you do a deletion in a linked list fairly simple now since you know it you can very easily mold it to a program and do this right you take the address of this node from n to address assign it to N 1 address and that is all that you need to do when you are doing a deletion like she has asked tells one more time about the insertion in a linked list /a insertion is simple if you have to insert a node at the very beginning the beginning node address should point to the first node that was present at the beginning first right then if you have to insert a node at the end then n 3 will not be pointing to null first n 3 points to null but if n 4 has to be the last node n 3 will point to n 4 and n 4 will point to nothing fine and if you have to insert any row node in the middle of the list let's say between n2 and n3 v inserted this X so first n2 was pointing to n 3 but this address that was pointing to n 3 will come now here because X will point to n 3 and n 2 will take the address of X so this is now the new link of n2 point into n 3 or X pointing 2 &amp; 3 fine now moving on to the next stack ok how to traverse the list Thomas asked how to traverse the list list traversal is very simple you take the first value take this address of the next move on to the next from here see a linked list traversal is simple because it has value and it has the address of the next node where you have to go so based on this address you to the next element read that value again check the address of the next element go to it read that value again address of the next element till you reach null when you reach null you have so let's traversal based on these addresses is fairly simple and easy to do right moving on to stack now quickly go ahead take a look at this understand what is written here Susmita is asking how to learn to write algorithms or program in data structures so Smitha once you are good enough with the concept of a data structure what is a stack how it is implemented how to travel through it how to add elements how to delete elements then if that that's the first step of you know writing in algorithm or program in data structure now let's say if we I go back to link list and you have to write an algorithm to delete an element from a linked list how will that algorithm look like you take the address of n3 from n2 and store it in some variable say X correct now this address of n3 that is stored in endo will now be stored in n1 so you take n1 address and change it to and three address simple we took the address from here of this node n 3 and we moved it to here so that n1 can now point to n3 and that is all about the algorithm of deletion just these two lines if you can explain that this is how a deletion is done in linked list you're good to go right and similarly with the program whatever language you know go ahead and write the program in that okay moving on stack stats allow adding and removing elements in a particular order so as you can see here we have a stack what happens in a stack is you add an element but the element that is last added is the element that is first removed from the stack all right so if this is a stack you add for 325 and it and you keep adding but the last element that was added is it and the first element that will be removed is again 8 right that is the simple structure of a stack correct the only element that can be removed is the element that is at the topmost position once that is removed then you can remove 25 then you can remove 3 then only you can remove 4 once all the elements above 4 are gone out then only we can remove 4 from this stack now what next so based on this stack is a last in first out a leaf or structure it follows right so whatever element goes last in the stack comes first out of the stack and the operations that are referred to are if you have to add something you use a push operation if you have to remove something you use the pop operation right and top is where the inserts and deletes happen also there is no fixed size to a stack you can keep adding on things one after the other keep removing things in the middle if you would like to remove things from the middle that's the simple processing in working of a stack right now how to reverse a string using a stack it's a fairly simple question and it is very easy to do now generally do you might be just asked if you have to reverse a string what data structure will you use mentioned here is stuck but you might just be asked that if you have to will he use and that is when you have to come up with this idea that okay if you have to reverse a string how can it be done and why stack is a good way to do it take your time take two minutes and try to figure this out why reversing a string is done using a stack and how it is done using a stack just the algorithm Krishna's learned data structure in Java or C which is good for future and more easy to learn Krishna I would suggest whatever language you already know if you know Java learned data structure learn to implement data structure in Java and if you are aware of C learn to implement data structures in C because implementing data structure in any language is basically the language at the background right if you know data structures like what is going on at the top how functionality is happening it is fairly easy to go ahead and do it in either of the languages yeah done rightly said that language is a tool for writing code language doesn't matter logic does well I would say language also does matter but yeah logic is with data structures what is more important is logic than underlying language can be anything so whatever language you are comfortable with you can learn it to implement in that Magne has replied extract each letter of the string push into the stack and then pop from the stack and Magne you skip the last step by your popping from the step keep stack keep assigning it back to the string so that you finally get the reverse string right split okay how I say spit into cash and reverse the stack so after splitting into cash Hacha you first have to push all those elements to the stack and then you don't have to reverse the stack you just have to pop the elements from the stack all right yes most of you have answered that push in pop G to say is one one character in catch in string push in stag and one by one pop character yeah so most of you have got it right let me quickly just take an example in explain it to the rest let's say we have a string called talent sprint okay let's say this is our string and we have to reverse it fine now what do we do what we are essentially saying it is that one by one take all these characters and push them into a stack so we need a big stack for this one let's see this is how our stack is so the first character we push in the stack T the next a l e n t is P R I and and T so this is what we did we took one character at a time and post it on the now what simply we have to do it we don't have to do a reverse stack etcetera etcetera etcetera just simple pop operation till we reach the last element at the end of this time so start taking out each element one by one T and I are P s T and E L a T one by one you will take out all these elements till you reach the end of the stack and this straight-ahead gives you a reverse string you don't have to do anything further write a simple program now this became easy since I mentioned that using stack but sometimes students get confused if they are just asked that if you have to reverse a string which data structure would you use to do that then you get confused that okay do I use this tag do I use a Q do I use a tree what do I do so remember pushpop anything that needs to be reversed can be done using your basic simple stock okay now next is this able create an empty stack one by one push all characters of string to the stack okay one thing that I would like to mention here is if you have been asked to write an algorithm make sure that your algorithm is very to-the-point very specific giving every detail of every operation that you are thinking of doing in the program because if you miss out anything on the algorithm part your interviewer can immediately say that okay you skip this not without the step if you do the next step how is it working right so every single small step that you think of for solving your problem note it down like starting with the creation of an empty stack correct any detail big or small that is relevant for your program not at all push all characters of the string to the stack pop all characters from this thing and put them back to the string so after popping where are they going you have to be put back into the string as well right that is the simple algorithm that you can write so when you write algorithm what is it it is simple English representation of how you're going to solve a problem it doesn't involve programming right this is how you can write a simple algorithm for reversing a string using a stack now if you have to check for balanced parenthesis in a sentence by balanced parenthesis I mean let's say we have a sentence or string like this okay bye balance fantasies I mean the number of parentheses that have been opened should be equal and in order with closed now if you have to check for balanced parentheses if the string or the statement that you have has balanced parentheses or not how can you do that Uncas Osmond please tell which language is easier to learn because my placement is going to start in seven eight days UNK it's seven eight days I would say is not a very decent amount of time to learn a programming language from scratch if you don't know any programming language at all but if you have to learn I would say go with C because at least then you won't have to worry about the oops object-oriented programming concepts you just have to learn the basic fundamentals of programming so maybe then you can kind of wrap it up in seven eight days so go ahead try out C and give a good amount of time if you only have seven eight days and your placement is going to happen in seven days I would say give at least if not more five six hours every day to coding practice all right a kilobyte stack Gaurav says you stack as one opening push it and then pop when the closing brace appears anybody else would like to take a shot travel show all the characters and check for the occurrences of that character okay this is again going to be a simple push pop operation in a stack but the only condition is the only programming condition that you would apply here is if your character like this is a character this is a character one by one we push characters onto the stack right if your character is equals to either of the opening braces beta square base brace beta curly brace beta normal price then we do a push all right and if your character is either of those closing braces right this or this or this I'm just writing a simple elbow you can convert this into any programming language you would like be it c be java whatever you are working with right so if character matches any closing brace then you have to check that if character if closing brace is this check the current brace you pop the topmost element and check if it matches this brace or not right so let's start with the example here we first encountered this simple brace flower base put it in the stack then we encounter square brace put so we are ignoring the characters right we are only pushing the braces on to our stack so we ignored these characters pushed the square brace then again ignore characters push the curly brace okay ignore characters again now we encountered this closing brace our first closing brace we encountered now what we do is we check if our this topmost element that we have and the stack matches the clothing place now this is also a curly brace and this is also a curly brace so in that case we pop our element from the top correct take this out now what we are left with in the stack is this and this correct now further we inquire us a square brace right now at the topmost element we have a square opening brace now we encounter the square closing brace so we remove this also from the top now what we are left with is a simple brace again we encounter a simple brace closing right so we pop this also so now our stack is empty if you reach an empty stack at the end of your string traversal that means that your parentheses were balanced but in our parentheses we have one more closing brace at the very end now if we now when you want to pop this out the respective opening brace for this out they and see that our stack is empty there is nothing to pop out but there is one more extra closing brace which means that the parentheses are not balanced so if one of these conditions occur that is there is no closing brace at all correct or the first brace if is a closing brace you get this that means also it's not balanced there has to be an opening brace for a closing brace correct so all these conditions you keep in mind if there is an extra brace at the end that is closing for which there is no opening brace to pop from the stack even then your string becomes your parentheses become unbalanced okay Magna is asked to explain this again Magna see it's fairly simple let me just clear this off and then quickly explain it again see the simple idea is if you start a brace there has to be a closing brace for it correct and it should be in the same order it cannot be that you start a curly brace but then you end with a square brace right let me just check this also give you simple examples see if your brace is like starting here talent and you close with this this is unbalanced because in the stack you will push this brace but when you pop you will try to match with the square opening brace right but you will not find a square opening brace because we have a normal opening brace okay so this is unbalanced situation another unbalanced situation is that you have this in a simple closing brace so there is no opening brace to it so this is also unbalanced now if you have let's say an opening brace but no closing brace to it this is also unbalanced correct these are the simple simple situations that you have to keep in mind that your program should be able or your algorithm should be able to tackle correct so once you know all the situations that you have to handle it becomes easy for you to write the program all that you have to do is whenever you encounter an opening brace put it down let's say you encounter next is let's say you encounter next this then this and then again the square okay now when the closing braces come they should be coming in the same order if the closing braces have started coming first you should have this then this then this then this then this so that they match and one by one you can pop all the elements out and at the end your stack becomes empty fine now if this order doesn't come let's say instead of this order what you get is square brace square brace now first square brace you will pop this one out next square brace you will see that this is a normal braid but close with the square base which is wrong if you start this you have to close this first right so then itself you know that your program or your string doesn't have balance balances and you can return an error right so it's very simple check whatever has opened should be match to whatever is closing at the end you should get an empty string if there is an opening brace there should be a corresponding closing braces well right that's a simple check for the parentheses program find next we move on to trees so take a look at the slide try to understand what is given and then we will quickly look at it Sargeras very nicely given the step-by-step procedure of doing that balanced parentheses situation instead of pop it should be peak if the condition matches then pop is done so you just take which is very correct you just get the topmost value check if it matches and then pop it out and if it doesn't match the program doesn't work right Shaboom also explained the same okay so moving on to tree trees the data structure made up of nodes vertices edges without having in cycle okay so the tree with no nodes is called the empty node a tree that is not empty consists of a root node and potentially additional levels of node by which they mean is that a tree has a root node R and can have multiple child nodes C 1 C 2 C 3 C 4 etc right now if another thing to keep in mind is if there is only one node that is a and it is pointing back to itself this does not qualify ie as a tree but this is what a tree cycle is one node pointing back to itself a is the root but a is also the parent of the root right now there is some certain terminology that is involved with tree what is all that first off let's create a simple tree 45 1372 4 and 8 and 56 and 93 right now in this tree you need to remember the tree terminology because if in your interview some questions are asked around this then you should be able to you know answer to these questions so what is a root root is the topmost element which has the Chinese so 45 becomes your root what is a child anything that comes down from 1372 for 8 is a child in the tree what is the parent if in reference to fold you ask the parent of four it is 13 the immediate ancestor is the parent so parent of 13 is 45 similarly parent of 93 is 7 - right what is the sibling all the loads that are at the same level so for 8 56 and 93 the nodes at the same level I siblings so if you are asked what is the sibling of 30 it is 72 okay further let's talk about descendants and ancestors so if you are asked what are the descendants of 13 we have 4 and 8 if there is anything under this let's say 1 then 1 4 &amp; 8 are the descendants of 30 similarly ancestors is what we have on the top and sisters of 8 let's say ancestors of 8 would be 13 and 45 and sister of 72 would be 45 now what does internal node an internal node is a node which has at least one child right 13 is an internal node 4 is internal node 45 is internal node but what is a leaf a leaf is the nodes which have no children so 8 56 93 they have no children correct so they are called as the leaf nodes now what is the edge H is this connection between two nodes this is referred to as edge why do we need to know this will come to know further down what is the path path is a sequence of node in edges so let's say if you are asked what is the path to reach 256 from the root node so it is 45 followed by this connection then 73 then connection then 56 this is the path from 45 to 56 correct so now next is what is the level of a tree how do you calculate the level of a tree it is 1 plus the number of connections between the node handle root so level of let's say 4 1 plus number of connections between this node and the root node so how many connections are there in this in this one - correct so level of root node 4 is 3 it's a third level correct similarly if we have to calculate level of node 1 so level of node 1 is equals to 1 plus number of connection between node 1 and the root node how many connections are there between them 1 2 &amp; 3 so level of node 1 is equals to 4 correct now next is the height of a node height of a node is the longest path from root node to the node and height of a tree is the longest path from the root node to the child that has the last leaf right so the height of this tree is 1 2 3 height of our tree becomes 3 okay further what is the depth depth is the edges from trees root node to the node so let's say if we ask what is the depth of 56 how many edges are there from root node 256 1 2 so depth of 50 sixes to depth 50 sixes - all right this is the simple terminology that you all should be aware of when you talk about a tree ok I see some what is the level of root node is 0 right yep Megna level of root node would be 0 because there is no further and sister or connection up it right so it starts at 0 and then further down we continue okay so level goes one plus and since we there is no further connection so the number of connection is zero but we add one to it so one plus the number of edges above it right so zero plus one our root node is at first level the next two nodes 13 and 72 then become at second level similarly for 856 93 our third level and the first node that we have is that fourth level correct this is how it was now once you clear with the tree terminology guys what next comes is tree traversal how do you traverse a tree now these questions are fairly interesting okay because they make you do programs in certain way and then not even programs even if only the algorithms there get pretty confusing so let me start with a simple one that is the breadth-first traversal how does it work it works in traversing the nodes in order so you start with the root node that is 1 then 2 3 then go down to 4 5 that is your breadth-first traversal order now similarly if you have to do depth-first traversal depth-first traversal is done in three types it is preorder and postorder okay now what happens in all these in order preorder and postorder in order traverses in this order left route and then right okay remember these orders only then you will be able to you know clearly distinct between this in pre-order we have route left right and in post order we have left then right then route okay so now if you have to traverse this simple tree that we have fine let's say in order how do you do it you start with the left most node then move to the route then right so the left most node in this tree is our node number 4 so first we have 4 then route that is 2 then right that is 5 now this part of the tree is done this becomes left so left is done again route that is 1 and then right that is 3 so if you travels your tree in inorder traversal you get elements like this four to five one three okay now I want you to give me the preorder traversal result of this tree we have root then left then right now give me the preorder traversal of the Ignasi you're confused about the level and the height of the tree see the formula for the level is very simple the level of any node is 1 plus the number of connections between that node and the now since root node doesn't have any connection between itself so the number of connections between the node and the road becomes 0 for the root node correct and you just add 1 to it to get the level of the root node which becomes 1 now in the next you add one more so the next level becomes 2 and 3 and so on that is a simple formula to calculate the level of a tree now about the height of the node the height of the node is the number of edges on the longest path between that node and the leaf node so you just count the number of edges between that node and the leaf node in this case between 45 and 1 so the height of this tree becomes number of these edges that is 3 that's a simple formula you don't have to be very confused about it 1 plus the number of connections and root and the leaf ok so some of you have given me the pre-order traversal let me go back there 2 4 5 1 3 1 2 4 5 3 and 1 4 2 5 3 okay I have got three answers we'll actually for now and out of which only two are correct are John's answer is correct and meghna's answer is correct 1 2 4 5 3 inertia bonnie has corrected her answer so let me quickly explain what is happening here root left right correct so you start with the root that is 1 so 1 left that is to then again to keep going root you have taken go to left that is four and five now once this part of the portion is again done you are done with the root you are done with the left then go to the right that is three correct similarly post-order left right root now how does that work left right root so you start with the leftmost that is four then right of it five and then root that is two now once this is done this is the left the right is three and the root is 1 so this will be your post order traversal correct so I hope now you have understood the inorder preorder and postorder right now quickly take your time and do the same for this I'll give you the order written here for those of you who haven't remembered it yet in order is left root and right three orders route left and right and post orders all right so let's start with the in order I want everyone to quickly good the tree is fairly simple okay it is not very complicated go ahead and give me the inorder traversal of this tree the first one let's go ahead and take a look at the first one inorder traversal I've got some answers already for the in our traversal let me check that for 10 12 15 18 22 24 25 31 35 44 50 66 70 and 90 so Sagar and Magne have both answered Sagar has answered the pre-order as well so all of you are able to get the in order and you have moved on to the pre-order as well that's good cool and postorder is also given so let me quickly give you the answers for those of you who are not able to it figure this out in order is left root right fine so you start with the leftmost that is 4 so 4 root 10 right 12 this is done now this becomes your left so left root 15 right you have this now in this again left rude right keep repeating this so that is 18 route 22 and right is 24 fine now once that is also done get to the root that is 25 again you move on to this part right in this part what you will do is start again with the leftmost so then left root right now root left root right correct and similarly I think you all are able to do it repeat keep repeating this pattern root left right and for postorder repeating the pattern left right root so let me quickly show you post order as well left 4 right 12 root 10 this is done let is done now this is left right root so left corresponding right you will check again in that left right root 18 24 22 then after 22 you go to the root that is 15 right so you go to 15 fine then corresponding to this half you go to this half okay in that leftmost 31 so 31:44 35 then 66 90 70 50 and finally 25 okay so most of you are able to get crack this pre-order I'll leave it for you guys to figure out on your own the pattern I have given to you root left right fine moving on to binary search tree what is a binary search tree there are three easy points to quickly remember about the binary search tree the left element is smaller than the right element okay the left part of the tree is has all elements smaller than the right part of the tree okay so if your root node is 45 all the elements on this side will be smaller then all the elements on the side correct and there's one more thing about this binary search tree that no element can be null in a binary search tree there has to be a value to the elements so it's a normal tree but just these rules apply in the binary search tree now further let's quickly go on to Q we are already overdue think most of you could be late for your prior assignments so what is the Q Q is an abstract data type again first element is inserted from one end called real and the deletion happens from the front other end coil front okay and Q is a first-in first-out so our stack was a last in first out queue is a first-in first-out so situations where you need a first in first out data structure you use a queue the process to add an element is called nqn process to delete an element from a queue is d qu now corresponding in stack was push and pop right in Q with respect to it is called and Q and D Q alright so that simply about Q I will quickly show you those structure all right let's see oh okay let's say we implement you using in array fine so we keep adding elements from the insertion happens from the tail that is real right so we add let's see L and front and rear I'll mark the same first element we added is let's say 4 ok now next element would be added at this position correct let's say 5 the next element would be added in this position let's since 731 ok we keep adding and adding and adding so the rear of the tree comes finally here after adding all these elements in the front remains and the front correct now when deletion happens what will happen is the first element that was inserted in this queue will go out correct so the first element that is inserted in the tree was 4 now when you delete this element how you delete the element is very simple front instead of pointing to 4 it points to 5 so whatever element the front points to that is the first element of your queue by default for is deleted now if you point your front to 71 your 5 is deleted and as similarly for addition real keeps moving forward and elements keep being added all right simple process fine circular queue magnetized for circular coming a circular queue is again fairly simple just assume that this is a let's say assume that this is a cassette tape right we have all heard music in a cassette tape now if you add sections to the cassette tape and write elements there and then just wrap it around okay so the last element I'm just giving you this for conceptualization so it is easy for you to understand let's say the last element is 81 and the first element is 4 so the real points to this now in the circular queue the rear and the front becomes same so after 81 then move on to the next you get the element 4 right so this this idea of having this circular thing right the circular tape feeling around that connects your elements together so you have a normal cereal list you have four eight thirteen fourteen eighty one let's say now in this circular queue for and eighty one would be adjacent to each other right here elements those two front and rear would be next to each other now if you remove the element four and make it point to the next element still front and rear will remain the same because you got having the idea of a circular queue so front and rear would be right next to each other in a circular queue alright so that was the session about data structures we saw stacks we saw trees we saw linked lists we saw queue and we have seen traversing in other questions around there are commonly asked around all this so stack we saw how you know certain real life scenarios like matching braces or string reversals those kind of questions are done using stack and then we saw how traversal is done in a tree right so that was about the session guys I hope you understood the basic implementation of all these data structures how they are working how they're used why they are used is more essential once you know the understand why something is used it is it becomes easier to understand how it is used all and I I missed out on some of the comments in the middle when there were a lot of questions around interviews and what language should I prepare for etc etc so I'll try to answer all those questions in the once the video is posted in the comment section I will try to answer all those questions so you can go ahead and take a look if you have asked a question go ahead and take a look at the comment section of the video and your questions would be answered there and what next I have is if there is certain questions the data structure was highly requested in the last two three videos many of you asked for a session on data structures that is why we had this session today and if there's some topic or some concept that you would want to brush up on any question that you want to me to take up in the next session again drop a comment or drop your comment here in the chat and we'll take it up in the next session and I'll see you next to next Monday when we have the next session on 25th I guess 

===[=]===


pA-8eBZvN1E.en.vtt   SPEAKER 1: All right, this is CS50 and this is week five. And let's take a look at where we left off last time. You may recall this guy here, Binky from our friends at Stanford. And we used Binky to start talking about pointers. What is a pointer? So, a pointer is just an address, the location of some piece of data in memory, because recall at the end of the day your computer just has a few pieces of hardware inside of it, one of which is RAM or Random Access Memory. And in RAM you have the ability to store bunches and bunches of bytes, or kilobytes, or megabytes, or gigabytes, depending on how much memory you have. And if you assume that no matter how much RAM you have you can enumerate the bytes-- this is byte 0, this is byte 1, this is byte 2, and so forth-- you can give each of the bytes of your computer's memory an address and those addresses are simply called pointers. And now in C we have the ability to use pointers both to go to any location in memory that we want and even to dynamically allocate memory in case we don't necessarily know a priori how much memory we might need for a program. Now, in terms of your computer's RAM, recall that we divided the world into this picture here whereby if this rectangular region, arbitrarily, represents your computer's memory, here is how the computer divvies it up when you're actually using a program. At the bottom of your computer's area of memory, you have the so-called stack. And recall that the stack is where any time you call a function, it gets a slice of memory-- a frame of memory, if you will-- for all of its local variables, all of its arguments and anything else that it might need. On top of that might go another slice or frame of memory if that first function calls another. And if that second function in turn calls another function, you might have a third frame on the stack. Of course, this doesn't end well if you keep calling function after function after function after function. And so, hopefully you don't accidentally induce some kind of infinite loop such that these frames pile on top of each other infinitely many times, because eventually they'll run the risk of hitting the heap. Now, the heap is the same type of physical memory. You're just using it in a slightly different way. The heap is used any time you want to dynamically allocate memory, when you don't know in advance how many bytes you need but you do know once the program is running how many you now want. You can ask via functions like malloc the operating system for some number of bytes, and those bytes are allocated from the heap. So, those two have addresses or numbers. And so, the operating system, by way of malloc, just figures out which of those bytes are not yet being used so that you can now put whatever piece of data you have in that particular place. Now, beyond that [? appear ?] things like initialized data, uninitialized data. That's where things like global variables that are initialized or not end up that might be outside of your main function. And then above that is the so-called text segment, which are these zeros and ones that actually compose your program. So when you double click an icon on Windows or Mac OS to run a program or you type dot slash something in the Linux command line environment in order to run a program, the bits that compose your program are loaded also into memory up into this region here. So, at the end of the day, you have access to just pretty generic memory, but we use it in these different ways. And it allows us to ultimately solve problems that we might not have been able to in the past. Recall for instance this example here, deliberately shown in red because it was [? buggy. ?] This does not work. Now, logically, it does do the swap that we intend whereby a goes into b and b goes into a. And we achieve that result by way of this temporary variable so that we have a temporary placeholder into which to store one of those values while doing the swap. But it had no permanent impact on the two variables that were passed into it. And that was because by default in C any time you pass arguments to a function, those arguments are passed so to speak, by value. You get copies of those values being passed into a function. And so, if main, for instance, has two variables, x and y-- as they did last time-- and you pass x and y into a function like this one here swap, x and y are going to get copied as a and b respectively. So you might perfectly, logically, correctly swap a and b, but you're having no permanent impact on x and y themselves. But what if, per this green version here, we reimplement swap to be a little more complicated looking, but at the end of the day actually correct? Notice now we've declared a and b not to be integers but to be pointers to integers, the addresses of integers. And that's what's implied by the star that we're putting right there before the variable's name. Meanwhile, inside of the body of this function, we still have three lines of code. And we're still using a temporary variable, and that in itself is not a pointer. It's just an integer as before, but notice we're using this star notation again, albeit for a different purpose to actually dereference these pointers. Recall that int star a and int star b means give me a variable that can store the address of an integer. That's declaring a pointer. Meanwhile, if you just say star a without declaring something to the left of it with a data type like int, you're saying go to the address that is in a. So if a is an address, star a is at that address, which of course per its declaration is going to be an integer. Similarly, star b means go to the address in b. Star a means go to the address in a and put the former into the latter, ultimately putting the value of temp at the address in b-- so absolutely more complicated at first glance, but if you consider again the first principles of what's going on here, all we are doing are moving things around in memory. And we can do that now because we have the ability to express the locations, the numeric locations of where things are in memory. But nicely enough, we, the programmer, don't have to care where things are in memory. We can access things symbolically as we're doing here with a and b. So even though we might have seen on the screen or you might see while debugging actual addresses of memory, rarely does that actually matter in practice. We can deal with everything we've learned thus far symbolically. Now, last time we also took a look at the world of forensics, and we took a look at how images are implemented and specifically file formats like BNP, and JPEG, and GIF, and yet others. And we glanced into [? Asmila's ?] here as we tried to enhance this image, but of course, there was only finite amount of information. So, what you see is what you get in terms of any kind of glint or suspect in her eyes. But we did this in part so that we could also introduce another feature of C that allows us to declare our own data types, indeed our own data structures. For instance, we proposed that if you wanted to write a program that stores a student, you could actually declare your own student data type inside of which is a name and inside of which is a dorm, you might actually want. Meanwhile, this syntax here gives us a new data type called student so that if we want to write a program that implements students, we can actually wrap related information together like name and dorm without having to maintain a whole bunch of strings for just names and a whole bunch of strings for just dorms. We can actually encapsulate things all inside of one structure. And indeed encapsulation is another principle of computer science that you'll see throughout program and throughout the field itself. So, what do we now do this time? So, today we introduce more sophisticated ingredients with which we can solve problems and we revisit a problem from the past that we thought we had rather knocked off and had solved. So, this might represent a whole bunch of names, a whole bunch of numbers, a whole bunch of telephone numbers in a phone book back to back to back to back stored in this case in the form of an array, the simplest of data structure, so to speak, that we've discussed thus far. And an array, again, is a contiguous block of memory each of whose element-- typically are of the same data type, integers, or strings, or the like-- and they are by definition back to back to back to back, which allows you random access. Which means you can jump to any of these locations instantly just by using in C that square bracket notation or as we saw last time using pointer arithmetic, actually using the star operator and maybe adding some number two and address to get at some subsequent address. But it turns out there's a few problems with this fundamental approach. Nice and as simple as it is, it would seem that we rather paint ourselves into a corner with this approach. This array has 1, 2, 3, 4, 5, 6 total elements, at least as depicted here. So that's fine if you want to insert a number, and then another number, and then four more numbers. But what if you want to then insert a seventh number, not to mention an eighth number or a ninth number or the like? Well, where do you put them? Well, you might think, well, that's fine. I'm just going to go put the seventh number over here, or the eighth number over here, or the ninth number over there. But you can't just blindly do that. If this memory is being managed not by you per se but by malloc and by the computer itself inside-- and your program, this memory over here, while it might physically exist, might be used by some other part of your program all together. It doesn't necessarily belong to you unless you've asked for it. And the problem with an array is that as we've seen it typically you declare their size in advance, as with the square bracket notation, and say give me six integers or give me six something or others, but that's it. You have to decide in advance. You can't just grow it as you can in some programming languages thereafter. You've rather painted yourself into a corner. But with malloc and other functions like we saw last time, you can actually allocate more memory using malloc. Unfortunately, it might end up in another location in your computer's memory, so you might have to do some copying to take the original six elements and move them elsewhere just to make room for more. And there is a data function for that, something called [? re-alloc ?] or reallocate. And indeed it can do exactly that. It can give you a bigger chunk of memory and reallocate what was previously there to be a larger [? size. ?] But you have to do a little bit of work. You have to invoke it in order achieve that. You can't just blindly keep adding things at the end of this array. Now, unfortunately, while a solution that might not be very efficient. Even if you can allocate a bigger chunk of memory that's bigger than six because you have more numbers, for instance, to store, what if that takes a bit of time? And indeed it's going to. If you allocate more integers somewhere else in memory you still have to copy those original values, and now it just feels like you're wasting time. Now, instead of just inserting things into the list, you might have to copy it into a bigger space, reallocate things, grow. It's a lot more work. And all of that discussion of running time and performance comes back into play, because if that whole copying process and reallocating is costing you time, your algorithm or your program ultimately might not really be as fast as you might want it. So, what could we do instead? What could we do instead in order to solve this problem dynamically, so to speak, that being the operative word. And luckily enough, last week we learned that there is dynamic memory allocation in C by way of that function malloc. And we also learned that there is ways of representing structures in C that you don't necessarily get with the language itself, because they're not primitives. They're not built in. In other words, let me propose this as a solution to our problem. This is a list of, let's see, five numbers it would seem, 9, 17, 22, 26, and 34. Pretty arbitrary right now, but you might imagine very simply drawing those same numbers-- 9, 17, 22, 26, 34-- in the form of an array and they're clearly deliberately sorted. But again, what if you wanted to grow that array or even shrink that array dynamically over time? Well, let me propose that we not draw those numbers back to back to back to back literally next to each other but allow ourselves potentially a little bit of space? But if that's the case and nine is here in my computer's memory and 17 is here and 22 is here, or over here, or over here-- in other words, what if I relax the constraint that my numbers or my data types more generally have to be stored contiguously back to back to back to back in memory and instead allow them to be anywhere, indeed anywhere a function like malloc wants to give me more memory, that's fine. If it wants to give me memory up here in my computer, I'll deal with that. If it wants to give me extra memory over here, that's fine. I'll deal with it, because I'll use these conceptual arrows to stitch together my data structure this time. And now, where have we seen these kinds of arrows before? What feature of C allows us to connect one thing to another where a la chutes and ladders get from one place to another? Well, that's exactly what we saw last time which was pointers. While we've drawn these here per the snippet from a textbook using arrows, those are really just pointers. And what does each of these rectangles represent? Well, clearly a number in the top half of the rectangle, but I claim that at the bottom half of these rectangles let's consider that bottom rectangle to just be another piece of data, specifically an int star, a pointer. Or rather not a pointer because it seems to be pointing not just to the number but to this whole rectangle, so I need some new terminology. I need some kind of structure to contain an integer and this pointer. And for that, I think I'm going to need a struct. And indeed let me propose that to solve this problem we give ourselves this building block as a new C data type called a node. You can call it anything you want, but the convention would be to call something like this in a data structure-- that's like a puzzle piece or a building block in a data structure would be called a node. Let me propose that we define it as follows. I'm using that same syntax from last time with which we declared a student data type, but here I'm saying inside of this data structure, this node shall be an int. And that's pretty straightforward. Just like a student might have a name and a dorm, this node will have an int called n arbitrarily. And then the only piece of detail that's a little bit new now is the second line, struct node star next. Now, what does that mean? It's pretty verbose, but struct node is just recursively, if you will, referring to this same type of data structure. Star means this is going to be a pointer, the address of one such thing, and next is just an arbitrary but pretty reasonable name to give to such a pointer. So this line here, struct node star next, is the incantation in C with which you declare one of those arrows that will point from one node, one rectangle to another node, another rectangle. And the fact that we have a little bit of additional verbiage up here, typedef struct node, is because again C is a language that is read top to bottom, left to right, so words have to exist before you actually use them. So, whereas last time when we declared a student, we didn't actually mention struct student or anything like that. We just said typedef open curly brace. Today, when declaring a node, we actually have to have some additional syntax here just called struct node. And technically this word could be anything, but I'll leave it as node for consistency. And that allows me inside of this definition or to specify that the second data member is going to be a pointer to exactly that kind of data structure. But typedef, just to be clear, allows me to type a smaller name for this data structure here, which I will simply called node at this point. So, what can we actually do with this kind of data structure now? And, indeed, let's give this data structure a name. Let's start calling a linked list. Previously, we had arrays, but now we have linked lists, both of which at the end of the day are types of lists, but linked lists, as the name suggests, are linked or threaded together using pointers. Now, when you have a linked list, what might be some operations, some algorithms that you might want to run on them? Well, if you've got a linked list of say numbers, for the sake of discussion, you might want to insert a new number into that list. You might want to delete a number from that list and you might want to search that list. And that allows us to then consider how we might implement each of these kinds of things. But it turns out while all simply-- while fairly simple intuitively, we're going to have to be a little careful now by way of our pointers. So, let's more formally declare a linked list to look something like this. It's a collection of nodes that are linked together with pointers as represented by these arrows here, but we're going to need some special pointer, at least at the beginning of the list. Let's just call it first. store a actual integer. It itself first is just a pointer to the start of the list. And by way of that pointer can we access the first actual node in the list. From there can we get at the second, from there can we get at the third, and the fourth, and the fifth, and any number of others. And this syntax over here might just represent null. Because you don't want to have that pointer just pointing off into no man's land, that will have to be a null pointer so that if we check for that with a condition we know, OK, we're at the end of the list. So, let's pause for just a moment and consider these three algorithms-- insert, delete, and search, and consider what's going to be involved. Well, how would you go about searching for an element of this list? Suppose I wanted to find the number 22? What do you do? Well, me, I, the human can just look at this and be like all right, 22 is right there. But a computer can't do that. A computer every time we've had this discussion can only look at one thing at a time. But moreover the computer this time is even more constrained because it can't just use our old friend binary search or divide and conquer, because how do you get to the middle of a linked list? Well, you have to find your way there. The only thing you have in a linked list from the outset is one pointer called first or whatever it is, but one pointer that leads you to the beginning of the list, the first node in the list. So, if you want to get to the second node in the list, you can't just go to bracket one, or bracket two, or bracket three to get any number of other elements in the list. You have to follow these bread crumbs, if you will. You have to follow these arrows or these addresses to go from one node's address to the other to the other. And so, we've paid a price already. And we'll see that there is still an advantage here, but what's the running time? What's an upper bound on the running time of search for a linked list, even if it is sorted? Any thoughts? Is it constant time like big O of 1? Is it log of n? Is it n, n squared? What's the running time going to be? Well, they're sorted, and that was this magical ingredient, this assumption we've been allowed to make in the past which was helpful, but that assumed that we had random access. In C, we had square bracket notation, so that using some simple arithmetic we could jump roughly to the middle, and then the next middle, and the next middle looking for Mike Smith or whatever element it is we're looking for. Unfortunately here, one price we have already paid already by taking this step toward linked lists is linear time. Big O of n would seem to be the running time of searching a linked list, because the only way you can start is at the beginning, and the only way you can get through the list is by following these arrows. And if there's n nodes in the list, you're going to need as many as n steps to find, something like 22, or 26, or 34, or any elements all together. Well, that's not all that great. What about insert? the running time of insert? Well, here too it depends. Suppose that we don't care about keeping the list sorted. That's kind of a nice advantage, so I can be a little lazy here. So, what's the running time going to be if I want to insert a new number like the number 50 into this list, but I don't care about keeping it sorted? Well, instinctively, where would you put this element? Where would you put it? You might be inclined-- you kind of want to put it over here, because it's the biggest element. But again, if you don't care about keeping it sorted, where is the fastest, the quickest and dirtiest place to put it? I would propose let's just put it at the front of the list. Let's take this first pointer, point it at the new number 50 that we've have somehow added to the picture as by calling malloc, asking malloc for a new node. And then have 50, in turn, point to the number 9, and then 9 can point to 17, and 22, and so forth. What if we want to insert another number, 42, and we don't care about where it goes? Well, why don't we just put it at the beginning of the list? Then we have the first pointers pointing at 42, which in turn should point at 50, which in turn can point at 9, then 17, then So, if we're just lazy about this, we can actually achieve a great running time for insert constant time. Unfortunately, if we want to keep things sorted then we're going to have to incur a linear time cost again, right? Because if we have to insert 42 or 50, worst case they might belong all the way at the end of the list and that's Big O of n steps. And delete, too, unfortunately, whether it's sorted or unsorted is also like search going to be Big O of n because you don't necessarily know when you're searching for a number to delete if it's going to be at the beginning, the middle, and the end. So, in the worst case, it might indeed be at the end. You know what? Why don't we instead of walking through this verbally, let's see if we can't get some volunteers? Can we get seven volunteers to play-- wow, to play the role of numbers here. 1, 2, 3, 4, 5, 6, and yes, 7, come on up. All right, so I have here some printouts for all seven of you that represent exactly the nodes that we have here on the screen. Let's meet one of our first contestants. What is your name? AUDIENCE: Scully. SPEAKER 1: Scully, nice to see you. So, you shall be literally first and represent our first pointer. So, if you want to come and stand roughly over here. And then what is your name? AUDIENCE: Maria. SPEAKER 1: Maria, nice to see you. And you can be the number 9 right next to our first contestant. And your name? AUDIENCE: Sarah. SPEAKER 1: Sarah, nice to see you. You shall be the number 17. [? AUDIENCE: Satoshi. ?] [? SPEAKER 1: Satoshi, ?] You shall be 20. [? AUDIENCE: Mosof. ?] [? SPEAKER 1: Mosof, ?] nice to see you. And you shall be 22. AUDIENCE: Jed. SPEAKER 1: Jed, nice to see you-- 29, formerly 26. AUDIENCE: Erin. SPEAKER 1: Erin, nice to see you. You shall be 34. All right, so what we have here is seven elements, six of which are very similar to themselves, one of which is fundamentally different. So, Scully here represents first, and indeed her sheet of paper is horizontal to suggest that she is just a node. She is just going to be the pointer of to a node in a list. Everyone else's nodes are vertical, as have been the rectangles we've been drawing on the screen, because each of these guys represents a number as well as a next pointer. Now of course, you're only seeing in front of you the number. So we're going to go ahead and if you wouldn't mind, use your left hand to represent the arrow that we've long had on the screen to point to the person next to you. And Erin, you're a bit of an anomaly, but also because you need to have a null pointer at the end of the list, so that you're not just pointing aimlessly. And pointing to the ground seems fine, so literally pointing to the ground will represent-- will infer as null. So, Scully, you are the only thing keeping this list together, so to speak. So, you two need to point with your one pointer to Maria there. So, here we have a linked list. And just to make this clear, could everyone separate from each other by a step or two in any direction? Notice that the list is still-- it's almost identical to before. Can some of you take a step forward, a step back, but still point at the other person? So, now we're capturing a little more accurately the fact that these nodes and these pointers can be anywhere in memory, so long as they're linking themselves together by way of these pointers. All right, so suppose now that I want to insert an element like 55, which happens to belong at the end of this list. Let me go ahead and malloc Christian if I could. So we have asked malloc for a chunk of memory equivalent to the size of one integer and one pointer. That is going to be represented with this rectangle here. Nice to see you. AUDIENCE: Nice to see you. SPEAKER 1: You shall be 55. And I'll play the role of the temporary pointer as predecessor pointer or pointer just using my left or right hand to try to figure out where Christian belongs. So, just like you might-- just like we might want to search the list, inserting is fundamentally rather the same. The only thing I have access to at the outset of this algorithm is my first pointer, and it's only by way of Scully that I can even access the rest of the list. I cannot jump to the middle, jump to the end. I can only start at the beginning and literally follow the pointer. So, let me go ahead and do that. point at whatever Scully is pointing at, which happens to be Maria, which is the number 9. 55, of course, is bigger than that, and I do want to keep the list sorted for today's purposes. So I'm going to very carefully follow the next pointer, 17. Follow the next pointer, 20. Follow the next pointer, 22. Follow the next pointer, 29. Follow the next pointer, 34. ah dammit, null. And so this is why it is important with some of these algorithms to have a predecessor pointer, a second pointer or really my left hand so that maybe my left hand can still point at Erin. My right hand can realize, ah, null, so that I still have access to the last node in the list so that Christian-- if you could come over here. I'm going to go ahead and tell Erin quite simply to point at Christian. Good, and let's just say for students' sake come on over here, but technically we could have left Christian there and just had Erin pointing at him. It's just going to get a little confusing before long, so we'll just cheat and move you right over here. But now we have a linked list that has one additional member. Suppose now that we want to make another insertion-- pardon. Let me go ahead and propose that we insert say the number 5. Well, the number 5, of course, belongs at the beginning of the list. So you know what? I need to malloc. Can I malloc Jordan off camera five, perhaps? So malloc, a very slow return value. OK, we're going to store your node your n value five here. His pointer is undefined right now, because he's not actually pointing at anything. And so where does he ultimately belong? Well, he belongs at So, let me deliberately make a mistake. Let me go ahead and update Scully to point at Jordan, thereby putting Jordan effectively Unfortunately, whom should Jordan now point at technically? It should be Maria, but this is code. The only thing we can do is copy pointers in memory, and if Scully's left hand is no longer pointing at Maria, I have literally orphaned the entirety of this list. I have leaked 1, 2, 3, 4, 5, 6, 7 chunks of memory, seven nodes, because I got my order of operations out of order. Indeed, I should have done what-- let's undo, control Z. And now let me go ahead and do what? Jordan should point at the exact same thing Scully is pointing at, which has no downside. Even though it feels redundant, we've not lost any information. And now that Jordan is pointing at Maria, Scully's pointer can be pointed at Jordan. And now, even though the list looks a little weird, this is a key feature of the linked list. These nodes could have been malloc from anywhere. So indeed, even though we initially kept everyone physically sorted left to right-- and you've all cleaned the list up even since-- that's OK. The point is that all of these nodes are linked together. So, thank you so much to our volunteers. You can keep these pieces of paper and later on we'll have some stress balls for you. But that's the key idea here behind a linked list. Thank you. So, of course, there are some more complicated operations that we might have to deal with. For instance, if we want to insert into the middle of the list, that's going to be a little more of a burden on me, the program, keeping track of where things have to go. But nicely enough, there's only these three cases-- the beginning of the list, the end of the list, and the middle of the list, because middle of the list doesn't have to mean literally the middle, just anywhere that's not the beginning or the end. Of course, we should be careful to make sure that we handle the empty list scenario, which is equivalent to putting something at both the beginning of the list and the end of the list. But that would be perhaps a special case we could deal with separately. Of course, there are other operations like inserting-- or rather removing from the tail of the list, removing from the head of the list, and removing in the middle. And that would be the opposite of malloc, if you will. And in those cases, we have to take care to call our friend free to free those bytes of memory, give them back to the operating system so that we don't leak memory. But there, too, I'm probably going to have to be careful as to what order I change my pointers and free nodes. Because what you don't want to do, and what unfortunately you might very well accidentally do at some point, is free a pointer and then try to access that pointer or change the pointer, even after you've told the operating system I'm done with this address. That can give you what's called a segmentation fault, which is just one of the ways in which you can deduce that kind of mistake. So, let's actually implement one of these methods. And we'll pluck off one that allows us to actually take a look at the syntax with which we can manipulate pointers. And let's go ahead and implement a function called search, for instance, where search I [? proposed ?] just returns a bool, true or false, this number n is in the given the list. And now, why have I said node star list? Well, at the end of the day, a linked list is just a whole bunch of nodes. But the first of those nodes that we keep calling first is of what data type? If you have a pointer, a variable, that's pointing to a linked list, that means it's storing the address of a node, otherwise known as a node star. So, this would be the syntax with which you can pass to a function something like a linked list. You simply have to pass it a pointer to the first element in that list. And if I want to go ahead now and implement this, propose the following. Let me go ahead here and give myself a temporary value, so node star pointer we'll call it, PTR. And that's going to equal So, I'm just creating another box of memory and I'm storing inside of it the same address that I was passed in, just so that I have a temporary variable that I can use to update. After this, let me go ahead and say while that pointer is not equal to null-- because recall that null is this special sentinel value that means end of the list. So inside of this loop, what do I want to do? and say if pointer-- and now I have to get at the number inside of it. So, if I recall from the last time, we only spent a little bit of time on the student example, but we said something like student dot name or student dot dorm. And in this case I'm inclined to say pointer dot n, where n is the number, the integer that's inside. But pointer this time is not a struct, per se. It's the address of a node. It's the address of a struct. And so, perhaps the most intuitive piece of syntax in C, at least retrospectively now, is that if you want to access a piece of data that's inside of a node and you have a pointer to that node much like our arrows in the pictures imply, you literally draw an arrow using a hyphen and then using a right angle bracket. So, now if we do see-- whoops, let me finish my thought. If pointer n equals equals the n we're looking for, let me go ahead in here and say return true. Or else, let me go ahead and not return false, because I don't want to just check one element and then blindly say false. I instead want to say pointer should get pointer arrow next. And then only after that loop is all complete should I say something like nope, return false. So, what's actually going on here? The function declaration, again, took in two arguments-- one, an int n that we're looking for, two a pointer to a node, node in a linked list. And per the pictures we've been drawing, you can access any other element in that linked list by way of the first element in that list, as suggested here. So, now I'm just giving myself a temporary variable called pointer, but I can call it anything I want. And I'm declaring it as node star, so that it can store the address of a node as well, and then I'm just initializing it to be the exact value that was passed in. So, I don't want to accidentally break the list that I was passed. I don't want to change the value of my parameter unnecessarily and complicate things. I just really want a temporary variable, much like I in the world of loops that allows me to constantly iterate through something and update it as I go while the whole along the way I want to be checking this. While pointer is not null. If pointer is null, that means I'm at the end of the list, or maybe more curiously, I was passed null, in which case there is no list. And that's a valid scenario that could happen, even though it's a bit strange. But if pointer is null, I don't want to proceed further inside of this loop. But so long as pointer is not null, let me go ahead and do this. Let me follow that pointer and go inside that node and say is your n value equal equal to the [? end ?] value that I've been asked to search for? And if so, return true. I don't want to just return false now because otherwise I'd only ever be checking the first element in a linked list. So, I now want to do the equivalent in spirit of i plus plus. But I'm not using i's. I don't need to use pointer arithmetic here, and indeed it won't work because I have this thing stitched together. It's not an array of contiguous memory. I want to say that my current temporary value whatever pointer arrow next is, and then let this loop continue. If it's not null, check again. If it's [? end ?] value equals what I'm looking for and repeat, repeat, repeat until pointer equals null. So, let's make this more concrete. Let me go ahead and just draw a temporary picture here. And let me suppose here that what I have been passed is something like the following. Let's do a very simple linked list that has maybe the number one, and has the number two, and has the number three. And, again, I've drawn gaps between these nodes, because they could be anywhere in memory. So, technically they don't need to be left to right like this, but that'll keep us sane. And if this is indeed a correct linked list, there are pointers in each of those fields that point to the next node in the list, and that slash I drew in the last one just means null. You can draw it however you want. But for a linked list to work, we need to know the beginning of this thing. So, we'll call this first, and that of course has to point to the first element in my linked list. So, here's the state of our world. It's a linked list quite similar in spirit to the other one. It's a little shorter, just for the sake of discussion. And now, let's consider my function search, which again takes two arguments. So, that the first argument is of type int called n. And suppose I'm searching for the number three. The second argument is a node star, so the address of a node called list. So, what does that mean? When this function search is called, let's suppose that we currently have the value n, which is going to be 3, because that's arbitrarily the number of decided to search for. And then this other value pointer is going to be initialized-- sorry, not that. List is going to be whatever pointer is passed in as the second argument to this function. So, let's suppose that this linked list, this sample linked list at the top, is indeed what is passed in to this function. So, I've passed in 3, because I want to search for 3. So what goes here? If I pass this sample linked list into my search function, what is the value of list? Well, list if I'm past is really going to be the pointer to the first element in the list. That's all we're saying. Node star list just means give me the address of a linked list, which means give me the address of the first node in the linked list, which means that initially when I call search my picture-- my stack frame, if you will, in terms of my local arguments-- is going to look like this. All right, so with that said, how does this code work? We recall in this code have this while loop that just sits in a loop checking whether the current nodes n equals equals the one we're looking for, and if not, it updates it. So, we need one more local variable called pointer that's initialized to the start of this list. So, this will be a pointer and it's initialized to the same thing that my second argument is initialized to. So, this now is the state of our world once one line of code has executed, that very first one in there. So, now let's implement the loop. While pointer does not equal null, so here's pointer. Does it equal null? No, because if it did, we would just draw a slash or some other piece of syntax. But it's pointing at clearly something that exists. So, this node here has some valid address. Pointer is pointing at it, so it's not null. So, what do I do inside of my code? I check if the n value inside of pointer, PTR, number I'm looking for, and if so, return true, otherwise, if not I update pointer. So let's check. Let's follow the arrow, PTR, and look at the value n. Recall that the top of these boxes is n. The bottom of them is called next-- n, next, n next. So, I followed this pointer. I'm looking at the box called n. Does 3 equal 1? No, obviously not. So I update-- pointer gets pointer next. So, to be clear, pointer gets pointer next, that second to last line of actual code. So, what does that mean I need to do? That means I need to update pointer to be equal to pointer next. What is pointer next? Well, here's pointer and here's next. We were looking a moment ago at n. Now I'm looking at next. So, pointer next means that I should update whatever is inside this box-- and a lot more on the screen-- to be equal to pointer next, which is this field. This field is pointing at that, so that line of code has the effect of updating PTR to simply point at the second node. So, what happens next? I seem to still be in that loop and I say, well, pointer does not equal null, and it doesn't. It's pointing at that second node. If pointer arrow n equals equals n, but no that's not the case, because I'm looking for three. I'm pointing at two, so that is again false. So, again, I don't return true. I instead update pointer to equal pointer next. So, what has to happen here, at the risk of deleting my handiwork again, now pointer gets pointer next, which is this element, which is equivalent to pointing at this node here. And so, now I'm still inside that loop while pointer-- not equal to null. It's not null. n, well, let's follow that logic. If pointer, follow the arrow, n equals equals n, three-- which is the one I'm looking for-- returned true. And so, how then does this function ultimately behave? It would seem in this case to return true, because I have eventually found that number three. What would happen by contrast if I were looking not for three, but for four with this code? In other words, what if I'm not looking for three and I want to go one step further? Well, one step further is going to update PTR to equal null, that slash in my last node. And that means code wise, I'm going to break out of that loop, because pointer now does equal null. And so, by default that very last line of code return false, not found. So, complicated at first glance, and it certainly looks more complicated than things we've written before, but again, if you go back to basics, what does each of these lines mean? Consider that there's no magic here. This first line means give me a variable that's a pointer to a node. It'd be in other words and assign it whatever I was passed in. While pointer [? naught ?] equals null, we've seen null before. It's this special zero value, and I'm just making sure that the pointer I'm using, PTR, does not equal that special value. And then inside of this loop I'm using one piece of new syntax, this arrow notation, which just like the picture suggests means go there, and then look at the field called n and check if it equals the n you're looking for, and if so return true. Otherwise, update yourself much like i plus plus but specifically update pointer to be whatever the value is when you follow the arrow in that next field. So, this of course is just search. We've not actually changed the list, but imagine, if you will, that you could now implement insert and delete, not simply by following these pointers but actually changing the value of next in a node to the left, a node to the right, or a new node all So, who cares? Why did we add all of this complexity? We had arrays, which were working really well for a whole bunch of weeks, and now we've claimed that arrays are not so good. We want to use linked lists instead. But why might we want to use linked lists? Well, linked lists gives us dynamism. We can call malloc and give ourselves more, and more, and more nodes and grow our list of numbers, even if we don't know in advance how many such numbers we need. And we can shrink them, similarly, so we don't have to allocate a massive array unnecessarily. We can shrink our data structure based on how many numbers we actually need. But we're paying a price. Search is a little bit slower, delete is a little bit slower. Insert would be slower if we insist on keeping things sorted, so we've paid this price. And indeed, this is thematic. In CS50, in computer science more generally, there's often going to be these trade-offs of time, or space, or just complexity, or your human time. Any number of resources can be in scarce supply. And, indeed, we've seen by way of linked lists that we're solving one problem while introducing another. It's like that silly situation you might see memes of where you cover your hands-- put your hand around a hose that has a leak and all of a sudden another leak springs up over there. We're just moving the problem elsewhere, but maybe that leak is less problematic to us than this one here. So, again, it's this theme of trade-offs. Now, this here is Mather Dining Hall. And this, of course, is a whole bunch of trays where you might go and get some food, lunch, breakfast, or dinner, or the like, and you pick up this tray and you put food on it. But what's interesting about trays, as Mather and a lot of cafeterias do, is trays are stacked one on top of the other. And it turns out now that we have this second building block with which to create data structures-- we're not just using arrays anymore. We now have pointers and this general idea of linking nodes together in our toolkit, we can now start to imagine more interesting data structures that solve problems in slightly different ways. For instance, suppose that I wanted to implement this paradigm of stacking things on one on top of the other like this. Indeed, this is a data structure called a stack, and it generally has two operations associated with it, push to push something on the stack and pop to take something off of the stack. And this is perhaps a useful data structure if you just want to store numbers or something else in really just the most efficient way for you without regard really to fairness. So, for instance, if this table here is my initial data structure and it's empty and I have a piece of information that I want to store, I'm just going to going ahead and put it right there. And now suppose I want to push another number onto the stack. ahead and simply put it on top, third number on top, fourth number on top. But I've now committed to a certain property, if you will, a certain property whereby the last tray in has to be the first tray out, otherwise known in computer science as LIFO-- last in, first out-- because if I want to get that first number, I mean, I've created a mess for myself. I have to lift these all up or move them just to get at it. That just seems stupid. Intuitively, the easiest thing to grab is probably going to be the top, but that's not necessarily the first element I put in. But that's OK. This might still be a valid data structure-- and indeed later in the term when we introduced web programming and we look at languages like HTML, there's actually a number of applications where it's actually super useful to have a data structure where you can just stack stuff on top of each other in order to tuck some data away for subsequent use. And, indeed, when we talked about memory in our own computer, stacks clearly have some value. We talked about main and then swap, and then maybe other functions. There are many contexts, one of which we've seen already, where in life you actually want to stack things on top of each other so as to keep track of really what did I do most recently, because that's the next problem I'm going to deal with or the next frame-- in the case of memory-- that I'm going to pop off of the stack. So, how might we implement this data structure? Let me propose that if we want to define our own data type called the stack that implements that idea of cafeteria trays or frames in memory, let me go ahead and typedef a structure called stack inside of which are two data members. Suppose that, for the I'm not going to try to store trays or something that doesn't really exist computationally but rather numbers, just integers. Inside of this structure called a stack is going to be an array called numbers of type int and it's going to store capacity. So capacity, let's assume, is hash defined elsewhere to be some constant. So, maybe it's 10, maybe it's 1,000, but it's some constant integer elsewhere that limits, ultimately, the capacity of the stack to some integral value. And then size-- this seems weird. I have capacity here and then size here. Well, there's the semantic distinction here. Just because you have a stack ready to go, as I did a moment ago-- just because I had this stack ready to go, empty initially, it's going to have some capacity. Realistically, I can only go as high as the ceiling or until the things fall over. But there's also a size here, and the size is currently zero, but the capacity might be like 1,000 or whatever. So, that's the difference there and the size now is 4 and the capacity is like 1,000 minus 4 at this point-- or rather, capacity is still 1,000, because that's the total possible size, not the actual size. But what if that's a limit? What if I don't want to restrict myself to some fixed, finite number of trays or a fixed number of numbers? Well, I could instead declare my stack as being a pointer. Now, this pointer initially has no value, so let's assume that it's probably going to be initialized to null in my code, but that too is not going to be useful. Why would I declare numbers now not to be in an array, which felt very straightforward. Normally we draw arrays left to right, but with the trays, just imagine turning an array vertically and thinking of the number stacked on top of each other. But this is just a pointer to a number. Why might I want to implement a stack as just a pointer to an int? That seems wrong. I want lots of numbers, not one number. So, what could I do? Well, what if in this world to implement a stack I invoke our friend malloc and I say to malloc, malloc, give me enough memory for 2,000 numbers or 5,000 numbers. What is malloc going to return? Well, by definition, we know malloc is going to return the address of a chunk of memory, and that chunk of memory is going to be of whatever size I ask malloc for, and the address of the first is really just equivalent to the address of one integer. And so long as I, the programmer, remember that I asked malloc for 2,000 integers or for 5,000 integers, I know implicitly the end of that chunk of memory and malloc just need to tell me the beginning. So, it's perfectly fine to implement the stack by way of a single pointer, because all I need to know is, hey, malloc, where should I put my first integer? Because I know via pointer arithmetic, per last week, that I can put my next integer four bytes later, four bytes later, four bytes later. And I'm deliberately going up this time, but it really is just an array where you can think of the array as left and right. So, this would be a way of giving ourselves a data structure called a stack that is not fixed from the outset like this previous version to some specific capacity. Now, we are limited only by how much physical memory or virtual memory my computer actually has. So, suppose Apple or someone similar implemented the lines outside their stores for the release of the iPhone as a stack. So, it's weird maybe to think of people stacking on top of each other, but maybe you could imagine Apple funneling everyone into the glass store here in Manhattan, and then whoever is the last one in gets their phone first. Because why? They're closest to the exit. So, you have all these people show up super early in the morning or days before, you pile them all into the store saying everyone, hey, please go into the corner there. Please get into the store. And then as soon as 9:00 AM rolls around and it's time to give out the iPhones, just for logistical convenience you realize, all right, why don't we just give the person who came in last their phone first because they're closest to the exit and get them out, last in, first out? Good design, bad design? It's correct in so far as everyone's going to get an iPhone if supply is there, and that's never going to be the case. So, it's not necessarily very equitable or fair, and indeed the humans are not going to be very pleased with Apple if they used a LIFO data structure or a stack. What would these fans of Apple hardware prefer that Apple use? We call it a line. If you go to the UK, they call it a queue, which is actually a perfect answer, because there's this other data structure in the world called a queue, which is exactly what you would hope the Apple store line would be, a line whereby it's first in, first out. So, the first person there three days before, at 5:00 AM gets his or her phone first, and the one person who comes in at 9:01 AM doesn't get their phone because they're at the last position in the queue or the list. And a queue, nicely enough, might just have at least two operations-- enqueue and dequeue whereby enqueue means get into line d queue means get out of the line, but these happen at different places. For instance, if there's a whole bunch of people lined up here on the stage, closest over there's I get here last. I enqueue myself at the end of this data structure, but you dequeue someone from By contrast, when we had a stack, when you push someone onto the stack, you pop it off, or him or her off first by nature of it being a LIFO data structure. So, how might we implement a queue? It's actually slightly more complicated, 50% more pieces of information you need to keep track of, the front of the list. But you can still do it in an array. So, suppose that we do use an array, and let me go ahead and draw this Suppose that like hopscotch we draw the queue for an Apple Store like an array like this. And here is the door of the Apple store, so you want to be at location zero, ideally. 1, 2, 3, 4, 5, 6-- so this is how many people can fit into our queue in this case. So, suppose that Alice wants to buy an iPhone and she gets to the store first. Where should she go to keep things fair? This is the queue, so we don't want to put her into the corner, so to speak, in our first example. We want to put her at So, Alice belongs right there, pretty straightforward. Now, Bob arrives and he comes in slightly after Alice, so he gets to get behind Alice in line. And so Bob is there, and maybe Charlie arrives thereafter, and then so forth. David maybe comes in fourth and beyond. So, that's how people would queue up, so to speak. And now, when it's time for Apple to open this door and start selling iPhones, what happens? We want to take Alice out of the list first. We want to de-queue Alice. So, we need to start remembering some information, because it's not sufficient now to just remove-- whoops, it's not sufficient just to remove Alice like this, because suppose that we do keep adding other people, person d, e-- whoops, that's not an f. OK, don't know what happened there. Person f is here, g, h. Suppose that Alice has bought her phone and left the store, and then Bob does the same. He goes ahead and leaves the store, and then Charlie leaves the store. Where do I put person i who maybe shows up a little late? It would seem that I want to put them at the end of the queue, which makes good sense, but right now d, e, f, g, and h are still in the queue, and this is an array I proposed. My data structure's an array, so I can't just move d to the front of the line easily. I have to actually shift him or move him, and this might conjure up some memory of our searching and sorting examples where when we had our humans on stage, we actually had to physically move people like an insertion sort to make room for those elements. And that's fine. We can absolutely say, hey, David, come over here please and person e, come over here please, and that's obviously what the Apple store does. But when you're implementing this idea in memory, you can't just ask the numbers themselves or the elements themselves to do that moving. You need to do it for them, and that's going to cost you time, and that's going to be a price that you have to pay. But I propose that we can be clever here. We do not need to incur the cost of moving d, e, f, g h where Alice, Bob, and Charlie previously were. Where can we put person i instead? I mean, there's obviously room in the line, so maybe why don't we just put person i here? But, again, we don't want to piss off everyone who's already in the line. So, if this now is an array, we have to be mindful of the fact that the front of this list has to be remembered separately. This data member here front really should store not 0 in perpetuity but really 0, 1, 2, 3. It should store the current front of the list. And I need another variable, presumably, called size that keeps track of how many elements are in the list, which in this case is going to be six. So with a queue, if I'm implementing it using an array, there's some added complexity if I want to avoid the inefficiency of moving all of these elements and incurring the kind of running times we saw when we talked about searching and sorting the other day. There's no reason mechanically to move d, e, f, g, h anywhere in the array. We can in constant time, and maybe our old friend the modulo operator that you might have used in [INAUDIBLE], we can just figure out where i, and j, and everyone else should go so long as we keep track separately with a queue of what the front of the list would be. And why is this 3? Well, if I continue numbering the array like this, as we've often done, you can now see that d is the head of the list, or the front of the list. And so, we should remember his location there as 3. But, again, what happens if j, k, and then l shows up? There is no room for l in this world, not to mention m, n, o. So what if we solved this problem as before by changing the array from having some fixed capacity to having no pre-determined capacity, just use a pointer so that we can use malloc to dynamically allocate a big chunk of memory, remember its capacity ultimately, but also remember the front and the size of this data structure? So, the same idea there might apply. day, what have we done? We've taken these new building blocks, pointers, and this notion of linking things together using pointers much like a linked list, and we've looked back at our data structure called an array. And using these now, we can implement what are generally called abstract data types, a queue in a stack does not have as a low level meaning as an array does, which is a very technical concept. And in a linked list, this It's a node with pointers linking things together. A stack is like a stack of cafeteria trays, or a queue is something like people lining up outside of an Apple Store. These are abstract data types that can be implemented clearly underneath the hood in at least a couple of different ways. You can use an array and keep things simple, a la weeks two and beyond in the class, but you're going to paint yourself into a corner by fixing their size, as I did a moment ago, by declaring this queue and before it a stack to be of a fixed capacity. But now that we have pointers, and malloc, and dynamic memory allocation, and this spirit of linked lists, we can change that to actually be numbers and actually just remember where things are underneath the hood. And nicely enough, a stack in a queue doesn't even need me to stitch things together like a linked list. I just need malloc in order to allocate those. So, let's tie these two topics together if you would and compare and contrast them by way of a wonderful animation that a fellow educator made and posted online that we've abbreviated here to give us a sense of the difference between stacks and queues. [AUDIO PLAYBACK] [MUSIC PLAYING] -Once upon a time, there was a guy named Jack. When it came to making friends, Jack did not have the knack. So, Jack went to talk to the most popular guy he knew. He went to Lou and asked what do I do? Lou saw that his friend was really distressed. Well, Lou, began just look how you're dressed. Don't you have any clothes with a different look? Yes, said, Jack. I sure do. Come to my house and I'll show them to you. So, they went off to Jack's, and Jack showed Lou the box where he kept all his shirts, and his pants, and his socks Lou said I see you have all your clothes in a pile. Why don't you wear some others once in a while? Jack said, well, when I remove clothes and socks, I wash them and put them away in the box, then comes the next morning and up I hop. I go to the box and get my clothes off the top. Lou quickly realized the problem with Jack. He kept clothes, CDs, and books in a stack. When he reached something to read or to wear he chose [? the top ?] book or underwear. Then when he was done he would put it right back, back it would go on top of the stack. I know the solution, said a triumphant Lou. You need to learn to start using a queue. Lou took Jack's clothes and hung them in a closet, and when he had emptied the box he just tossed it. Then he said, now, Jack, at the end of the day put your clothes on the left when you put them away. Then tomorrow morning when you see the sunshine, get your clothes from right from the end of the line. Don't you see, said Lou. It will be so nice. You'll wear everything once before you wear something twice. And with everything in queues in his closet and shelf, Jack started to feel quite sure of himself all thanks to Lou and his wonderful queue. [END PLAYBACK] SPEAKER 1: All right, so let's take a look at another data type, this one known as a tree. Because now that we have the ability to stitch data structures together much like a linked list, we now have the ability to stitch things together not just left to right or top to bottom conceptually, but in any number of directions. And indeed, there's nothing stopping us from having one node linked to by way of multiple pointers, multiple nodes. So, for instance, this picture here from a textbook is a tree structure. And it's very much like the family trees that you might have drawn in grade school or the like. But in this case, you have just one root node, the node at the top of the from which everything else descends. And that node is said to have children. For instance, 2 and 3 are children of the node number 1 here. And then there's other semantics in this world of trees in computer science. Much like family trees, anything that does not have children-- like 5, 6, and 7, or 8 and 9-- would be called leaves of the tree, because like the leaves at the end of the branches, there is nothing beyond them. So, nicely enough we borrow a lot of the language from family trees and actual trees in order to discuss this data structure known as a tree. But why in the world would we want to lay out data in a tree structure? Now we just seem to be doing things because we can, it would seem at first glance. Because, for instance, suppose we had these numbers-- 22, 33, 44, 55, 66, 77, and 88. They're clearly sorted. And suppose that I wanted to lay these out in a data structure and be able to search them efficiently, assuming the whole time that they are indeed sorted. Well, if we wanted to do that, we have our old friend arrays from weeks ago. And we also have our old algorithm from Mike Smith, our binary search algorithm, divide and conquer. And we can find nodes in this data structure super, super fast in logarithmic time, big O of log n. So, we've solved that problem. But it turns out we don't necessarily have to use an array laying out data from left to right because, again, one of the prices we pay of using arrays where as we've realized today is this finiteness. At the end of the day, the size of an array is fixed. You have to decide in advance how big your array is going to be. So, what if you want to add more numbers to it? What if you want to remove numbers for efficiency and not waste so much memory? You can't really do that with an array. You can, but have to jump through some hoops. You have to reallocate the array, as with a function like [? re-alloc ?] if you indeed used malloc in the first place to allocate it. But then you have to copy the old array into the new array, so it's all possible. Nothing's impossible once you have a keyboard at your disposal, but it's a lot of work, and it's more time, and it's expensive there for both in terms of your time and the computer's time. But could we achieve the beauty of divide and conquer and binary search from week zero without the constraints that arrays impose? And today, the solution to all of our array problems seems to be linked lists or more generally pointers so that, one, we can dynamically allocate more memory with malloc when we need it and then use pointers to thread or stitch together that node with any existing nodes. So, indeed let me propose this variant on a tree structure that the world calls binary search trees or BSTs. Binary in this case means two, and this just means that every node in this tree is going to have 0, 1, or 2 maximally children. And now, in this case binary search tree means that for every node in the tree it's left child is less than it and its right child is greater than it. And that's a recursive definition. You can look at the root of this tree and ask that same question. 55? Is it greater than its left child? Yep. Is it less than its right child? That is the beginning, it would seem, of a binary search tree. But it's recursive in so far as this is indeed a binary search tree if that statement is true. Those answers are the same for every other node in the tree. 33, is its left child smaller? Is its right child bigger? How about over here, 77? Left child smaller? Right child bigger? Yep, indeed. How about the leaves of the tree? Is 22 greater than its left child? I mean, yeah, there is no child, so yes, that's a fair statement. It certainly doesn't violate our guiding principle. Is it less than its right child, if any? Yes, there just isn't any. And so this is a binary search tree. And indeed, if you took a scissors and snipped off any branch of this tree, you would have another binary search tree, albeit smaller. But it's recursive and that definition applies to every one of the nodes. But what's beautiful here now is that if we implement this binary search tree, similar in spirit to how we implemented linked lists using not arrays but using pointers and not one pointer but two pointers whereby every node in this tree apparently has up to two pointers-- let's call them not next but how about left and right just to be intuitive. Well, if every node has a left and a right pointer, now you can conceptually attach yourself to another node over there and another node over there, and they too can do the same. So, we have the syntax already with our pointers with which to implement this. But why would we? Well, one, if we're using pointers now and not an array, I can very, very easily allocate more nodes for this tree. I can insert 99 or 11 really easily, because I just called malloc like I did before. I put the number 99 or 11 inside of that node, and then I start from the root of the tree, much like I start from the first element in the linked list, and I just search for its destined location going left or right based on the size of that value. And what's nice, too, here is notice how short the tree is. This is not a linked list. It's not a long list, whether vertically or horizontally. This is very shallow this tree. And indeed I claim that if we've got n elements in this list, the height of this tree it turns out is log of n. So, the height of this tree is log of n, give or take one or so. But that's compelling, because how do I search this tree? Suppose I am asked-- I'm trying to answer the question is 44 on my list? How do I answer that? Well, we humans can obviously just look back and it's like, yes, 44 is in it. It's not how a computer works. We have to start from what we're given, which in this case is going to be as the arrow suggests a pointer to the tree itself, a pointer towards first node. And I look is this the number 44? Obviously not. 55 is greater than 44, so I'm going to go down to the left child 33, is this 44? Obviously not, but it's less than it so I'm going to go down to the right child. Is this 44? Yes, and simply by looking at three nodes have I whittled this problem down to my yes no answer. And indeed, you can think of it again with scissors. I'm looking at 55 at the beginning of this story. Is 44 55? No, 44 is less. Well, you know what? I can effectively snip off the right half of that tree, much like I tore that phone book in week zero, throwing half of the problem Here I can throw essentially half of the tree away and search only what remains and then repeat that process again, and again, and again, whittling the tree down by half every time. So therein lies our logarithmic running time. Therein lies the height of the tree, so long as I am good about keeping the tree balanced. There's a danger. Suppose that I go ahead and start building this tree myself in code and I'm a little sloppy about doing that. And I go ahead and I insert, for instance, let's say the number 33. And it's the first node in my tree, so I'm going to put it right up here at the top. And now suppose that the next number that just happens to get inserted into this tree is 44. Well, where does it go? Well, it has no children yet, but it is bigger, so it should probably go over here. So, yeah, I'll draw 44 there. Now, suppose that the inputs to this problem are such that 55 is inserted next. Where does it go? All right, 55, it's bigger, so it should go over here. And then 66 is inserted next. All right, it goes over here-- never mind that. So, what's happening to my binary search tree? Well, first of all, is it a binary search tree? It is because this node is bigger than its left child, if any-- there just isn't any-- and it's less than its right child. How about here, 44? It's bigger than its left child, if any-- because there is none-- and it's smaller than its right child. The same thing is true for 55, the same thing is true for 66. So, this is a binary search tree and yet somehow what does it look like? It looks like a linked list, right? It's at a weird angle. I've been drawing everything horizontally, but that's a meaningless artistic detail. It devolves potentially into a linked list. And so, binary search trees if they are balanced, so to speak, if they are built in the right order or built with the right insertion algorithm such that they do have this balanced height, this logarithmic height, do afford us the same logarithmic running time that the phone book example did and our binary search of an array did. But we have to do a little bit more work in order to make sure that these trees are balanced. And we won't go into detail as to the algorithmics of keeping the tree balanced. But realize, again, there's going to be this trade-off. Yes, you can use a binary search tree or trees more generally to store numbers. Yes, they can allow you to achieve that same binary or logarithmic running time that we've gotten so used to with arrays, but they also give us dynamism such that we can keep adding or even removing nodes. But, but, but, but it turns out we're going to have to think a lot harder about how to keep these things balanced. And indeed, in higher level CS courses, courses on data structures and algorithms will you explore concepts along exactly those lines. How would you go about implementing insert and delete into a tree so that you do maintain this balance? And there is yet more variance on these kinds of trees that you'll encounter accordingly. But for our purposes, let's consider how you would implement the tree itself independent of how you might implement those actual algorithms. Let me propose this type of node. Again, notice just the very generic term in programming where it's usually like a container for one or more other things, and this time those things are an integer-- we'll call it n but it could be called anything-- and two pointers. And instead of next, I'm going to just by convention call them left and right. And as before, notice that I do need to declare struct node up here or some word up here. But by convention I'm just going to do typedef struct node, because C reads things top to bottom, left to right. So if I want to refer to a node inside of a node, I need to have that vocabulary, per this first line, even though later on I just want to call this whole darn thing a node. And so, that's the distinction. This actually has the side effect of creating a data type by two different names. One is called struct node, and you can literally in your code write struct node something, struct node something. It just feels unnecessarily verbose, so typedef allows you to simplify this as just node, which refers to the same structure. But this is necessary for this innermost implementation detail. So, now that we have the ability with a structure to represent this thing, what can we actually do with it? Well, here is where recursion from a few weeks ago actually gets really compelling. When we introduced that sigma example a while ago and talked in the abstract about recursion, frankly, it's kind of hard to justify it early on, unless you actually have a problem that lends itself to recursion in a way that makes sense to use recursion and not just iteration, loops-- for loops, while loops, do while, and the like. And here we actually have a perfect incarnation of that. What does it mean to search Well, suppose I'm searching for a number n and I'm being given a pointer to the root of the tree, and I'll call it tree. So, just like when I was I'm given two things, the and a pointer to the first thing in the data structure-- the first thing in a linked list or the first thing in a tree. And in this case, we would call that first thing in a tree a root, generally speaking. So, the first thing I had better do in my search function is check, wait a minute. If tree equals equals null, don't do anything. Do not risk touching any pointers, because as you may have gleaned already or soon will with some of CS50's problems, you will cause quite probably a memory-related problem in your program such that it just crashes. It literally says segmentation fault on this screen if you touch memory that you should not. And you should not touch null values. You should not go to null values. You should not do star of any value that itself might be null. And so, if tree equals equals null is super, super important here, because I want to make sure to immediately say, well, if you hand me null, that's like handing me no tree whatsoever. So, my answer is obviously false. N can't be in a non-existent tree. But we need that condition up top, because the next case is [? noticed through ?] the following. Else if n-- the value we're looking for-- is less than the value of n in this node-- tree, recall, doesn't refer to the whole thing, per se, in this context. It refers to the current node that we've been past, which at the beginning of the story is the root of the tree. So, if the number n in the root of the tree is greater than the number we're looking for, we want to go to the left. Else we want to go to the right and search the right subtree. So, what's the syntax here? If the n we're looking for, like 44, is less than the value at the current node, 55, then what do we want to do? We want to call search, still searching for the same number n but searching on the left subtree. And how do you pass in a pointer to the left tree? Well, you have in tree a pointer to the root node. Tree arrow left just means go to my left child and past that value in instead, pass its address in instead. Meanwhile, if the number is actually greater than the value in the current node, search the right subtree, else return true. Because if the list is not null-- if there is actually a list and the number you're looking for is not less than the current node and it's not greater than the current node, it must be the current node, so you can return true. But there's one important detail here. I didn't just call search. I called return search in each of these two middle cases. Why is that? Well, this is where recursion gets potentially a little mind bending. Recursion is the act of a function calling itself. Now, in and of itself, that sounds bad, because if a function calls itself, why wouldn't it call itself again, and again, and again, and again, and again, and just do this infinitely many times such that now you get a stack overflow where all of those frames on the stack hit the heap and bad things happen. But no, recursion works beautifully so long as every time you recurse, every time a function calls itself it takes a smaller byte of the problem. Or rather, put another way, it throws away half of the problem, as in this case, and looks only at a remaining half. Because if you keep shrinking, shrinking, shrinking, shrinking the problem, you will eventually hit this base case where either there is no more tree or you're looking right at the node that you want to find. And so, by returning search and tree left, or returning search and tree right, you're deferring the answer. When you, the search function, are called and asked is the number 44 in this tree, you might not know because the node you're looking at at the beginning of the story was again 55. But you know who does know? I bet my left child will know the answer to that if I just ask it by passing it-- passing to search a pointer to it, my left child, and passing in that same number 44. So, saying return search is like saying I don't know. Ask my left child. Or I don't know, ask my right child and let me return as my answer whatever my child's answer is instead. So, you could do this same function using iteration. But you could solve it arguably much more elegantly here using recursion, because a data structure like this-- like a binary search tree, which again is recursively defined-- each node is conceptually identical, if numerically different from the others, allows us to apply this algorithm, this recursive algorithm to that particular data structure. Now, let's look at a more concrete incarnation of trees that allows us to do something pretty neat and pretty real world. Indeed, this is another problem borne of a real world domain of compression. We talked a couple weeks ago about encryption, the art of concealing or scrambling information. Compression, meanwhile, is the art of taking something that's this big and compressing it to make it smaller, ideally without losing any information. It's pretty easy to take a 10 page essay that's maybe-- that was supposed to be a five page essay and just remove paragraphs from it or remove sentences from it. But that changes the meaning of the paper, makes it a worse paper, even though you're compressing it by making it smaller. No, what most students would typically do, if you've written 10 pages and it needs to fit into five, you really, really, really shrink the font size or increase the margins. Or maybe more realistically you write a five page paper that's supposed to be a 10 page paper, and so you increase the font size or increase the margins so as to expand or decompress the essay. So, similarly here, what if we wanted to compress text, but we want to do it losslessly in a way that we don't lose any information by just throwing away characters, or paragraphs, or pages, but we want to use the system with which we're familiar from week zero. So ASCII, again, is just this code, this mapping of letters to numbers. And so, A is-- capital A is 65 and that's some pattern of bits, but it's some pattern of 8 bits-- 7 historically, but really 8 bits in practice So every one of the characters in the English alphabet, at least here, takes up 8 bits. Now, that sounds fine. That allows us to express as many as 256 possible characters, which is more than enough for English characters, plus some punctuation But it seems wasteful. I type A, E, and I, maybe O and U pretty often. I use the values often-- the vowels often. B and D, I feel like I use those a lot. I don't really type Q all that much, Z all that much. So, there are certain letters that I just feel like I don't type them that often, and indeed, probably if we analyzed a dictionary, we wouldn't see them as frequently as other letters. Indeed, if you've ever played or watched Wheel of Fortune, certainly all the contestants on that show know which are the most popular letters in English words. And it seems silly and perhaps inefficient-- certainly for a computer scientist-- that we are not somehow embracing the fact that some letters are more commonly used than others, and yet we are just blindly using 8 bits, the same amount of memory, for every darn letter in our alphabet. Why? If you keep writing a certain letter again and again, why not use fewer bits for the more popular letters, and more bits for the less popular letters so that at least you're optimizing for the common case, so to speak? Well, it turns out that someone named Huffman years ago did figure this out and introduced what's generally known as Huffman coding. And, at first glance, it's a little similar in spirit to something some of you might have grown up learning a little something about called Morse code, but it's better in a couple of ways. Morse code typically transmitted with electrical signals or audible signals. It has dots and dashes where a dot is a quick beep and a dash is a slightly longer beep, and you can use those series of dots and dashes, as per this chart here, to represent letters of the alphabet and some numbers. The one problem, though, as efficient as this seems-- and then by efficient I mean look at E. Mr. Morse realized that is super popular, so he used literally the shortest symbol for it, just a dot, a simple blip, to represent an E. And, meanwhile, as I kind of imagined, Z is not that common, so dash, dash, dot, dot is longer than just a single dot. So Z is probably less popular, and that's why we did this. And Y may be even less popular-- dash, dot, dash-- I don't know why I'm using this voice. But it's longer than E, so we optimized for the shorter characters. Unfortunately, suppose that you receive the message dot, dot, dot, dot, dot, dot, so six dots in a row, and I technically paused in between them. Six dots, what message did I just send you? Six dots. So, I wanted to say hi, so I said dot, dot, dot, dot, which is H, and then dot, dot which is I. I should not have paused between them, because the whole point of Morse code is to do this as quickly as possible, even though you probably do want to pause to resolve ambiguity, and indeed, that's the problem. I wanted to send you hi, H-I, but maybe I just sent you E, E, E, E, E, E, six Es in a row, because those two were just dots. So, in other words, Morse code is not immediately decodable when you're reading, or hearing, or seeing the dots and dashes come over the wire, so to speak, because there's these ambiguities, unless this transmitter does indeed pause, as I accidentally did there, to give you a moment to take your breath and realize, oh, that was an H. That's an I. As opposed to E, E, E, E, E, E. So, it's not necessarily the best system in so far as some letters share prefixes with other letters. In other words, I, dot dot, has a common prefix with E. Both of them start with a single dot. It just so happens that I is a little longer, and that can lead potentially to ambiguity, and it certainly means that the transmitter should probably slow down. So, the whole system is meant to be super fast, super efficient, but you probably should pause between certain letters so that the recipient doesn't get confused as to the message you're actually sending. Well, thankfully Huffman coding-- which as we'll see in a moment is based on trees-- does not have that ambiguity. It is a immediately decodable. And suppose for the sake of discussion, as per this example here, you just have a whole bunch of text that you want to transmit. This is meaningless. There's no pattern in these As, and E, B, C, Ds, and Es, but if you go through and count them up, each these letters-- A, B, C, D, E-- occur with some frequency in this text. So, it's meant to be representative of an essay, or a message, or whatever that you want to send to someone. Indeed, if you count up all of the As, Bs, Cs, Ds, and Es, and divide by the total number of letters, it turns out that 20% of the characters in that random string are As, 10% are Bs, 10% are Cs, 15% are Ds, and 45% are Es, so it's roughly consistent with what I'm claiming, which is that it E is pretty popular. So, intuitively, [? it ?] would be really nice if I had an algorithm that came up with some representation of bits that's not just 8 bits but that is a few bits for the popular letters less popular letters, so I optimize, again, so to speak, for the common case. So, by this logic E, hopefully, should have a pretty short encoding in binary, and A, and B, and C, and D should have slightly longer encoding, so that again if I'm using E a lot I want to send as few bits as possible. But I need this algorithm to be repeatable. I don't want to just arbitrarily come up with something and then have to tell you in advance that, hey, we're using this David Malan system for binary. We want an algorithmic process here. And what's nice about trees is that it's one way of seeing and solving So, Huffman proposed this. If you have a forest of nodes, so to speak, a whole bunch of trees-- each of size one, no children-- think of them as each having a weight or a frequency. So, I've drawn five circles here, per this snippet from a popular textbook that has 10%, 10%, 15%, 20%, 45% equivalently in each of those nodes. And I've just labeled the leaves as B, C, D, A, E, deliberately from left to right because it will make my tree look prettier, but technically the lines could cross and it's not a big deal in reality. We just need to be consistent. In order to figure out the so-called Huffman tree for this particular text, in order to figure out what to encode it's letters as with zeros and ones, go ahead and take the two smallest nodes and combine them with a new root node. So in other words, B and C were both 10%. Those are the smallest nodes. Let's go ahead and combine and add together their weights, so 10% plus 10% is 20%. And then arbitrarily, but consistently, label the left child's edge or arrow as a 0 and the right arrow's edge as a 1. Meanwhile, repeat. So, now look for the two smallest nodes. And I see a 20%-- so ignore the children now. Only look at the roots of these trees. And there's now four trees, one of which has children, three of which don't. So, now look at the smallest roots now and you can go left to right here. There's a 20%, there's a 15%, there's a 20%, and a 45%. So, I'm not sure which one to go with, so you just have to come up with some rule to be consistent. I'm going to go with the ones on the left, and so I'm going to combine the 20% with the 15%, the 20% on the left. Combine their weights. That gives me 35% in a new root, and again label the left branch 0 and the right branch a 1. Now, it's not ambiguous. Let's combine 35% and 20% with a new root that's 55%. Call its left branch 0, its right branch 1. And now 55% and 45%, combine those and give us a 1. So why did I just do this? Well now I have built up the so-called Huffman tree for this input text and Huffman proposed the following. To figure out what patterns of zeros and ones to use to represent A, B, C, D, E, simply follow the paths from the root to each of those leaves. So what is the encoding for A? Start at the root and then look for A-- 0, 1, so 0, 1 shall be my binary encoding for A in this world. How about B? 0, 0, 0, 0 shall be my binary encoding for B. How about C? 0, 0, 0, 1 shall be my encoding for C. How about D? 0, 0, 1. And beautifully, how about E? So, to summarize, what has just happened? E was the most popular letter, B and C, were the least popular letters. And if we summarize these, you'll see that, indeed, B and C got pretty long encodings, but E got the shortest encoding. mathematically you will now have a system for encoding letters of the alphabet that is optimal, that is you will use because you are biasing things toward short representations for popular letters, longer representations for less And mathematically this gives you the most efficient encoding for the original text without In other words, now if Huffman wanted to send a secret message to someone in class or over the internet, he and that recipient simply have to agree on this scheme in advance and then use these encoding to transmit those messages. Because when someone receives 0, 1 or 0, 0, 0, 0 or 0, 0, 0, 1 from Mr. Huffman, they can use that same look-up table, if you will, and say, oh, he just sent me an A or, oh, he just sent me a B or C. So, you have to know what tree Huffman built up. And, indeed, what typically happens in actual computers is when you use Huffman coding to compress some body of text like we just have here, you store the compressed text by storing your As, Bs, Cs, Ds, and Es and other letters using these new encoding, but you somehow have to embed in that file in the compressed file the tree itself or this cheat sheet of encodings. So, with compression-- maybe you're compressing a Microsoft Word file, or a dot TXT file, or any other type of file, you have to store not just the compressed text using these shorter representation-- not 8-bit ASCII, but these shorter representations-- but you also somewhere, maybe at the beginning of the file or at the end of the file, somewhere where someone else can find it, you need to store this mapping or you need to store the tree itself in some digital form. And so, it's possible by this logic that you might try to compress a really small file, and that file could actually become bigger because you're storing a tree inside the file to-- with which to recover the original information. Or better yet, most algorithms or most actual compression programs will realize, wait a minute, if compressing this file is actually going to make it bigger, let's just not compress it at all and leave it alone untouched. So, what if you take a compressed file and compress it again, and compress it again, and compress it again? A dangerous assumption to get into is, well, I could just maybe keep compressing that video file again, and I can maybe compress my big essay, or my big video file, or big music file to just maybe one bit. Right? That's the logical extreme, just keep compressing, compressing, compressing, compressing. But, of course, that can't possibly make sense, because if you compress some file down to just a single bit, 0 or 1, you've clearly thrown away information and can't possibly recover it all. So, at some point, too, you've hit this lower bound on the size of the file until you need to start throwing actual information away. At some point, the file just has so much entropy, appears to be so random, there really is no pattern to start to leverage to compress it further. And so, there generally is some maximum amount of compression you can apply to something. So, how would we represent this? Let's whip out a C struct here. So, this time each of the nodes in a Huffman tree need a little something different. They need, at least in the leaves, some kind of character to remember the symbol. Now, technically only the leaves need to know what symbols they are, so it's a little redundant to have this in every node, but we can keep things simple and use the same type of node for everything. Float frequency, I could use an integer and treat it exactly as a percentage, or I can use a float as the nodes were with 0.1 and 0.45 and so forth, and I'll call that frequency. And then each of those nodes needs a left child potentially and a right child potentially. And, again, I'll call these things a node. So, again, it's getting a little more involved this node, but it still allows me to represent it ultimately in C. And now, it's time to pursue lastly the holy grail of data structures, Thus far, we've been solving problems, creating new problems, trying to solve those again. And the problems we've been exploring this week are things like dynamism, if we want to be able to grow or shrink our data structure. Malloc and pointers give us that flexibility but might cost us a bit more time, because we have to keep things sorted differently or we have to follow all of those pointers. And so, a lot of the algorithms we've been discussing today at least have-- like linear time, searching, or inserting, or deleting potentially like in a linked list. Better still would be something logarithmic like a balanced binary search tree, so still preserving that nice binary aspect from week zero. But the holy grail of a data structure for its operations is Big O of 1 so to speak, constant time. If you are searching, or inserting, or deleting, and somehow changing a data structure, wouldn't it be amazing if every darn operation takes just one step, or maybe two steps, or three steps but a constant number of steps? Now, it might be a little naive for us to expect that we can store an arbitrary amount of data in some fancy way that we get constant time, but maybe just maybe if we're clever we can get close to that. So, let's introduce a step toward that. It turns out there exists in this world things called hash tables. And a hash table can be implemented in any number of ways, but you can think of it really as just an array. So, for instance, this might be a way of representing a hash table called table, whose first location is bracket zero and whose last location is bracket n minus 1 for however long this is. And I just left it as blanks. I don't even know what this hash table might want to store. It could be numbers, it could be names, it could be letters, it could be anything we want. But hash table has this nice theoretical property that if well-designed and thought through, you can maybe just maybe get constant look up time in it. And let's do a simple example of a hash table. Hash tables are often nicely thought of as buckets, so we borrowed these from the loading dock outside just a little moment ago, and we've attached thanks to Arturo some of these signs to them. This is going to be Z, so I'll just put this over here. This is going to be C, so I'll put this over here, and B here, and A. And we thought we might get chased away by the folks on the loading dock, so we didn't bother getting D through Y, So we'll just pretend that we have 26 such buckets here. And suppose that the goal at hand is-- I don't know, it's like at the end of an exam, so we've got our old blue books that a class might use for students writing essays in some class. And it's time for the students to come submit their blue books. Now, we could just collect them all and make a big mess as would generally be the case, or we can be a little more methodical to at least make our jobs easier. Now, at the end of the day, what's going to be interesting about hash tables is that there's going to be this distinction between actual benefits and theoretical benefit, or lack thereof. So, we'll come to that in just a moment, but here's A, B, C, D, and Z. And you know what? I just am going to ask the students in this class-- there are so many people in the room after an exam, I just want them to at least make my life 1/26 as difficult by putting all the As over there, all the Bs here, all the Cs here, all the Zs here, so that I don't have a massive mountain of As through Zs that I have to sift through individually. It would just be nice if they do the first pass of bucketizing the values based on the first letter in their last name. In other words, my hash function, my algorithm, is going to be for each student to consider his or her last name, look at the first letter they're in, and put his or her exam in the appropriate bucket. So, here is, for instance, someone with the letter C. I'm going to put that blue book in here. Here's someone with the letter A. That one's going to go here. Letter Z? This one's going to go over here. Letter B? This is going to go over here. C, and B, and F-- Z, I mean, and all of [? the ?] [? letters ?] of the alphabet in between. So, hashing really has this visual and conceptual equivalence of putting something in this bucket, putting something in that bucket, other bucket, ultimately bucketizing all of your elements. And you can think of this, frankly, as just an array, but it's not just an array with one spot. It looks I can stack multiple numbers or multiple blue books inside of that array. So, we're going to have to come back to that, because this clearly can't be an array. Normally, the array would be filled the moment you put one value in it. But this hashing is the interesting part. The juicy ingredient today is if I take into account as input what it is I'm trying to store, use some piece of that information to decide where to put it, that's an algorithm, because I can repeat that process, so long as it's not random. You go over here, you go over here. That's amazing. Wow, OK, pushing my luck. OK, so I'm not just randomly putting things here. I'm actually giving some thought as to where I'm putting things, and that makes the algorithm deterministic, repeatable, predictable so that if you insert something now, you can absolutely find it if present later. Unfortunately, if our hash table does look like this, just a simple array from bracket 0 to bracket n minus 1 dot, dot, dot in between, and it's just an array for integers or an array for strings or whatever, once you put something here, or here, or here, that's it. There is no more room to put another element there wide as I might have drawn this table. If there's an int there, that's it. So, what could you do? Suppose that you do have an array structure like this, and that is unacceptable. You have a whole bunch of elements here and this table looks like this, and you consider this table like this. And maybe it's just where you're supposed to take attendance or put people's names. So, if you say, oh, Alice is here today. Let me go ahead and hash on Alice's name and put her where the As should go. Oh, Zoe is here, Z-O-E, so we'll put her down there. And then who else? Alex is here. Dammit, Alex, no room for you in our hash table, because Alice is already there. This is stupid. If we have data we want to insert into this data structure, it would seem that I have 24 available spots into which I could put Alex and yet I'm just stubbornly trying to put him where only the As belong. So, why don't I, in this kind of scenario, I need to put Alex in here. I clearly have space. Let me just probe the array looking for the first available spot. OK, Alex, you're just going to go here, and if someone else like Erin appears, You just are going to go over here. So, you try to put the letter As where you want them to go, but if there's already someone there, just probe deeper into the data structure looking for the first available slot. So, this is a general technique in programming called linear probing whereby you have a data structure. If you hash to some location like the letter A there's a collision, something is there, you probe further in the data structure just looking for some place you can put it. So, you get close to constant time decision-making. Put A here, put Z here. And because this is an array, you have random access with your square bracket notation, but if you have lots of As and not too many Zs, or Bs, or Ds, it's possible this approach could devolve back into linear time. So, in the ideal we have one A, one B, one Z, and everything in between, that's constant time. We have our holy grail, constant time operations for a data structure, but not if we want to support insertion of other elements, even those that hash to the same location. So, what's the fix? Well, if the problem is that we've already made room-- we already have used this space for Alice, you know what? If we need to put someone else here, why don't we just create dynamically some more space? We have malloc now. We have dynamic memory allocation. Why don't we just extend our data structure laterally, horizontally-- artistically here-- so that, yes, you try to go to that first location. But if there's multiple people that are meant to go there, multiple values, go ahead and just link them together, thereby merging the idea of a hash table and a linked list with a data structure that might look like this. So, this is an example, somewhat arbitrary, of 31 days out of a month. And if you actually hash on people's birth dates, as I think this author did, you can think of your hash table still as an array. But that array does not store strings, it does not store integers. It only stores pointers, 31 total in this case-- some of which might be null, per the vertical diagonal slash-- but those pointers in turn point to the beginning of linked lists. So, if multiple people were born on the fourth of some month, you would put J. Adams and W. Floyd in a linked list at that location. If both Aaron, and Alex, and Alice, and other students with the names A all belong at that first location in my previous table, that's fine. Just string them together with a linked list. Much like with these buckets, at the end of the day, I'm still creating piles. And at the end of the day, I still have to go through them all, ultimately. But each of these piles is 1/26 the size of it would have been if everyone just came up at the end of the exam and just piled all their books in the same pile. So, whereas, these algorithms are still devolving, if you will-- or these data structures are devolving, if you will, into linear time operations, in the worst case if these things just get really long and stringy, at least in actuality they might be as good as 1/31 as long or 1/26 as tall. And so, now there's this dichotomy in this week five of asymptotic running time, the theoretical running time that we've really been belaboring and the actual running time. Just because something is n squared does not mean it's bad. If there's only a few elements, n squared is great. It's going to happen super fast if your computer is 1 gigahertz, or 2 gigahertz, or faster these days. N squared in and of itself isn't bad. It just gets really bad when your data gets large. But in practice, even n squared divided by 2 is actually better than n squared. So, a couple weeks ago when I was saying don't worry about the lower order terms, the constant terms, focus only on n squared and not n or anything you're dividing by, that's fine theoretically, but in actuality you're going to feel that kind of difference. So, here's one last data structure that we'll call a trie-- so trie, short for retrieval somehow, T-R-I-E, but pronounced try. And this one is cool because this now is really like a weird offspring of these data structures from today. But it's a tree each of whose nodes is in an array. And a trie is really good for storing words like words in a dictionary. Indeed, one of the problem I had for you in CS50 is going to be to implement a spell checker, which effectively means build a dictionary in memory, and you'll be challenged to spell check words as fast as you can, storing as many as 100,000 English words somehow in your computer's memory and answering questions of the form is this a word, is this a word, is this a word. That's, after all, what spell checking is. So, a trie is kind of interesting in that-- and this is an excerpt of an, artist's rendition there of-- the root node here represents this-- is this rectangle here, and that of course looks like an array. And notice what's implicit in this. If this is location A and this is location Z, the author here has just decided to only show you those letters that matter But the fact that the M location here is not blank means there's a pointer there. Indeed, what are these arrays? They are arrays of pointers to other nodes. So, the fact that M is not null and it leads to this node, and notice that A and then this node, and then this node. And this is where the artist is just taking some liberties. This tree would be monstrously wide, because all of these arrays are so darn wide, so he or she is just showing you the width-- or the element that we care about, M, A, X, W, E, L, L, and then some special sentinel symbol delta, but it could be anything. This is null, really. This is how using a trie a programmer could store the name Maxwell, M-A-X-W-E-L-L, by simply leaving little bread crumbs, if you will, from one node to another such that each of those elements in the array is a pointer to another array. And if you keep following these pointers, following the bread crumbs and you eventually find yourself at this special sentinel value-- and actually, it wouldn't be null, it would be like a Boolean saying true. This is a word you can just by storing a single yes or no at this location way down here, implicitly reveal that M-A-X-W-E-L was in fact a word. Let's follow another. So, let's say Turing, T-U-R-I-N-G, check, Boolean true. Turing is in this dictionary as well. So, if there are bread crumbs that lead to null, that word is not in here. So, apparently there is no names starting with A through L, and there is no one after U through Z or some of the letters in between, because those pointers are implicitly and pictorially null. But let's consider, then, what is the running time of inserting or looking up a name and [? in a trie? ?] Thus far, pretty much all of the data structures we've talked about have pretty slow running times, linear in the worst case. So, if we used an array to store people's names or we used to linked list to store people's names, in the worst case we had linear running time, unless maybe we sort things, but even then that costs us some time. So, linear may be logarithmic was the best we could do. And even with a hash table, whereby, maybe we store Maxwell at the M location in our table, he might still have a link list of a whole bunch of other M people. That, again, can devolve into something linear, a linear linked list. But what about a hash table? To answer the question is Maxwell in a trie-- sorry, what about to trie? Maxwell in a trie, what do we do? We start at the root and we follow the pointer that represents m, and then we follow the pointer there that represents A, then X, W, E, L, L, and we look for at the end of that series of steps a true false value. And if it's true, yes, Maxwell is here. What about Turing? Well, we start at the T, then U, R, I, N G, then check. Oh, true. Turing is in there. Let's look for David. No, false. There's not even a pointer there. David is not in this dictionary. So, how many steps did that each take? To tell whether Maxwell was in the dictionary, was M-A-X-W-E-L-L and then look at the Boolean, so that was eight steps. And to look up Turing was T-U-R-I-N-G. And then that Boolean, that was seven steps. Those numbers have nothing to do with how many words are already in the trie. There might be-- and there's only a couple dozen here-- there are a dozen or so here-- there might be thousands of actual words in this dictionary, but we're still going to find Alan Turing by way of T-U-R-I-N-G Boolean seven steps, and M-A-X-W-E-L-L Boolean, eight steps. It doesn't matter how many other data elements are in this trie. powerful, because if there is an upper bound on the number of letters in an English word-- which is kind of true. I've rarely typed words that are longer than I don't know 10 characters, 15 characters. At some point there might exist these words, but no one actually says or types these words. Those are effectively constants. The maximum length of a word in English is surely some constant, because there is one word that's the longest. That's a constant value, which means inserting a name, or searching for a name, or removing a name from a trie does depend on the length of the name, but it does not depend on how many pieces of data are already in the data structure. And as such, it is constant time. So, now in C, we have a whole bunch of new syntax with which to represent data structures, namely actual structs in C, and we have pointers, and we have malloc with which we can build more interesting shapes, if you will, in memory. And we now have a number of abstract data types and actual data structures we can build using these ingredients with which we can now solve problems that are going to demand all the more resources, all the more time, all the more space, in which case efficiency and good design is going to be ever more important. All this and more next time. AUDIENCE: She thought she was doing the right thing. -Tell me more. -David was sure it had to be the muppet, something called muppet mode, but the pressure was too much. -This is Mario in muppet mode. Take 23. [HONKING] -What's happening? I thought this is what you always wanted, to star in the walkthrough videos, to have all of YouTube's eyes watching you. -Yes, you are. You have to be. Now stand up straight, tuck in your shirt, look into the camera! Take it again from the top. 

===[=]===


wU6udHRIkcc.en.vtt   the topic is disjoint sets in this video I will cover the following things first is what are disjoint sets and operations on them then detecting a cycle see disjoint sets are useful for detecting a cycle in non directed graph or undirected graph so we will take an example and learn how to detect a cycle in a non directed graph then graphically how to represent these disjoint sets and how it can be represented using array and the lastly the time efficient operations on disjoint sets are weighted Union and collapsing find that are based on the ranks or weights we will see that disjoint sets are similar to sets topic and mathematics but not exactly they are little bit change for making them useful in algorithms so the famous algorithm that uses disjoint set is kruskal's algorithm which detects a cycle in a graph so let us see how these disjoint sets are different from normal sets of mathematics let us understand what are disjoint sets seeing here I have a non connected and non directed graph there are two components it's not connected graph two components I have taken and each component I have represented it as a set said s1 is having one two three four these are the vertices of this component and set it to is having five six seven eight these are the vertices of second component so the two different components are representing two different sets and what is a disjoint here so know what X is a common here the numbers are not a common here so if you take intersection of these two s1 and s2 then you will not get anything five empty set so that is disjoint disjoint set means two sets are not having anything common then how we use them what are the operations on them see we prefer performing only two operations that are fine and Union I'll show what does it mean by these operations so first operation find I want to know what x5 belongs to which said it's not here yeah it's here so it belongs to set to find operation is to find out any element or a vertex belonging to which set it's like a set membership operation also means that element is member of which is set so like I want to find out 7 7 doesn't belong here ok here it belongs so it belongs to set 2 then 3 find three five three welders here so it is set 1 so that's it find operation is very simple so you have to find out in which set it belongs to so I am showing you just mathematically later we will come to the data structure now let us look at Union operation see for showing Union operation I'll try to connect these two with an edge I have added this edge this edge that is 4 to 8 so when you add an edge then what we do here is we perform Union operation so we connected what 4 comma 8 we have connected now find for 4 yeah it belongs to set 1 5 8 8 AHA here it belongs so it isn't set to so find 4 and find 8 they belong to two different sets so perform Union s 1 Union s 2 so now we get a set that is 1 2 3 4 5 6 7 8 this is Union operation see in mathematics simply we perform Union on two sets but here there is a reason of performing Union what is the reason if there is an edge u comma V find out to you it is to which set it belongs and find out V to which a set it belongs and if they belong to different sets then perform union of those two sets this is the purpose of performing Union know why we are doing this next I'll add one more edge one two five so this is one two five now we don't have these sets that are Union and we got a new set let us call this as set three so we have a new Center those elements are gone this is the final set one comma five one yes find one it's present here find five yes it is present here now both these vertices or numbers are belonging to same set and if they belong to same set means there is a second that's it this is the way we find out a cycle in a graph so one of the things we learn what is fine operation what is Union operation and what is the purpose of Union operation then how we can know that there is a cycle in the graph if you take any edge and both the vertices are belonging to same set then there is a cycle in the graph so this was a very simple example I have shown you what does it mean by fine and Union now we will take one example graph and we will see from the beginning how we can detect a cycle in a graph I will form all the sets right from the beginning I will add all there just one by one let us take an example and find out how we can find our cycle how we can detect a cycle in a graph by with the help of disjoint sets here I have taken one example graph and in this I have labeled the vertices so let us say these are some weights so just like let us find our minimum cost spanning tree from this one otherwise you can also say that I have numbered them so first at should that I will be taking is this one then this one second one then third and four in this way I will include all the edges of a graph now how we can take the help of disjoint sets for finding finding a cycle let us check see there are eight vertices I have taken a Universal set with a two vertices each element you considered it as a set now let us start what we'll be doing is we'll be going on taking edges including edges and forming the set so for them one by one so the first edge is 1 comma 2 so the first edge is 1 comma 2 so find one 1 is here and find it - it is here so actually they are in the universal set so former set for them take 1 &amp; 2 so perform Union on 1 &amp; 2 so from this Universal set they are removed and they are brought in to set 1 s 1 now next edge next edge is 3 comma 4 so 3 comma 4 3 is an Universal set remove this find for this is in this Universal set remove it so former set that is set it to with the 3 &amp; 4 then third edge 5 6 so this is 5 comma 6 and they belong to Universal set remove them from there and form a set for them 5 6 the next one is 4th at just seven eight so take 7 &amp; 8 &amp; find 7 it is here find 8 it is here they are a universal set former set for them that is 7 &amp; 8 now the mix edge after the 4th edge this is the 5th edge I am going to take that is 2 comma 4 now I can see that all these vertices are removed numbers are removed they are in different sets now now find the two words not they just forget this one find it - it is here find 4 it is here so they are in two different sets of perform Union so I will form a new set that is set 5 by taking union of these two one two three four I have performed Union on these two sets so now you can see that Union is being performed let us go to our next edge after 2 comma 4 this one 2 comma 4 sixth one is this one that is 2 comma 5 so 2 comma 5 find 2 so 2 is in this set now these are Union remove them this is in set 5 &amp; 5 is in set 3 / some union of these two and foremost six so what are those vertices 1 2 3 4 and peas 2 5 6 see the reason of performing Unionists we are including an edge considering an edge so this set is also gone we have a union that's also gone now we have only 2 sets now right now after this edge vii edges this one 1 comma 3 1 comma 3 I'll remove these sets and I'll just write two sets here find one it belongs to set 6 5 3 it belongs to same set so when the both belong to same set it means there is a cycle yes you can see that by taking this edge I'll be forming cycle I will highlight the edges that I have included so far see I have included these edges I having you did these I have included these edges all right now if I include this edge this will form a cycle so don't include this that's all the edge which is forming a cycle don't include it we have detected 1 cycle let us continue after that 7th edge the next edge 8 1 is this one so 8 is what 6 &amp; 8 6 &amp; 8 let us see find six five six six belongs here find eight eight belongs to this one so they are in different sets perform Union now we will get 7 the set and what is that 1 2 3 4 5 6 from this set and 7 8 from this set 7 &amp; 8 from this set so these two are gone so this is also included now the last edge remaining is 9th one 5 comma 7 5 comma 7 5 5 it is in this set find 7 this also in the set both all are in same set only now as they both belong to same set there is a cycle so this is how crucial algorithm also uses it in the same way for finding a spanning tree like you may be knowing that in crystals algorithm always we select a minimum cos H now shall we select it or not is it forming a cycle or not how we can know by checking in to the sets so this was like working off a criticals algorithm only now how it is done graphically and how it is represented using array that we have to see so I take the same graph and show you let us quickly look at how we can show the sets graphically so I will do the same thing I have the same graph and the vertices these instead of Universal set I have shown them as vertices here that is I have taken notes now I will go on including the edges so the first edge is 1 comma 2 if I include edge 1 comma 2 you remember I was making a set as 1 2 now actually we don't need a set we are not performing mathematical operations here like intersection Union difference come we are not performing that one so what we want is just you want to detect a cycle so we want to do it in the easy way so instead of showing it like this graphically we will take 1 &amp; 2 basically we don't need the name of a set we need just one representative of a set so we will make what X 1 as a parent of set &amp; 2 as a child if you like you can make 2 as a parent and one as a child also so let me show you other edges that is 3 comma 4 so if I take 3 comma 4 and make a set 3 4 so 3 as a parent and 4 as a child of it now third set that is 5 6 5 then set for 7 comma 8 I have included 4 I got 4 set graphically they are shown like this now let me include the next one from here you can get the clear picture edge 2 comma 4 v 1 2 comma 4 so where is 2 2 is here who is the parent of 2 1 the next is 4 find 4 4 is here who is a parent of four three so these are at two different sets so you remember we perform Union how to perform Union so we will select one as a and two as a child here and it's a child as a three and four so we made the parent of one said as a child of the period of another set so you will be asking that why did you select a three ever parent if you want you select that one also it makes no difference it makes no difference whether you take three as a parent and one you make it as a child of three it makes no difference then next one after fifth sixth one as a 2 comma 5 2 is here who is a parent of this one 1 then 5 is here so they are in two different sets these are in two different sets so we interviewed that five we will bring it here and six here actually these are gone I will remove them now again one more thing here also you can ask a question why did you select five as a parent see here I have a strong answer that before including this see how many nodes are there 4 gnomz are there so weight of this set is more and this way it is less so we will make this as a parent and this as child earlier although both the sets were having the same number of elements but now this is set to 1 2 3 4 is having more number of elements 5 6 is having just two elements so this is representing this set you see 1 2 3 4 5 6 this is v 6 2 set if you remember already we have done this now this is gone now on extras 7th 1 1 comma 3 1 comma 3 1 is the parent itself and three is parent is 1 so both of their parent is 1 only it is 1 only so they belong to set of 1 so both belong to same set so it's a cycle that's enough I will not go further so this is how we detect whether there is a cycle or not graphically I have shown you now let us see the same thing again with the help of an array how it is done using now I'll show you the graphical representation as well as irony presentation c4 representing a set we don't need the name of a sector we are not performing actual Union intersection or set difference operations of mathematics we just want to perform find and union our objective is to detect a cycle so for that for all eight vertices we will take a single array called parent and the indices are representing these eight vertices and each is having value minus 1 means each vertex is in its own center next to show you graphically how it looks like I have even taken these eight nodes now let us perform the same thing on this graph and see how we will represent sets in a array and also I will show it graphically so fast edge 1 comma 2 1 comma 2 1 who is a parent of 1 minus 1 itself to find to go to index 2 and see what is there minus 1 so who is a parent of 2 itself so how much time it has taken for finding 1 and finding to find 1 minus 1 find 2 is minus 1 so constant a time so they belong to two different sets the perform Union how do you perform Union so graphically I will show I will select one as a parent and two as a child so 2 is a child of 1 so here we will write 1 so who is a period of 2 now 1 and what is 1 minus 1 so there is a parent so if there is minus 1 or negative value that is a parent now I'll do one more thing total how many nodes are there two years are there so instead of writing just minus 1 I'll write negative only so minus 2 so there are 2 - shows that it's a parent and 2 shows that there are 2 modes here that's it let us continue repeat the same thing for all of them next edges 3 comma 4 3 comma 4 find 3 one itself is apparent 4-1 itself is a parent so former said so who is a parent of four three and what is the three its parent but there are two nodes in this one five comma six the third one so find 5 this is minus 1 5 6 minus 1 so 5 here and 6 here so this is a 5 and this is minus 2 now the next edge is this one 7 comma 8 find 7 itself as a parent find 8 itself is a parent now make 8 as a child of this 7 or 7 as a parent so this is 7 and this is 2 till here we have finished next shift H 2 comma 4 so 2 comma 4 find the 2 1 is a parent find 4 3 is a parent let us do it in an array to go to two one go - 1 - so who is a parent of this 1 1 find so go to four three go - 3 - 2 so who is the parent of this 1 3 and this was 1 they are different parent perform Union so whom we should select as a parent 1 we will select it as spirit so at a 3 I will write 1 then total how many nodes now 4 nodes so graphically 3 will come as a child of 1 and here is 4 that's it so that's all Union is done now let us take next 1/5 now this is 6th 2 comma 5 2 &amp; 5 let us see who is a parent of 2 1 let us look at here - its 1 go to 1 its - for just one step we are going right it's not n at time we considered as constant time only five and five five go to 5 - 2 itself as a parent so for 2 this is a parent and 4/5 itself is a parent now who should become the parent for both we have to perform Union now unite these two so who should be compared in 1 or 5 see what is the right one - for what is there at 5 - 2 whose weight is greater ronk is greater weight or rank both are same only here we call it as rank also whose rank this created once rank is greater so let five come as a child of one so at five we write one now - the rules are added to this so 4 and that - 2 is added so it becomes sorry till your notes are added to it that 4 and minus 2 it becomes 6 so total 6 nodes are here this is how Union is performed let us go to next one after 677 this what 7 this 1 comma 3 this will be interesting find 1 1 okay here in this one itself is a parent find 3 3 who is a parent 1 okay here in an array 3 1 go to 1 minus 1 so the parent is same so for both 1 &amp; 3 parent is same both our parent are same so it means they belong to same set and exacycle if you include 1 comma 3 it will form a cycle see so far we included these edges right we have included these edges and if we include 1 comma 3 this one so that's how inclusion of any edge will it form a cycle or not we can know it with the help of this disjoint sets I can continue like this okay let me quickly finish the rest of them also but here 5 comma 6 is gone it is coming under this one now let us take next edge 6 comma 8 6 comma 8 find 6 6 / and is 5 5 / and is 1 so go here in the on array let us see here also 6 / n is 5 &amp; 5 spirit is and once parent there's one itself is the parent so one is the parent of six now or about eight find eight in this graph you can see this is graphically it is seven so go to eight and seven go to seven X minus two so this is the parent so perform Union on 1 on 7:00 now who is greater minus eight is greater this is minus two so make this seventh parent as one and add two more nodes here and graphically show it like this seven and eight that's it now the last one is ninth one this is included no 91 if I try to include five and seven find five pair in this one find seven pair in this one look at here five one only seven one only so for both of them period this one so inclusion of nine will form a cycle so this is how a simple array of values are sufficient for finding whether there is a cycle or not with the help of fine and union operation that's already what just one thing is remaining here see I instead of taking just minus one I was taking a ranks or weight and the Union was performed based on whoever weight is higher right so this is weighted Union now one more term is used that is collapsing fine so let me tell you one thing here see if I say find to go to two one one is negative just two steps find three go to three one at 1 minus eight so one is a parent just two steps constant steps find four go to four go to four it will take you to three go to three it will take you to one then here so the time is more time is more so here for some nodes the time may be more you have to go along the parent and pair and ampere and then finally you will get the root or the main parent of a set so what we do in this situation is when we find that period of six is five and then it parent is one so finally parent of sixes one so for this we have to take multiple steps but once we found out that the parent of sixes one we don't have to keep it there only we can directly bring six under one so here also in six five is the parent five spur in this one so four six also it is one so we can directly modify this one now whenever we say Phi in the six go to index six what is fine there one so at one it is negative so parent of six is one directly in constant time we can know parent of any element so this procedure of directly linking a node to the direct parent of a set is called as collapsing fine but collapsing find we can reduce the time for finding the same value next time first time you may omit spending some extra time but next time in constant time we can get the parent now same way suppose I find 8 from 8 go to 7 from 7 go to 1 let us do it here go to 8 7 7 this one go to 1 experience so once you know that 8 is under 1 so directly bring it under 1 so here also we can write 1 so whenever you find any element you can collapse it to its direct parent so that's all how we can use array for representing disjoint sets and even link lists can be used for so for link list we can explore it I have shown about array in detail everything I have shown you when we use linguists then we have to take nodes and in the node we have to write down these index and stuff index we have to keep it as a value that is the node value and a pointer to the parent pointer to the next node so you can explore that by yourself that's all with a disjoint sets 

===[=]===


qH6yxkw0u78.en.vtt   hello everyone in this lesson we'll introduce you to an interesting data structure that has got its application in a wide number of scenarios in computer science and this data structure is tree so far in this series we have talked about what we can call linear data structures array linked lists stack and queue all of these are linear data structures all of these are basically collections of different kinds in which data is arranged in a sequential manner in all these structures that I'm showing here we have a logical start and a logical end and then an element in any of these collections can have one next element and a previous element so all in all we have linear or sequential arrangement now as we understand these data structures are ways to store and organize data in computers for different kinds of data we use different kinds of data structure our choice of data structure depends upon a number of factors first of all it's about what needs to be stored a certain data structure can be best fit for a particular kind of data then we may care for the cost of operations quite often we want to minimize the cost of most frequently performed operations for example let's say we have a simple list and we are searching for an element in the list most of the time then we may want to store the list or collection as an array in sorted order so we can perform something like binary search really fast another factor can be memory consumption sometimes we may want to minimize the memory usage and finally we may also choose a data structure for ease of implementation although this may not be the best strategy tree is one data structure that's quite often used to represent hierarchical data for example let's say we want to show employees in an organization and their positions in organizational hierarchy then we can show it something like this let's say this is organizational hierarchy of some company in this company John is CEO and John has two direct reports Steve and Rama then Steve has three direct reports Steve is manager of Lee Bob and la they may be having some designation Rama also has two direct reports then bob has two direct reports and then tom has one direct report this particular logical structure that I have drawn here is a tree well you have to look at look at this structure upside down and then it will resemble a real tree the root here is at top and we are branching out in downward direction logical representation of tree data structure is always like this root at top and okay so tree is an efficient way of storing and organizing data that is naturally hierarchical but this is not the only application of tree in computer science we will talk about other applications and some of the implementation details like how we can create such a logical structure in computer's memory later first I want to define tree as a logical model tree data structure can be defined as a collection of entities called nodes linked together to simulate a hierarchy tree is a nonlinear data structure it's a hierarchical structure the topmost node in the tree is called root of the tree each node will contain some data and this can be data of any type in the tree that I am showing in right here data is name of employee and designation so we can have an object with two string fields one to store name and another to store designation okay so each node will contain some data and may contain link or reference to some other nodes that can be called it's children now I am introducing you to some vocabulary that we use for tree data structure what I'm going to do here is I'm going to number these nodes in the left trace so I can refer to these nodes using these numbers I'm numbering these nodes only for my convenience it's not to show any order okay coming back as I had said each node will have some data we can fill in some data in these circles it can be data of any type it can be an integer or a character or a string or we can simply assume that there is some data filled inside these nodes and we are not showing it okay as we were discussing a node may have link or reference to some other nodes that will be called its children each arrow in this structure here is a link okay now as you can see the root node which is numbered one by me and once again this number is not indicative of any order I could have called the root node node number ten also so root node has linked to these two nodes number two and three so two and three will be called children of one and node one will be called parent of nodes 2 &amp; 3 I'll write down all these terms that I am talking about we mentioned root children and parent industry one is a parent of one is parent of two and three two is child of one and now four five and six are children off to so no 2 is child off node one but parent off nodes four five and six children of same parent are called sibling I'm showing siblings in same color here two and three are siblings then four five and six are sibling then seven eight are sibling and finally nine and 10 are sibling I hope you are clear with these terms now the root would be the only node without a parent and then if a node has a direct link to some other node then we have a parent-child relationship between the nodes any node in the tree that does not have a child is called leaf node all these nodes mugged in black here are reliefs so leaf is one more term all other nodes with at least one child can be called internal nodes and we can have some more relationships like parent of parent can be called grandparent so one is grandparent of four and four is grandchild of one in general if we can grow go from node a to be walking through the links and remember these links are not bi-directional we have a link from 1 to 2 so we can go from 1 to 2 but we cannot go from 2 to 1 when we are walking the tree we can walk in only one direction ok so if we can go from node a to node B then a can be called ancestor of B and B can be called descendant of a let's pick up this node number 10 1 2 and 5 are all ancestors of 10 and 10 is a descendant of all of these nodes we can walk from any of these nodes to 10 okay let me now ask you some questions to make sure you understand things what are the common ancestors of 4 and 9 ancestors of 4 are one and two and ancestors of 9 are 1 2 and 5 so common ancestors will be 1 and 2 ok next question are 6 and 7 sibling sibling must have same parent 6 and 7 do not have same parent they have same grandparent one is grandparent of both nodes not having same parent but having same grandparent can be called cousins so 6 and 7 are cousins and these relationships are really interesting we can also say that node number 3 is uncle of node number 6 because because it's sibling of 2 which is father of 6 or I should say parent of 6 so we have quite some terms in vocabulary of tree ok now I will talk about some properties of tree tree can be called a recursive data structure we can define tree recursively as a structure that consists of a distinguished node called root and some sub trees and the arrangement is such that root of the tree contains link to roots of all the sub trees T 1 T 2 and T 3 in this figure are sub trees in the tree that I have drawn in left here we have two sub trees for our root node I am showing the root node in red the left subtree in brown and the right subtree in yellow we can further split the left subtree and look at it like node number two is root of this subtree and this particular tree with node number two as root has three sub trees I am showing the three sub trees in three different colors recursion basically is reducing something in a self-similar manner this recursive property of tree will be used everywhere in all implementation and users of tree the next property that I want to talk about is in a tree with n nodes there will be exactly n minus 1 links or edges each arrow in this figure can be called a link or an edge all nodes except the root node will have exactly one incoming edge if you can see I'll pick this node number two there is only one incoming link this is incoming link and these three are outgoing links there will be one link for each parent-child relationship so in a valid tree if there are n nodes there will be exactly n minus 1 edges one incoming edge for each node except the root okay now I want to talk about these two properties called depth and height depth of some node X in a tree can be defined as length of the path from root to node X each edge in the path will contribute 1 unit to the length so we can also say number of edges in path from root to X the depth of root node will be 0 let's pick some other node for this node number at 5 we have 2 edges in the path from root so the depth of this node is 2 in this tree here depth of nodes 2 &amp; 3 is 1 depth of nodes 4 5 6 7 &amp; 8 is 2 and the depth of nodes 9 10 and 11 is 3 ok now height of a node in tree can be defined as number of edges in longest path from that node to a leaf node so height of some node X will be equal to number of edges in longest path from X to a leaf in this figure for node 3 the longest path from this node to any leaf is 2 so height of node 3 is 2 node 8 is also a leaf node I'll mark all the leaf nodes here a leaf node is a node with 0 child the longest path from node 3 to any of the leaf nodes is 2 so the height of node 3 is 2 height of leaf nodes will be 0 so what will be the height of root node in this tree we can reach all the Leafs from root node number of edges in longest path is 3 so height of the root node here is 3 we also define height of a tree height of tree is defined as height of root node height of this tree that I'm showing here is tree height and depth are different properties and height and depth of a node may or may not be same we often confuse between the two based on properties trees are classified into various categories there are different kinds of trees that are used in different scenarios simplest and most common kind of tree is a tree with this property that any node can have at most two children in this figure note 2 has 3 children I'm getting rid of some nodes and now this is a binary tree binary trees most famous and throughout this series we will mostly be talking about binary trees the most common way of implementing tree is dynamically created nodes linked using pointers or references just the way we do for linked lists we can look at the tree like this in this structure that I have drawn in right here node has three fields one of the fields is to store data let's say middle cell is to store data the left cell is to store the address of the left child and the right cell is to store address of right because this is a binary tree we cannot have more than two children we can call one of the children left child and another right child programmatically in C or C++ we can define node as a structure like this we have three fields here one to store data let's say data type is integer I have filled in some data in these nodes so in each node we have three fields we have an integer variable to store the data and then we have two pointers to node one to store the address of the left child that will be the root of the left subtree and another to store the address of the we have kept only two pointers because because we can have at most two children in binary tree this particular definition of node can be used only for a binary tree for generic trees that can have any number of children we use some other structure and I will talk about it in later lessons in fact we will discuss implementation in detail in later lessons this is just to give you a brief idea of how things will be like in implementation okay so this is cool we understand what a tree data structure is but in the beginning we had said that storing naturally hierarchical data is not the only application of tree so let's quickly have a look at some of the applications of tree in computer science first application of course is storing naturally hierarchical data for example the file system on your disk drive the file and folder hierarchy is naturally hierarchical data it's stored in the form of tree next application is organizing data organizing collections for quick search insertion and deletion for example binary search tree that we'll be discussing a lot in next couple of lessons can give us order of log n time for searching an element in it or special kind of tree called tri is used is used to store dictionary it's really fast and efficient and is used for dynamic spell checking tree data structure is also used in network routing algorithms and this list goes on we'll talk about different kinds of trees and their applications in later lessons I'll stop here now this is good for an introduction in next couple of lessons we'll talk about binary search tree and its implementation this is it for this lesson thanks for watching 

===[=]===


gXgEDyodOJU.en.vtt   hello everyone so far in this series on data structures we have talked about some of the linear data structures like array linked lists stack and queue in all these structures data is arranged in a linear or sequential manner so we can call them linear data structures and we've also talked about tree which is a nonlinear data structure tree is a hierarchical structure now as we understand data structures are ways to store and organize theta and for different kinds of data we use different kinds of data structures in this lesson we are going to introduce you to another nonlinear data structure and that has got its application in a wide number of scenarios in computer science it is used to model and represent a variety of systems and this data structure is graph when we study data structures we often first study them as mathematical or logical models here also we will first study graph as a mathematical or logical model and we will go into implementation details later okay so let's get started a graph just like a tree is a collection of objects or entities that we call nodes or vertices connected to each other through a set of edges but in a tree connections are bound to be in a certain way in a tree there are rules dictating the connection among the nodes in a tree with n nodes we must have exactly n minus 1 edges one edge for each parent-child relationship as we know an edge in a tree is for a parent-child relationship and all nodes in a tree except the root node would have a parent would have exactly one parent and that's why if there are n nodes there must be exactly n minus 1 edges in a tree all nodes must be reachable from the root and there must be exactly one possible path from root to a node now in a graph there are no nodes a graph contains a set of nodes and a set of edges and edges can be connecting nodes in any possible way tree is only a special kind of craf now craf as a concept has been studied extensively in mathematics if you have taken a course on discrete mathematics then you must be knowing about crafts already in computer science we basically study and implement the same concept of craft from mathematics the study of crafts is often referred to as craft theory in pure mathematical terms we can define graph something like this a graph G is an ordered pair of a set V of vertices and a set of edges now I'm using some mathematical jargon here an ordered pair is just a pair of mathematical objects in which the order of objects in the pair matters this is how we write and represent an ordered pair objects separated by comma put within parenthesis now because the order here matters we can say that V is the first object in the pair and E is the second object an ordered pair a B is not equal to B a unless a and B are equal in our definition of graph here first object in the pair must always be a set of vertices and the second object must be a set of edges that's why we are calling the pair an ordered pair we also have concept of unordered pair and an ordered pair is simply a set of two elements order is not important here we write an unordered pair using curly brackets or braces because the order is not important here an ordered pair a B is equal to B a it doesn't matter which object is first and which object is second okay coming back so a graph is an ordered pair of a set of vertices and a set of edges and G equal V E is a formal mathematical notation that we use to define a graph now I have a craft drawn here in the right this graph has 8 vertices and 10 edges what I want to do is I want to give some names to these vertices because each node in a graph must have some identification it can be a name or it can be an index I'm naming these vertices as V 1 V 2 V 3 V 4 V 5 and so on and this naming is not indicative of any order there is no first second and third node here I could give any name to any node so my set of what is e is here is this we have eight elements in the set v1 v2 v3 v4 v5 v6 v7 and v8 so this is my set of vertices for this graph now what's my set of edges to answer this we first need to know how to represent an edge an edge is uniquely identified by its two endpoints so we can just write the names of the two endpoints of an edge as a pair and it can be a representation for the edge but edges can be of two types we can have a directed edge in which connection is one way or we can have an undirected edge in which connection is two way in this example graph that I'm showing here edges are undirected but if you remember the tree that I had shown earlier then we have directed edges in that tree with this directed edge that I'm showing you here we are saying that there is a link or path from vertex u to V but we cannot assume a path from V to u this connection is one way for a directed edge one of the endpoints would be the origin and the other endpoint would be the destination and we draw the edge with an arrowhead pointing towards the destination for our edge here origin is U and destination is V a directed edge can be represented as an ordered pair first element in the pair can be the origin and second element can be the destination so with this directed edge represented as ordered pair UV we have a path from u to V if we want a path from V to u we need to draw another directed edge here with V as origin and U as destination and this edge can be represented as ordered pair vu the upper one here is UV and the below one is vu and they are not same now if the edge is undirected the connection is two-way an undirected edge can be represented as an unordered pair here because the edge is bi-directional origin and destination are not fixed we only need to know what two endpoints are being connected by the edge so now that we know how to represent edges we can write the set of edges for this example graph here we have an undirected edge between v1 and v2 then we have one between v1 and v3 and then we have v1 v4 this is really simple I'll just go ahead and write all of them so this is my set of edges typically in a graph all edges would either be directed or undirected it's possible for a graph to have both directed and undirected edges but we are not going to study such graphs we are only going to study graphs in which all undirected a graph with all directed edges is called a directed graph or digraph and a graph with all undirected edges is called an undirected graph there is no special name for an undirected graph usually if the graph is directed we explicitly say that it's a directed graph or digraph so these are two types of graph directed graph or digraph in which edges are unidirectional or ordered pairs and undirected graph in which edges are bi-directional or unordered pairs now many real-world systems and problems can be modeled using a graph graphs can be used to represent any collection of objects having some kind of pairwise relationship let's have a look at some of the interesting examples a social network like Facebook can be represented as an undirected graph a user would be a node in the graph and if two users are friends there would be an edge connecting them a real social network would have millions and billions of nodes I can show only few in my diagram here because I am short of space now social network is an undirected graph because friendship is a mutual relationship if I'm your friend you are my friend too so connections have to be two-way now once a system is modeled as a graph a lot of problems can easily be solved by applying standard algorithms in graph theory like here in this social network let's say we want to do something like suggest friends to a user let's say we want to suggest some connections to Rama one possible approach to do so can be suggesting friends of friends who are not connected already Rama has three friends Ella Bob and Katie and friends of these three that are not connected to Rama already can be suggested there is no friend of Allah which is not connected to Rama already Bob however has three friends storm Sam and Lea that are not friends with Rama so they can be suggested and Katie has two friends Lee and Swati that are not connected to Rama we have counted Li already so in all we can suggest these four users to Rama now even though we described this problem in context of a social network this is a standard crafts problem the problem here in pure graph terms is finding all nodes having length of shortest path from a given node equal to two standard algorithms can be applied to solve this problem we will talk about concepts like paths in a graph in some time for now just know that the problem that we just described in context of a social network is a standard craft problem okay so a social network like Facebook is an undirected graph now let's have a look at another example interlinked web pages on the internet or the world wide web can be represented as a directed graph of web page that would have a unique address or URL would be a node in the graph and we can have a directed edge if a page contains link to another page now once again there are billions of pages on the web but I can show only few here the edges in this graph are directed because relationship is not mutual this time if page a has a link to page B then it's not necessary that page B will also have a link to page a let's say one of the pages on my code school comm has a tutorial on craft and on this page I have put a link to Wikipedia article on let's assume that in this example graph that I'm showing you here page B is my my code school tutorial on craft with this address or URL my code school comm / videos / craft and let's say page Q is the Wikipedia article on graph with this URL wikipedia.org / wiki / graph now on my page that is page P I have put a link to Wikipedia page and graph if you are on page P you can click on this link and go to page Q but Wikipedia has not reciprocated to my favor by putting a link back to my page so if you are on page Q you cannot click on a link and come to page P connection here is one way and that's why we have drawn a directed edge here okay now once again if we are able to represent web as a directed graph we can apply standard craft theory algorithms to solve problems and perform tasks one of the tasks that search engines like Google perform very regularly is web crawling search engines use a program called web crawler that systematically browses the worldwide web to collect and store data about web pages search engines can then use this data to provide quick and accurate results against search queries now even though in this context we are using a nice and heavy term like web crawling web crawling is basically Draft traversal or in simpler words act of visiting all nodes in a graph and no prizes for guessing that there are standard algorithms for craft traversal and we'll be studying graph traversal algorithms and later lessons okay now the next thing that I want to talk about is concept of a weighted graph sometimes in a graph all connections cannot be treated as equal some connections can be preferable to others like for example we can represent intercity throwed Network that is the network of highways and freeways between cities as an undirected graph I am assuming that all highways would be bi-directional intra-city road network that is road network within a city would definitely have one-way roads and so intra-city road network must be represented as a directed graph but intercity road network in my opinion can now clearly we cannot treat all connections as equal here roads would be of different lengths and to perform a lot of tasks to solve a lot of problems we need to take lengths of roads into account in such cases we associate some weight or cost with every edge we label the edges with their weights in this case weight can be lengths off the roads so what I'll do here is I'll just label these edges with some values for their lens and let's say these values are in kilometers and now edges in this graph are weighted and this graph can be called a weighted graph let's say in this graph we want to pick the best route from City a to city D have a look at these four possible routes I am showing them in different colors now if I would treat all edges as equal then I would say that the green route through B and C and the red route through E and F are equally good both these paths have three edges and this yellow route through E is the best because we have only two edges in this path but with different weights assigned to the connections I need to add up weights of edges in a path to calculate total cost when I'm taking weight into account shortest route is through B and C connections have different weights and this is really important here in this graph actually we can look at all the graphs as weighted graphs an unweighted graph can basically be seen as a weighted graph in which weight of all the edges is same and typically we assume the weight as one okay so we have represented inter-cities road network as a weighted undirected graph social network was an unweighted undirected graph and World Wide Web was an unweighted directed graph and this one is a weighted undirected graph now this was interesting at work I think network within a city can be modeled as a weighted directed graph because in a city there would be some one-ways intersections in intra-city road network would be nodes and Road segments would be our edges and by the way we can also draw an undirected graph as directed it's just that for each undirected edge we'll have two directed edges we may not be able to redraw our directed graph as undirected but we can always redraw an undirected graph as directed okay I'll stop here now this much is good for an introductory lesson in next lesson we will talk about some more properties of graph this is it for this lesson thanks for watching 

===[=]===


HUJAAOcOHR0.en.vtt   you [Music] good morning friends I'm doctor corenman I'm a faculty at the Department of Geography a memory islamia today we are going to learn a module and the title of module is Jia's data structure vector versus roster in this module the learning objectives are what are the different GL databases what are the sources of different DEA's databases what are different types of GIS database and in the next part we'll be specially talking about the vector data models and raster data models and there are different types of raster data models and there are different types of vector data models so we'll try to understand what are these data models what are the structure of these data models what are different characteristics of these data models what are the different properties of these data models and also what are the advantages what are the disadvantages of these data model because in today's word when we are talking about the GIS and remote sensing everybody is using the satellite data everybody using in GIS software to assess understand the special problems with the physical or natural with us human or man-made or natural so all these problems is to be solved by using different data sets and that is the data set that is coming from different sources and these data sources with the supplied data or any other data in the form of map or in any other format so what we have we try to understand what are these different data what are different types of data as if I example a special data in broad categories and non spatial data so we'll try to see what are these special data and what are these non special data and how we can create the GS database and how we can use these databases for different you know problems so by enlarge in this module we'll try to understand these concept and these data types and these formats and how we can use these data different problems so before going to the edge data structure we should understand what is our data and what is GIS you must have studied jazz in the jazz module this art and science of you know acquiring information storing manipulating assessing analyzing and retrieving at the will and manipulation of the data so it's a computer-based software technology soft rec technology wherein we use different data so one need to understand what are a different data structure that a GIS software can support in that process we are trying to understand raster and vector so before going to raster and vector let us understand what is the data you all know what is the data if I ask you what is the data you will be in a position to answer what is your data let me tell you something more about this yes about a data data is nothing but is numerical values which are there for representing any particular phenomena if I say population distribution if I say population density if I say number of trees in a particular area so once I say 1,000 population 1 lakh publishin 10 lakhs population or if I say population density maybe 150 persons per square kilometer all these are the data so data could be in the three form one could be in the form of number which I was telling you data could also be in the form of say for example text say for example if I say blacks file if I write Black's file in text so that is a data which separates Black's file with a liberal side which separates blacks file with the Reds foil which separates red soil with the net rights while so if you write something if I write 1 million population in a text that is a data now third form of data data could be in a form of symbol if I draw any symbol that could be a detail say for example for electric food we have a symbol for trees we have a symbol for the grasses we were a symbol for a temple we have a symbol so if we draw any symbol on a piece of paper on a map or a tapa sheet what we have we can count it and we or we can see these are the features phenomena which are there on any particular part of surface of the earth so so broadly speaking data are in three form number text or symbol now let us try the information information is little different from the data information is nothing but any any degree of sensitivity that we extract from the data that is information if I say if I say you are a class of say 50 or 100 responds if I say K out of hundred eighty stones are having marks more than 60 percent so therefore what is that I can say information I can extract the information based on the data that sixty percent stones are having marks maybe 80 percent so I can say this class is very good or this class where the percentage of Max is very good that means the stones the quality of stones are very good so that is information so geography information we can say now javac is nothing but is any no surface feature which are there any particular part of surface of that is a javac data and the from that data if we draw the information that becomes a job seek information and when we say system when we put all these data javac data in a jazz environment and if you try to analyze if you try to extract something so that for that we use a particular system we apply a particular model or any logic or method and methodology so now let us see what are different types of data javac data so data can be classified broadly into two classes one class is called the special data and second is called non-official leader the moment I say special later is special data are nothing but a data which is in the form of maps which is on a piece of people so I can say that a special data say for example tapa sheet a conditional map or any any data in a form of say aerial photograph you must have learned photogrammetry in the earlier modules and other modules and the most recent important one is the data in the form of so satellite pictures so satellite data tapa sheet cadastral map or any data which is there on a piece of paper that is in surveyed that isn't plotted that becomes a special data so a special data is of immense use and that is being used in jazz software India's environment to solve to assess to analyze any problem or to give a solution to any problem on any part of surface of the earth these problem could be social economic human or natural so I'll talk about this special data little later in detail now second is a non especially de non especial data is also called as attribute data which is in the form of tables say for example and the best example of the non spatial data is a census data census data which is in form of tables in the form of table which are arranged in two dimension table in x and y x rows and y column so these are the norm is efficient data now in jazz domain what we do is we integrate a special data with a non especial data or we can say is non especial later with the special data in order to draw meaningful representation of any particular part of surface of the say for example if I take a special data say district wise map of a state both up adesh Bihar or or you talk about Kerala Assam that is the official data in the special data we have the census data where we have wherein we have the data on population total publish and mail publish and female publish and literacy child labor working publish on eye culture labor Landis labor and so and so so all these data can be linked with the special data and can we can draw or plot or represent meaningful thematic information of any particular state so let us talk about something more on on another data so if we talk about any data which Java key data which gives you a specific location in terms x and y and said also basically x and y the moment I say javac location of any particular no feature of phenomena in the form of x and y that is a latitude and longitude we all know what is the latitude or longitude suppose if I am standing on in Delhi so Delhi's latitude longitude is somewhat 28 degree latitude some minute and 78 degree longitude and some minute anthem second so if you draw a line of latitude and longitude in a form of cross this particular pinpointed location is you know the information or the location of any particular phenomena or the natural or the man-made so that is the javac' and the third dimension if I I'd said that means the elevation if I talk about I was living examine of Delhi so Delhi is located is situated at an height of about 230 meter above mean sea level something like that so that is the said data so if I move from this place to another place from another place to another thus in the topography is varying is not flat so said value changes if I move right and if I move front so what we have x and y values also get changed therefore the the the location gets change when the location the feature which are there is varying at one location we have one male feature at another location we have another feature so therefore what we can say that data is recorded or is there in in in in terms of extent a spatial extent that we can locate in a form of X Y and theta also now all these in function x and y is it we can get it from the top of sheet we can get it by using GPS we can get it from any mother map which is surveyed maybe 10 years 15 years 20 years before so all these data can be raw excess can be acquired and that can be present in a special form the non especial data which are there that cannot be linked and can be presented in a special form so now let us understand what are different data models so broadly speaking as I said in the introduction that there are two broad data models one is called a raster data and second is called Victor data now let us understand first what is the raster data and what are different types of raster data so raster data is nothing but is a data which is the spatial data efforts understand raster data is a special idea is it not non especially done which could be in the form of Toma sheet which could be in a form of s kinda which can be in form of a map this kind man which can mean a form of a real photograph digitally did for app or analog aerial photograph it could be in a form of satellite data which could be in a form of analog data or digital data since today is age of digital India or digital Drive whole of the whole of the world so we have the supply data which is digital form so what do we have we have a satellite data which is in digital form so that is a all these data what I have named is a raster data now what are the qualities what are the characteristics of raster data raster data are arranged in column and row in our form of cell each cell these cells are square in shape each cell as is unique value its unique value that we call is a pixel values or picture number or DN values or we call it a digital number so each cell has a unique number I'd listen to that no cell there could be another cell I'll show you in the diagram figure 1 and figure 2 and layer 3 that will gives you a very clear understanding of what is a big raster data so raster data is is is a continuous data which are arranged in a column and row I and J column I and row J so these are arranged systematically so raster data are of two types one is called discrete data and second is called continuous data either was given an example that raster data there is discrete data that is a data which is in form of pixels square in shape so each pixel has a unique value each pixel has this unique value so what do you have okay this data is a discrete in that form as I said that one pixel may be having a value of 120 under the next pixel I'd then do it or the right side may be having an end and 30 on the left side of it it may be having 110 so what do we have that D this this way is a discrete data it's a discrete data is arranged in a you know series of rows and columns so this is a discrete data one could be a very fine example of discrete data is safe example wrote it could be polygons it would be a point okay now once I say that continuous data second type of raster data is a continuous data continuous data if I say if I give an example of continuous raster data say if I examine this is a hilly slope so it is continuously the height of this mountain terrain is can yes T is increasing slowly and slowly increasing also Lowell is already decreasing so therefore in that way what we can say is a continuous data where the values is is changing values is is increasing or decreasing it values I mean height information the slope information slope could be in a degree slope criminal person did so these are the two basic classes of raster data continuous data and nostril data now let us understand what are the advantages of raster data and whatever disadvantage arrested raster data before going to metadata raster data as I said is a continuous data is in the form of you know cell the pixel values brightness value you must have learned what is the pixel value or what is the DN value let me tell you a little bit here that the sun's energy which is coming on surface of the earth and that sun's energy is being reflected back to the atmosphere and then back to the sensor which are there in a satellite so from one cell if you were one cell of say for example 15 meter or 5 point 8 meter Indian satellite data P 6 data 5 point 8 meter special is really from that grid 5 point 8 by 5 point 8 meter or 15 meter by 15 meter or astral data of twenty eight point five meter by twenty eight point five meter from that grid what the energy is going back and that is being recorded at a sensor that is a digital number so another advantages of raster data is that if you want to do any analysis in spatial analysis only analysis or any lenses by using via software for that you need to have data in a raster format if the data is in a vector format that can also be used but the raster format data is good for rolling buffering proximity analysis and so on so so what we have if you take any raster data which is at a scale of 1 is to 50,000 which has say for example if we take a grid of 3 millimeter by 3 millimeter that cover an area of about 2.5 hectare so what we have this is another beauty of the raster data raster data once you keep on breaking or if you the grid size becoming small that means if the spatial resolution keep on increasing increasing means if the 5 meter data is there so sizes small resolution is better clarity of the surface feature will be better but the area coverage will be spawn if you have a data of say 30 meter or 36 meter area coverage will be large but the details will be less so what we have if you have a better resolution data a 5 meter or 4 meter or 1 meter the size of the data becomes more so the disadvantage is that it needs large storage space the raster data keep on going the better resolution the size of the storage and the size of the pixel values increases say for example if I take twenty three point five meter data IRS data so if you break into five point eight meter to 500 meter it becomes four times larger storage capacity so it storage and handling of the raster data is is an issue for that you need to have a computer which which has a biggest storage and so and so so the raster data today energy has software there is option that we can convert vector data into raster data and raster data to you into a vector data now let us understand the vector data vector data is a discrete data opposite of the raster data as I said the raster data is a continuous data but here what we have we have vector data is a discrete data we separate up to surface feature X &amp; Y from X &amp; Y means if you have one line parcel that is the excellent passer that belongs to a particular person right side of the line is a Y which belongs to another person or any other lines are procedure so vector data is in the form of representative Philip information the offal phenomena in a form of line point or polygon or point liner polygon if he connect different points and draw those points into no circle it becomes a polygon so one polygon I said that belongs to a particular person one polygon one area is is is belongs to a particular person or one area is grown on one area is growing on a particular curve and another area next to it is grown a particular problem so we can separate tool and surfaces by using a polygon we can also separate tool and surface feature by using the line and the point if you take a point data which represent a particular object particular building a particular building which is where we are having a particular activity in annex building we have run a particular build maybe if you have a point data in the form of electric pole the next pole could be a telephone tower something like that so this way vector data is a discrete data okay vector data is discrete data if we see that the different data structure of vector data broadly speaking there are two types of external data models one is spaghetti model I will be showing in the table in diagrams that will give you bitterness running as figure is figure T model in the figure and the second is topological data model okay so what we have to if we talk about the topological data made on which which connects one with another and we draw say for example our node if we connect one node with another we can get an arc so act node and a polygon node so will be representing I will be I will be showing those you know data models spaghetti and topological data models through diagram that will give you bitterness training now what are the advantages of raster data what a vector data sorry and the disadvantage of and one day the vector data is that if you want to understand a particular area parameter on length or anything for that you need to go to the vector data we have to use the vector data model in a GIS or government if you want to use raster data that will not give you no length parameter an area and so and so on so what we have we just will we do vector operation from gas energy as from raster to vector in order to calculate area all now another advantage is that keep the vector data is easy to understand compared to the raster data because in the raster data you have different pixel if you take I'll show you in the diagram that one pixel is having value of 79 other is having of 80 ml is having of 99 so 99 8070 represents a particular object particular phenomena so we kind of miss time but it is difficult to understand what feature is that there could be a mix with yeah but in the vector data we completely separate it out we you know carve out a particular feature particular phenomena from one to another so therefore it is easy easy to understand and it's better to understand for a common person or or any other person but the disadvantage of raster data is a vector data sorry is that in a vector data is complex in a in a sense that there are different no boundaries lines that are being overlaid or one another so if we draw a polygon or that again there is another polygon there is another polygon so there are different lines this intersective overlaid or one another so in that way it you get confused because on one part of surface other we have particular soil we have to particularly inform we have 42 slope we have particular buildings where particular no human phenomena cultural phenomena so if you want to map all these so of all these you know that the boundaries get all act so it in that way it is of it complex to understand but otherwise for area analysis for length and all it is easy to understand so these are the some of the advantages disadvantages of Victor Aditya model in a figure 6 or 7 I'll be showing you key what are a different how the raster data looks like and how the vector data look like and how the real word looked like so I will show you that will give you better understanding how we can represent you know the earth surface feature real ourselves the feature in the form of raster in a form of vector now if you see Figure 1 which clearly shows a raster data structure wherein what we have what you see in this diagram that these are the grid different different needs if you see these grids are varying you know color and gray shades and if we see on the top of it there are different wrong values it may be 84 90 82 hours talking before so all these are discrete you know discrete values these values are the numbers digital number okay so this clearly shows that the data is in a form of grid which is discrete but is a continuous data is in form of cell okay so each one cell asset one set of cell is is is called a layer no each cell is independent address with its value that is what I was saying 80 81 or 1920 what all so each cell may be having certain values at listen to it may be having certain other value and I was telling you before that a minimum mapping unit ID vanish 250 thousand which if you take one cell which is a size of 3 millimeter by 3 millimeter that that has an area of about 2.5 Ector so if we take couple of row cells you can get in you know how much area is there so these are the very fine example of raster data sets figure 2 shows vector data wherein I have talked that vector data could be no formal point it could be a form of line it could form of area now if you see the point 1 is a different point is a no dot dot point it is a cross point it is a triangle point it could be a no circular a hollow point so all these point you can represent data in it you know by using any of these pictures that is in a formal point that is vector data what I was telling you before is that if you see the no dark one may be representing a particular feature in a hollow circle triangle may be representing particular feature therefore in this way what we can say that these are the discrete data and which is a vector data now if you see the third second there are three no representation of nine one is is exact line second is broken line is exact and the third is straight line so this may be a river which is you know moving is exact this could be a root broken neck this could be another road which is going straight metal-on-metal road so this separates one with another now the turn is area if you see this figure 2 area there once polygon on the second we have the one polygon within one polygon there are two other polygons so that means each polygon is representing a particular phenomenon of the feature and the third is shaded volume this is a presenting another feature so therefore if you see within the polygon is something else beyond that polygon there is something else in that way it's a discrete data it separates one feature with a another now if you see figure three as I was telling you that there are different types of vector data one is called a spaghetti data model in a spaghetti data model each feature this is point line polygon is presented as a string of x and y coordinate group with no inherent structure in a spaghetti repetative model so what we have if you see the figure 3 which is spaghetti model on x-axis you see one two three four on YEC then there are three polygons one is called one is a B and C now if you see a 1 C a1 how can we identify so for that you have different nodes so say 1 2 3 4 5 then another line that is called that is a node 6 7 8 9 no 10 11 so by using these nodes and all we can you know you can separate one with another the polygon that guide is into each other may be made up of its own kind of a spaghetti so due to this some redundancy within a data model is created and result a visionary is reduced now the second data model that I was talking about in the vector is the topological data model as I said that it is it is nothing but is a characterized by inclusion of topographic information within the dataset topography is set of rule that model the relationship between neighboring points line and polygons and determines how they share the geometry for example figure 4 shows act node topology if you see this one left side this I ignore top already if you see here on the right side our node list on one column here arc a then from node and to node from where to where our extend so if we see a this is a here a extend C 16 and 17 so what we have a extend from 16 to 17 now obviously similarly B in the second column that is node from to node 2 that is 14 to 17 so our B you see here vertical line are we extend from 14 to 17 similarly you can come down say if I examine arc e E is here so what we have are key it is start from 18 point 18 to our node it is a point or node same 2:21 so 18 to 21 similarly if you say our h the last ArcheAge which start from 21 21 here and the bottom and is it end at 22 so this way we can say this is a topological model topology is also concerned with preserving you know special properties of any particular human initial phenomena another example of you know a topology model which is under the vector data model weight vector data structure is arc polygon topology if you see if you five arc polygon topology there - no diagram one is on the left side on the left side what we have the these are different polygons from we have polygon say in the center D in the top left we have this polygon B we have on the right side not not East way polygon C and the bottom is F and left side is e now let us understand what is our polygon topology through this diagram what we have we say be polygon by polygon be what are the arc units and the arc unit is 1 3 &amp; 5 one is on top three is on the right side and five is in water so our polygon which is named as a room B is made from you know at least of 1 &amp; 3 &amp; 5 similarly if you see see at polygon what it comprises it is made of unit number arc unit number 2 2 here on a top and 3 3 on the left side and then 4 on the right side and then we have the 6 at the similarly you can have all the polygons we can clearly understand let us take one last that is a d if you see the d it comprises of polygon d comprises of 4 5 7 8 and 12 that is 4 5 7 e and 12 on the left side so this is how these know vector data is stored in a jazz domain for any analysis friends if we see this figure seven what we have as I explained in a beginning that there's non efficient data non especially later if you see the right side is a table what we have as I said that non especial later is arranged in two dimension table in a form of column and row so this is a column ID sighs and then soil then age etcetera and the right side and the row is 1 2 3 it could be of any unit ID may be a district ID 1 they stick to these are the if you see the left side of it this is a map which is the form of vector data which is represented in this table so vector data has its attribute raster data which you see on the right side of it unravel it has also attribute but the if you see if you rasterize this if we take this convert this raster data into vector data say if I example number 4 which is their darker shade in the center if you see number 4 it is size is 119 is a soilless you know some type of soil age is five something else so these are them no non especially later which is linked with this official data so what I'm trying to explain through this figure 7 is that on one side of you the raster data on the left side we have the vector data a vectorized and in this vector data we have the norm especially de which is attached to it in the form of to my in two dimension so friends by now you must have understand what are the Gia's data structure and what are these data models wherein we have clearly spoken about raster data and Victor data especially and we have also seen the what are advantages of using raster data and we have also seen what are the disadvantages I have lost our data and advantages of Victor data and what are the advantages of Victor data before that we have clearly got an impression and we have got an honest running or different data sets and different data bases especially as database we have seen what are the difference between normal data and jazz database we have seen also the special data what are a different sources of spatial data right from the top of sheet to the modern age of remote sensing and even before the remote something we have seen the GIS database as aerial photography or aerial photograph as easy as database so I am sure that you must have got a good understanding of databases and data structure that can be used in geospatial studies and geospatial problems for starting from Social Sciences to other life sciences and human studies these data sources we have also explained that these databases are available for whole of the world not only for one state or for just one country for a whole of this state especially as I said before that in remote sensing remote something data what we are getting in a form of satellite that is covering entire world at a repeated interval at the regular basis sequentially and systematically so I do hope that you must have enjoyed today's lecture on Jia's database and especially raster versus vector data structure thank you so much 

===[=]===


c8P9kB1eun4.en.vtt   the graph data structure has a great many applications in computer science almost invariably to model some type of network travel routes such as road links shipping lanes or aircraft flight paths can be represented including information about distances speed limits wind speed fuel requirements or just about anything of relevance but it doesn't stop there a search engine might model the links between webpages on the internet using a graph the routing of data packets during transmission on a computer network can be represented by a graph the connections between people and groups in social networks the speed and pressure of liquids flowing inside pipes finding the quickest time to complete a project that includes several interdependent steps for example in the field of construction modeling objects in three dimensions usually involves the creation of a mesh which is really just another type of graph the available moves in a strategy game such as chest or the possible scenarios in a computer generated simulation arguably the graph is one of the most versatile data structures in the field of software engineering here's a simple graph it's a collection of interconnected nodes but unlike a tree there are no rules about how these nodes can be connected there's no such thing as a root mode nor are there such things as parent nodes or child nodes in a graph a node is more correctly known as a vertex and vertices are connected by edges typically a graph will have more edges than vertices a graph with lots of edges in relation to the number of vertices is said to be a dense graph while a graph with few edges said to be sparse in some graphs the edges are directional this is known as directed graph it's also known as a digraph a graph in which all of the edges are bi-directional is known as an undirected graph or an unordered graph or simply a graph by default a graph is assumed to be unordered each edge in a graph can have a weight associated with it the weight of each edge is sometimes referred to as the cost what each cost represents depends of course on the application for example each cost could be a speed limit the diameter of a water pipe the number of hours to complete a phase of a project you name it a path is a sequence of vertices in a graph a graph is said to be connected if there is a path from every vertex to every other vertex a cycle is a path in which the starting vertex is also the ending vertex a tree is a special type of graph which includes a path from some starting node the root to every other node but a tree has no cycles so how do we represent a graph or to begin with a graph can be described in mathematical set notation a graph is said to be a set of vertices V and a set of edges e we can list the vertices inside curly brackets and each edge can be listed as a pair of vertices for a weighted graph we can add the cost of each edge to this notation now remember an undirected graph is one in which all of the edges are bi-directional so strictly speaking we should do note each possible direction of an edge separately so what if we want to code up a graph and work with the data it contains there are two ways that a graph class could internally maintain the vertices and edges of a graph these are the adjacency list and the adjacency matrix in essence with an adjacency list system we have a master list of vertices then for each edge each starting vertex maintains a list of ending vertices or to put in another way each vertex maintains a list of its neighbors there are several ways this could be implemented but an object-oriented approach is probably the most suitable we could code up a vertex class that each vertex object would be instantiated from the vertex class would have a property to hold information about the vertex such as the name of a city if we were representing some kind of map another property could be an identifier for the vertex and another an array containing the identifier of its adjacent vertices the master list of vertex objects can also be stored in a simple one-dimensional array to represent a weighted graph the cost of each edge could be stored in the adjacency list to using an adjacency list is a very compact space efficient representation of a graph particularly a sparse graph you don't have to store any more data than necessary however determining if an edge exists between two particular vertices would require searching through the adjacency list of one of them for a dense graph the time taken will increase proportionately with the density of the with an adjacency matrix every vertex is written as a row heading and a column heading in a grid if an edge exists between a pair of vertices then its weight can be indicated at the intersection of the appropriate row and column note that for an undirected graph there is symmetry along the adjacency matrix is diagonal if there's an edge from A to B there must be a corresponding edge from B to a this symmetry wouldn't be present for a directed graph for an unweighted graph we can simply represent each edge with a boolean value an adjacency matrix can be implemented with a two-dimensional array we would still have a vertex class from which we would create each vertex object but the actual connectivity of the graph would be defined by this 2d array of edges one of the advantages of an adjacency matrix over an adjacency list is that determining whether or not an edge exists between two vertices requires a simple array lookup this takes the same amount of time to do regardless of the edge in question however an adjacency matrix is not particularly efficient when it comes to space for a sparse graph much of the adjacency matrix will be empty furthermore for an undirected graph half of the information stored is just duplication which method you use to implement a graph will ultimately depend on the nature of the information it will represent and of course how you plan to process it 

===[=]===


R-HLU9Fl5ug.en.vtt   hi I'm Joe today I'm going to cover Python lists tuples sets and dictionaries now the list is the most widely used data structure in pythons very general-purpose similar to an array in Java and it covers most of what you would need but Tuffle sets and dictionaries have some advantages and specific areas and are very very useful data structures so the list is a sequence type is sortable the tupple is immutable which means you can't change add or remove items in a tubful once it's been created it's so it's useful for fixed data and tuple is also a sequence type which we'll explain in a second the set you can store non duplicate items so it's good for storing unique items in a set it's also very good for doing mathematical comparisons to set Union intersect those kinds of set operations dictionaries contain key value pairs it's like an associative array somewhere to a job a hash map and both sets and dictionaries are unordered which means they're not sortable and they're in random order there's one amazing thing about these data structures in Python is that they can hold any data type so they can hold integers floating point values strings or other object types and even other lists tuples sets and dictionaries and the data types don't have to be homogeneous so you can mix and match data types within a single list or within a set or within a dictionary now sequences include this tuples and also strings they're a bunch of different functions are applicable to all three of these data types and we're going to go into them in detail so indexing you can access any item in the sequence instantly using its index you have a million items in your list and you want to access an item instantly you can do that if you know it's index so a string is a sequence of letters let's say we want to access one of the items in the word frog we can say print X of three using the square brackets for the three and that gives us the third index starting from index 0 for F the G is going to be index 3 and in our list if we say we want item with index 1 that's going to go Scouse second eye list slicing allows us to slice out sub strings and sub lists and sub couples using indexes and syntax is using square brackets start n plus 1 and step and these are all optional I'll cover some examples of explain that and these are applicable to strings tuples and lists but in this example I'm just going to use the word computer which is a string so let's say we have X from 1 to 4 using a colon and this will return to us items 1 2 3 which is OMP if we want to slice items 1 2 6 this actually cuts off at 5 and it'll give us every other item since we have a step of 2 here so items 1 3 and 5 opt and X with items 3 2 basically no end right we didn't put an item after the colon so that's going to give us 3 onward 2p u ter if we don't put anything before the colon then it starts at 0 so this will give us items 1 through 4 or rather 0 through 4 and if we want to use negative numbers here we can use negative 1 which is the last item in a list or a sequence so X of negative 3 : nothing is going to give us the last three items on a sequence and then if we have X : negative 2 will give us everything except the last two items in it in the sequence adding and concatenating we can do using the plus symbol so we can combine two sequences of the same type only so if we have two strings that we want to combine we can use a plus sign to add them together and if we have two lists we want to merge together we can use the plus sign and will give us one list with 3 items in it multiplying we can use the star sign to multiply sequences again at the same type so if we have a bug it will multiply the word bug three times and give us bug bug bug or if we have a list with an eight and a five in it we want to multiply that by three it will give us eight five three times in our list checking membership test whether or not an item is in or not in a sequence using keywords in and not in so it's very simple to use so if we have x equals bug and we want to print you in x will print true if you is actually an X and O print false if it's not so in our list pig cow horse print cow not and will print true if cow is not an egg however cow is an EXO prints false so that's checking membership using the in and not end keywords iterating we can iterate through the items in a sequence using for loop so if we have list of integers in X we can say for item or in any variable name in X Trinity or whatever we want to do to that variable name it returns to us one list item at a time each loop iteration and if we need both the index and the item we can use the enumerate function so we say for index and item when you basically need two variable names here the first one is going to be index sector is going to be the value or the item in enumerate X and then we can do inside this for loop we can do whatever we want those two variables here I just have a print statement that prints the index followed by the value number of items will count the number of items in a sequence and we do that using the Len function which is short for length and we can do the same thing in a list prints the length of a list three items in this list minimum finds the minimum number lexicographically which means alpha numerically but this only works when all of the items in the list are either alpha or numeric you can mix and match integers and floating point values but you cannot have both strings and integers so if x equals bug we want to find the minimum the minimum is B we have a list of three strings we're going to find the lowest one which is C cow so prints cow maximum is going to find the maximum item in a sequence again lexicographically and they have to be all the same type either numeric or string type so if we take the maximum bug we get u and if we take the maximum of pig cow and horse we're going to get pig because it comes last alphabetically some we can find the sum of the items in a sequence if they're numeric type so five seven and bug is going to give us an error because bug is is not a numeric type but if we take the sum of two five eight and twelve it's going to print 27 or if we want to do a slice we can say hey I just want the sum of the last two items of X and this here will print 20 we can sort the items of the list this sorted function actually returns a new list without changing the original list returns a new list in sorted order so bug will return two letters of bug in a list in sorted order bgu and our list pig cow horse if we call sorted of X it's going to return a cow horse pig and mind you the original X is still unchanged count of item returns the count of a specific item in the sequence so here we're looking for the account X dot count of P will tell us there are two peas in hippo and X dot count of cow will tell us how many times the word cow appears in our list X if we want to find the index of an item the index function actually returns the index of the first occurrence of an item so if the item is in the list or sequence multiple times it returns the index of the first occurrence so here the H is 0 the eye is one the P the first P is 2 so X dot index of P is going to return 2 and here we find the first cow which has an index of 1 unpacking if we want to assign all the items in a sequence to a set of variables we can say a comma B comma C equals x and then all the strings in X will be assigned in order to the variables here on the left so Pig assign to a cow assigned to be in horse assign C but this only works if the number of variables exactly matches the length of your list so here we have 3 items we must have 3 variables so that covers general functions for sequence types now let's talk about specific list functions so there are a few different ways to create lists we can say x equals list parentheses we can say x equals in square brackets whatever list items we want to add to populate the list and again we can mix and match datatypes so we have Center some strings integers floating points and we can say x equals list and then in parentheses a double and we'll get a list from the items in the tuple there's a really cool function called comprehension so we can create a new list using what is returned by the for loop for M in range 8 so M and range 8 returns the values 0 through 7 and here we're saying we'll just take those values in so the resulting list is 0 through 7 here we have a for loop that says Z and range 10 if Z is greater than 4 so in other words item is 4 through 9 but we said hey look instead of adding the item itself Z to our list we want to add Z squared so it's going to take 5 through 9 and it's going to square each one of them and add it to the list so we get 25 36 49 64 81 so list comprehensions you can have fairly complex functions inside of the square brackets to create and populate a new list with whatever values you want delete we can delete an item from a list or we can delete a complete list the item we would delete using the index or we can delete the entire list append we can append an item to the end of the list using the append function extend we can combine to this this is very similar to the plus function that we already showed X extend Y is going to combine both x and y together into list X insert allows us to insert an item into a certain index position so here we want to insert a 7 into position one it will scoot the rest of the items to the right and put the 7 into the list and here we're going to insert a sub list or an embedded list with letters a and M into position 1 which is going to scoot all pop our sub list right in here the pop function pops the last item off the list and returns it so if we want to let's say print an item as we pop it off the list we can say print X dot pop and it will print the last item on the list and the new list will have one less item in it remove is going to remove a specific instance of an item so if we want to remove a 3 from this list we can put X dot remove 3 in order with the first 3 that defines not every 3 just the first 3 so you can see here the first 3 is gone and reverse reverses the current order of the list so the number that is first will become the last the number of the glass is going to become first and so on sort will actually do an in-place sort so a new list you get back our list X here is going to become a sorted list so unlike the sorted function sort is an in-place sort so it actually changes the order of the items in list X now let's talk about tuples so tuples support all the operations for sequences but tuples are immutable so member objects inside a tuple may be mutable for example you may have a list inside of a couple could be one of the items in your tub whole that list is still mutable you can still change an add and delete item from the list but you cannot delete the list itself from your Tuffle so it's a little confusing I'm going to show some examples in a second if the contents of a list shouldn't be changed then you can use a tupple that's what tuples are used for it's useful when you have a constant set of values that are not going to be changed that you want to use throughout your program and tuples are more efficient than lists due to how Python implements them so how do you construct a temple well a new tuple with no values in it is going to just be created using the parentheses and we can say x equals 1 comma 2 comma 3 if we want to create a tough hole with values 1 2 &amp; 3 in it and you don't even need the parentheses actually the parentheses are optional if you want to create a single item tuple you still have to put a comma after that item otherwise it would just sign x equals integer value 2 and X would be an integer not a double so the comma tells it hey this is a tupple but it's a single item tuple and we can create a tuple from all the members of a list just using the tupple function so tuples are immutable as I said if we try to delete an item from a tuple or change the value of an item in a temple we're going to get an error but if we have let's say a list inside of a tuple here we have a two pole called X and our first item is a list with one and two in it and our second item is an integer 3 so we can't change that 3 that's immutable however we can't change the list here we're going to delete the the list which is to the item in index 1 so our new tough ball has a list with just the 1 in it and integer 3 so we can change the list the list itself is mutable but the tuple is not we still have to keep the list in this position let's talk about sets now so there are some constructors how we would create a new set we use the curly braces if we want to populate a set with values and we can create a new empty set using set with parentheses and we can create a set from a list by calling a set function in parentheses the name of the list when we do this though it strips out all the duplicates from our list and returns only unique values to the set and then we also have similar to the list comprehension a set comprehension so we can use a for loop if statements and whatever functions we want to do on those X values X is probably a bad choice of variables here since we're using X for the set name but but we can use the list comprehension to put values into our set and sets our unordered so as we populate set the items are going to be in random order so some basic set operations we can add an item to set X by using X dot add item remove an item set X using X dot remove item get length of set X using a Len function we can check membership in X by simply saying item in X or item not in X that's going to return a boolean true or false we can pop a random item from set X using a pop function we don't know which item is going to be popped it's arbitrary selected and we can delete items from set X by saying X dot clear will completely empty our set some of the standard mathematical functions for sets are very useful we can find the intersection of two sets using the ampersand function and we can find a union of two sets using the vertical bar symmetric difference or exclusive or in other words items that are in set one but not in set two or in set two and not inset one using the up arrow the difference which means items that are in set 1 but not in set 2 we just take set one - set 2 and subsets and supersets a boolean value does set to contain set 1 or 2 set 1 contain set 2 for superset question so there's one set operations now let's take a look at dictionaries so a dictionary again is a key value pair and you can see three different ways here to create a dictionary you can use curly braces with the key first in this case I chose to use strings for a key and floating-point values for my value and they're separated by pullin so this is the most standard way to create a dictionary you can also call the dictionary function to create a dictionary by placing comma separated tuples inside of the set and you can also say key equals value comma separated and called dictionary on that so there's three different ways to create a dictionary I find the first one is more widely used in more standard but the all three work so some basic dictionary operations you can add or change an item in dictionary X by saying X key is equal to value if this key is already existing in the dictionary then it will change the value to this if the key doesn't exist in dictionary it will add this key value pair to the dictionary remove item from dictionary X delete X and then the key get the length of dictionaries and a Len function check membership in X item in ax or item not in X this only looks in the keys it does not compare to values so if we want to look through values I'll show it show you a way on the next slide to do that delete all items from dictionary X we could say X clear and delete the entire dictionary X delete X del X so how do we access the keys and values in the dictionary we can say X dot keys will return a list of the keys in X X values returns a list of values in X and X dot items return a list of key value couple pairs and X so if we want to check membership in values of X we can say item in X values and this will text test the membership in X and return a boolean iterating a dictionary we can use for loops for variable in X print variable right so we say key we used a word key for our variable we can print our key and then if we want access to the value as well we say X and then key in square brackets then we can get both the key and the value display by iterating however if we want to do a lot of operations or use use the value quite frequently inside of our for loop we could use items instead so we can get two separate variables for the key and the value by saying for K comma V in extra item items is going to return both a key and a value and assign them to variables K and V in this case so when we print K and B we print out each key and each value for the entire dictionary that wraps up my video on dictionaries I hope you enjoyed the video please click the like button at the bottom I'm Joe James thanks for watching 

===[=]===


CzZ6KodVKJo.en.vtt   into trees a tree is a data structure in which data elements have hierarchical relationship there are several ways of describing the internal structure of a tree formally we can define a tree data structure as a collection of data elements called nodes such that the collection has a special node called root which provides an entry point to the tree data structure the nodes are connected together with edges or paths there is exactly one path from the root to any node in the tree a tree data structure is often depicted by means of a diagram unlike a natural tree a tree data structure is shown to grow from top to bottom with root at the top and leaves at the lowest level a node is represented by a circle oval or rectangle it is usually labeled with the data value contained in the node the edges are shown by the slanted lines by convention tree is portrayed from top to bottom the direction of edges is therefore emitted figure shows an example of three data structure in this structure a is root node II M n g h i j k l are leaves all other nodes are the internal nodes basic definition and terminology the structure and properties of a tree structure are described by using a special vocabulary which is borrowed from mathematical graph theory and family trees most algorithms for trees use this terminology we therefore have a closer look at these terms payment node in the tree hierarchy and no directly above a given node is called parent node C is the parent node of H I and J the only exception is the root node which has no parent chide node a node which is directly below a parent node is called child node or simply a child for example C is the child of fruit and hij are children of C siblings all children which have common parent are collectively known as thus H I J are siblings of C likewise b c and d are siblings of if all siblings appear in definite order say in alphabetical order the tree is called ordered tree the tree shown in this figure is in fact an ordered tree ancestors we call that in a tree structure a node has a unique path to the root node or nodes which appear on the path from a given node to the root node are called ancestors of the given node for example ancestor of M r.fp and ascendant a descendant is a child of a node or a descendent of the child all of the descendants of a node n are called a subtree rooted at n in figure the subtree rooted at b consists of nodes b e f g m and n a subtree may comprise a single leaf node as we shall see later the notion of subtree is of great help in partial processing of data contained in a subset of nodes level of tree obviously the nodes of a tree are organized at different levels by convention the root node is at level 0 the children of fruit are at level 1 the children of children of fruit are at level 2 and so on notice that in Figure the nodes B C and D are at level 1 and nodes e f g h i j k and l are at level 2 the leaves m n are at level 3 height of a tree the maximum level of a node in a tree is called height of a tree thus the tree structure in figure has height 3 as we shall see later the height of a tree plays a crucial role in determining the performance of search algorithms a tree with the shorter height can be searched faster than an equivalent tree with greater height containing the same data elements from the preceding discussion we conclude that a tree data structure has two important characteristics which distinguish it from other data structures first unlike a stack and a queue a tree is a nonlinear structure this implies that a data element in tree has more than one successor which can be depicted in hierarchical fashion in two dimensions second the defining property of a tree is the existence of a unique path from root to any of the three nodes this also implies that any node in the tree has a unique parent except the root node if there is more than one path are more than one parent to a node or there is no path then the structure is not a valid tree data structure it belongs to the data structure called graph figure shows an illustration in which node E has two parent B and C also note that G has two parts to the root namely g e b a and g e CA thus we conclude that data structure is not a tree forest we have seen that a node which has no path to the root of a tree is not considered part of the tree this situation leads to the notion of a forest which is defined as a set of disjoint tree structure the disjoint property implies that there is no explicit part linking one tree to another for example if we remove the root node we have a set of three disjoint trees shown in figure here the forest is a set of three trees classification of trees the three structures are classified on the basis of maximum number of children permissible to be attached to a parent node if in a tree a parent as zero one two and children it is called Emery or anway three a ternary tree for example is the one in which each node can have up to three children if an energy tree contains nodes in specific order the tree is called multi-way 3 in this case each node contains a set of keys which determined range of values held by child nodes for example in eternity tree a node may contain keys a H and T to imply that the fourth child would contain a character in the range A to G second child would contain character in range h2s and third would contain characters in range T to Z monkey ways trees are frequently used in modern database management system to facilitate rapid searching of indexed records in order to improve the performance of search operations the height of tree is capped to be minimum balancing the levels of sub trees the resulting trees are often called as balanced trees the term b3 is often used to describe such trees the plus tree is a variant of b3 in which all the leaves are linked by pointers to facilitate sequential searching in addition to normal random searching indeed B and B plus trees are cornerstones of all modern data file systems and database management system simpler versions of B tree are used in some applications - such variants are known as two three three and two three four tree the former contains two to three nodes per child and later two to four nodes per child figure shows a small two three three a binary tree is the simplest form of each node can have at most two child nodes we shall study in great detail the binary tree structure in the subsequent section of the unit for now let us briefly look at some of the applications of binary trees application of trees many hierarchical data structures analogues to trees are commonly encountered in our daily lives a familiar example is the organization chart of a large department or company in which the hierarchy of the organization is shown the root node shows the head or CEO the children of fruit are usually the senior management which are followed by middle or to executives the line or operation level staffs are generally exhibited at the leaf nodes by systematically scanning the trees from top to bottom we can list all positions at different levels in the another common example of three data structure is table of contents of a book or a document as shown in Figure the title of book is at the root the book is generally organized into several chapters each chapter may be further organized into sections and the sections may in turn be divided into subsections using one of the three algorithms we can print the table of contents of the book with chapters sections and subsections appropriately indented as shown perhaps the most common example of three familiar to computer user is the structure of filing system in operating systems such as yonyx window and Mac information and content of a set of files residing in the computer are organized in a hierarchy of directories and subdirectories as shown the root of the tree represents the root directory the data files are represented at leaf levels by traversing tree we can determine the contents of files in each sub directories and print their size you 

===[=]===


F1F2imiOJfk.en.vtt   in this lesson we are going to introduce you to stack data structure data structures as we know are ways to store and organize data on computers so far in this series we have discussed some of the data structures we have talked about arrays and linked lists now in this lesson we are going to talk about stacks and we are going to talk about stack as abstract data type or ADT when we talk about a data structure as abstract data type we talk only about the features or operations available with the data structure we do not go into implementation details so basically we define the data structure only as a mathematical or logical model we will go into implementation of stack in later lessons in this lesson we are going to talk only about stack ADT so we are only going to have a look at the logical view of stack stack as a data structure in computer science is not very different from stack as a way of organizing objects in real world here are some examples of stack from real world first figure is of a stack of dinner plates second figure is of a mathematical puzzle called Tower of Hanoi where we have three rods or three pegs and multiple disks and the game is about moving a stack of disks from one peg to another with this constraint that a disk cannot go on top of a smaller disk third figure is of a pack of tennis balls stack basically is a collection with this property that an item in the stack must be inserted or removed from the same end that we call the top of stack in fact this is not just a property this is a constraint or restriction only the top of a stack is accessible and any item has to be inserted or removed from the top a stack is also called last in first out collection most recently added item in a stack has to go out first in the first example you will always pick up a dinner plate from top of the stack and if you will have to up late back into the stack you will always put it back on top of the stack you can argue that I can slip out a plate from in between without actually removing the plates on the top so the constraint that I should take out a plate always from the top is not strictly enforced for the sake of argument this is fine you can say this in other two examples when we have disks in a peg and tennis balls in this box that can open only from one side there is no way you can take out an item from in-between any insertion or removal has to happen from top you cannot slip out an item from in-between you can take out an item but for that you will have to remove all the items on top of that item let's now formally define stack as an abstract data type a stack is a list or collection with the restriction that insertion and deletion can be performed only from one end that we call the top of stack let's now define the interface or operations available with stack ADT there are two fundamental operations available with a stack and insertion is called a push operation push operation can insert or push some item X onto the stack another operation ii operation is called pop pop is removing the most recent item from the stack most recent element from the stack push and pop are the fundamental operations and there can be few more typically there is one operation called top that simply returns the element at top of the stack and there can be an operation to check whether a stack is empty or not so this operation will return true if the stack is empty false otherwise so push is inserting an element on top of stack and pop is removing an element from top of stack we can push or pop only one element at a time all these operations that I have written here can be performed in constant time or in other words the time complexity is big-oh of remember an element that is pushed or inserted last onto a stack is popped or removed first so stack is called last in first out structure what goes in last comes out first last in first out in short is called leaf Oh logically a stack is represented something like this as a three-sided figure as a container open from one side this is a representation of an empty stack let's name this stack s let's say this figure is representing a stack of integers right now the stack is empty I will perform push and pop operations to insert and remove integers from this stack I will first write down the operation here and then show you what will happen in the logical representation let's first perform a push I want to push number 2 on to the stack the stack is empty right now so we cannot pop anything after the push stack will look something like this there is only one integer in the stack so of course it's on top let's push another integer this time I want to push number 10 and now let's say we want to perform a pop the integer at top right now is 10 with a pop it will be removed from the stack let's do a few more push I just pushed 7 and 5 onto the stack at this stage if I will call top operation it will return me number 5 is empty will return me false at this stage a pop will remove 5 from the stack as you can see the element the integer which is coming last is going out first that's why we call stack last in first out data structure we can pop till the stack gets empty one more pop and stack will be empty so this pretty much is stack data structure now one obvious question can be what the real scenarios where stack helps us let's list down some of the applications of stack stack data structure is used for execution of function calls in a program we have talked about this quite a bit in our lessons on dynamic memory allocation and linked lists we can also say that stack is used for recursion because recursion is also a chain of function calls it's just that all the calls are to the same function to know more about this application you can check the description of this video for a link to my course Schools lesson on dynamic memory allocation another application of stack is we can use it to implement undo operation in an editor we can perform undo operation in any text editor or image editor right now I'm pressing ctrl Z and as you can see some of the text that I have written is getting cleared you can implement this using a stack stack is used in a number of important algorithms like for example a compiler verifies whether parenthesis in a source code are balanced or not using stack data structure corresponding to each opening curly brace or opening parenthesis in a source code there must be a closing parenthesis at appropriate position and if parenthesis in a source code are not put properly if they are not balanced compiler should throw error and this check can be performed using a stack we will discuss some of these problems in detail in coming lessons this much is good for an introduction in our next lesson we will discuss implementation of stack this is it for this lesson thanks for watching 

===[=]===


download video data for  3.65 minutes
