{
    "concept_relationship": {
        "links": [
            {
                "prerequisite": null,
                "similarity": 0.9999999999999999,
                "source": 0,
                "target": 0
            },
            {
                "prerequisite": 0.4500599873179829,
                "similarity": 0.9340351778464756,
                "source": 1,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.03500451920788287,
                "source": 0,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.12287521492963488,
                "source": 0,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.10621581067582246,
                "source": 0,
                "target": 4
            },
            {
                "prerequisite": 1.1080012914590636,
                "similarity": 0.858356250829527,
                "source": 5,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.1509467142360681,
                "source": 0,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.1385880960389019,
                "source": 0,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.5171621908562463,
                "source": 0,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.06610286388431452,
                "source": 0,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.21713651849267396,
                "source": 0,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.011679503794826546,
                "source": 0,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.15170516777820148,
                "source": 0,
                "target": 12
            },
            {
                "prerequisite": 0.33537195959015453,
                "similarity": 0.6317451699214991,
                "source": 0,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 0,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.05799988834841276,
                "source": 0,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.11691101657644087,
                "source": 0,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.3917380003873816,
                "source": 0,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 0,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.0317399156996447,
                "source": 0,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.11517641381972245,
                "source": 0,
                "target": 20
            },
            {
                "prerequisite": 0.3896003029272659,
                "similarity": 0.6565742375807929,
                "source": 21,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.39850687728890927,
                "source": 0,
                "target": 22
            },
            {
                "prerequisite": 0.5531635885948014,
                "similarity": 0.9564451235537577,
                "source": 0,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.036687272174412325,
                "source": 0,
                "target": 24
            },
            {
                "prerequisite": 0.16221521275359496,
                "similarity": 0.8073456442237346,
                "source": 25,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.12106481764813214,
                "source": 0,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.12782177560168304,
                "source": 0,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.4713763422600251,
                "source": 0,
                "target": 28
            },
            {
                "prerequisite": 0.0994937633870972,
                "similarity": 0.9794532906881677,
                "source": 29,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.9340351778464756,
                "source": 1,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.9999999999999999,
                "source": 1,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.04668764717768765,
                "source": 1,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.1993664899810275,
                "source": 1,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.15618130382907036,
                "source": 1,
                "target": 4
            },
            {
                "prerequisite": 1.7035284723380204,
                "similarity": 0.8723377057224108,
                "source": 1,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.21931899076163003,
                "source": 1,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.16083376102838728,
                "source": 1,
                "target": 7
            },
            {
                "prerequisite": 0.16828516897300544,
                "similarity": 0.6366487336722495,
                "source": 1,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.08532508115430716,
                "source": 1,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.26300990525598095,
                "source": 1,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.039519286178216886,
                "source": 1,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.147979125807618,
                "source": 1,
                "target": 12
            },
            {
                "prerequisite": 0.6813121403316766,
                "similarity": 0.7785803225155303,
                "source": 1,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 1,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.07068264849688022,
                "source": 1,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.19236647377182992,
                "source": 1,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.4558734951157828,
                "source": 1,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.015213115532121586,
                "source": 1,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.07212053593959301,
                "source": 1,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.19318152429927504,
                "source": 1,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.49377893259214145,
                "source": 1,
                "target": 21
            },
            {
                "prerequisite": 0.12149262605434563,
                "similarity": 0.6527836869500376,
                "source": 1,
                "target": 22
            },
            {
                "prerequisite": 1.4669185624508199,
                "similarity": 0.9587270348263298,
                "source": 1,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.08757670373068235,
                "source": 1,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.569388848755368,
                "source": 1,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.1261523194865118,
                "source": 1,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.19275782411368864,
                "source": 1,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.4675920332210977,
                "source": 1,
                "target": 28
            },
            {
                "prerequisite": 0.6567429940239687,
                "similarity": 0.887571923904389,
                "source": 1,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.03500451920788287,
                "source": 2,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.04668764717768765,
                "source": 2,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 2,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.1000360266123073,
                "source": 2,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.41582527999077606,
                "source": 2,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.034183761552317324,
                "source": 2,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.08484276986489918,
                "source": 2,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.2735265208614764,
                "source": 2,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.02284722930311166,
                "source": 2,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.29156437901576554,
                "source": 2,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.3491172210531499,
                "source": 2,
                "target": 10
            },
            {
                "prerequisite": 2.6136591246386702,
                "similarity": 0.8091531774037911,
                "source": 2,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 2,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0235802012219165,
                "source": 2,
                "target": 13
            },
            {
                "prerequisite": 2.2062980363943785,
                "similarity": 0.8205877741335885,
                "source": 2,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.14065774019325278,
                "source": 2,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.058265689984203534,
                "source": 2,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.12808677362683288,
                "source": 2,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.3120691134217232,
                "source": 2,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.29099040719913766,
                "source": 2,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.040834607919994374,
                "source": 2,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.10970985016517756,
                "source": 2,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.08501940463445036,
                "source": 2,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.027554280616878302,
                "source": 2,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.22238698664100592,
                "source": 2,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.02046394922900335,
                "source": 2,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.26676482549116354,
                "source": 2,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.029278592118930746,
                "source": 2,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.02303136689482748,
                "source": 2,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.028420813861484207,
                "source": 2,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.12287521492963488,
                "source": 3,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.1993664899810275,
                "source": 3,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.1000360266123073,
                "source": 3,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 3,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.06851759186298867,
                "source": 3,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.13237863320783108,
                "source": 3,
                "target": 5
            },
            {
                "prerequisite": 0.0035615276397183426,
                "similarity": 0.9923072206502024,
                "source": 6,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.1771021999406327,
                "source": 3,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.1308854145846631,
                "source": 3,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.04065071729523736,
                "source": 3,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.4028253381496071,
                "source": 3,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.021329726813334338,
                "source": 3,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 3,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.012545675649384917,
                "source": 3,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 3,
                "target": 14
            },
            {
                "prerequisite": 0.9370569877541549,
                "similarity": 0.6695277847117147,
                "source": 3,
                "target": 15
            },
            {
                "prerequisite": 3.437732365875313,
                "similarity": 0.9622659296018119,
                "source": 16,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.005556551441175929,
                "source": 3,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.015666801782339035,
                "source": 3,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.062057475136685164,
                "source": 3,
                "target": 19
            },
            {
                "prerequisite": 0.3528398123060761,
                "similarity": 0.919504441979933,
                "source": 20,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 3,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.03343783063663706,
                "source": 3,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.012704501155746882,
                "source": 3,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.03908347012048692,
                "source": 3,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 3,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.13426096840066376,
                "source": 3,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.31093126806923643,
                "source": 3,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 3,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.00797113772695396,
                "source": 3,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.10621581067582246,
                "source": 4,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.15618130382907036,
                "source": 4,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.41582527999077606,
                "source": 4,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.06851759186298867,
                "source": 4,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.9999999999999994,
                "source": 4,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.11308055859232619,
                "source": 4,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.039668423089067276,
                "source": 4,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.4058284173458201,
                "source": 4,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.10190269095364318,
                "source": 4,
                "target": 8
            },
            {
                "prerequisite": 1.0750956917493075,
                "similarity": 0.8661557381189413,
                "source": 9,
                "target": 4
            },
            {
                "prerequisite": 1.0579885432283067,
                "similarity": 0.7234056475648785,
                "source": 4,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.10554987080030867,
                "source": 4,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.019911788070772273,
                "source": 4,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.1316367159837516,
                "source": 4,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.011208622423944659,
                "source": 4,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.015381890191157935,
                "source": 4,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0338026104254994,
                "source": 4,
                "target": 16
            },
            {
                "prerequisite": 2.3560488428743738,
                "similarity": 0.630816099134789,
                "source": 17,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.37406971573634135,
                "source": 4,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.5103223073679951,
                "source": 4,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.03350679870948335,
                "source": 4,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.13418361611579724,
                "source": 4,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.15602635748596044,
                "source": 4,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.11810431754753048,
                "source": 4,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.17903612166879782,
                "source": 4,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.03119493603637454,
                "source": 4,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.39290943451099664,
                "source": 4,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.4052406135113653,
                "source": 4,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.08808560522014501,
                "source": 4,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.09832292544077537,
                "source": 4,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.858356250829527,
                "source": 5,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.8723377057224108,
                "source": 5,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.034183761552317324,
                "source": 5,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.13237863320783108,
                "source": 5,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.11308055859232619,
                "source": 5,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 1.0000000000000002,
                "source": 5,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.15730570937581492,
                "source": 5,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.4575417604290845,
                "source": 5,
                "target": 7
            },
            {
                "prerequisite": 0.42681186869454457,
                "similarity": 0.8776191127848836,
                "source": 5,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.04708852846847029,
                "source": 5,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.20832080661271055,
                "source": 5,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.011530063069716979,
                "source": 5,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.5890720519725503,
                "source": 5,
                "target": 12
            },
            {
                "prerequisite": 1.2893236854208614,
                "similarity": 0.652206779135813,
                "source": 5,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 5,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.08684361472604687,
                "source": 5,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.11712555236871876,
                "source": 5,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.39936834857221204,
                "source": 5,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 5,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.03133379947241487,
                "source": 5,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.11112762512214411,
                "source": 5,
                "target": 20
            },
            {
                "prerequisite": 0.33418471886915213,
                "similarity": 0.7621465888284739,
                "source": 5,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.4384312836594085,
                "source": 5,
                "target": 22
            },
            {
                "prerequisite": 1.2986695501831398,
                "similarity": 0.7953143378514866,
                "source": 5,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.036217853896688516,
                "source": 5,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.5109501493052815,
                "source": 5,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.07852278248616515,
                "source": 5,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.12234194962696042,
                "source": 5,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.46534502246902204,
                "source": 5,
                "target": 28
            },
            {
                "prerequisite": 1.4223469013218961,
                "similarity": 0.7619458328940574,
                "source": 5,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.1509467142360681,
                "source": 6,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.21931899076163003,
                "source": 6,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.08484276986489918,
                "source": 6,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.9923072206502024,
                "source": 6,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.039668423089067276,
                "source": 6,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.15730570937581492,
                "source": 6,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.9999999999999999,
                "source": 6,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.13990745155812412,
                "source": 6,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.15222574248668846,
                "source": 6,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.0016448106161106534,
                "source": 6,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.4365656778990486,
                "source": 6,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.0018792400267194458,
                "source": 6,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 6,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.06099603760172451,
                "source": 6,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 6,
                "target": 14
            },
            {
                "prerequisite": 0.6088163270062954,
                "similarity": 0.6263274036425202,
                "source": 15,
                "target": 6
            },
            {
                "prerequisite": 4.450593417665095,
                "similarity": 0.9758888477162637,
                "source": 16,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.045025822723558706,
                "source": 6,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 6,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.0051069738128681425,
                "source": 6,
                "target": 19
            },
            {
                "prerequisite": 0.4955828736432188,
                "similarity": 0.9403313397033066,
                "source": 6,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.00835992240732649,
                "source": 6,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 6,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.03860514630020554,
                "source": 6,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.00590300680169693,
                "source": 6,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.010647900196656618,
                "source": 6,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.06670841921717315,
                "source": 6,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.2763034949215048,
                "source": 6,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0758447709410415,
                "source": 6,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.03875501249274256,
                "source": 6,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.1385880960389019,
                "source": 7,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.16083376102838728,
                "source": 7,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.2735265208614764,
                "source": 7,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.1771021999406327,
                "source": 7,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.4058284173458201,
                "source": 7,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.4575417604290845,
                "source": 7,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.13990745155812412,
                "source": 7,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 1.0000000000000002,
                "source": 7,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.5924674386911601,
                "source": 7,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.2733931732606631,
                "source": 7,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.24197071223384858,
                "source": 7,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.052978220961015614,
                "source": 7,
                "target": 11
            },
            {
                "prerequisite": 1.1814647579159647,
                "similarity": 0.7175296133887175,
                "source": 7,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.02805234026941895,
                "source": 7,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.062139599733103394,
                "source": 7,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.19496381338572433,
                "source": 7,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.10610699671703082,
                "source": 7,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.020707569698201093,
                "source": 7,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.05935257387648912,
                "source": 7,
                "target": 18
            },
            {
                "prerequisite": 1.6771065617993748,
                "similarity": 0.6008663300671946,
                "source": 19,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.08343398956311505,
                "source": 7,
                "target": 20
            },
            {
                "prerequisite": 0.4072213958738808,
                "similarity": 0.6129950935808289,
                "source": 7,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 7,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.0177546729713054,
                "source": 7,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.0027148182394263433,
                "source": 7,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.004897015137635424,
                "source": 7,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.49659989292150963,
                "source": 7,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.4648722642192295,
                "source": 7,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.03488133665315469,
                "source": 7,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.01782359707839874,
                "source": 7,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.5171621908562463,
                "source": 8,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.6366487336722495,
                "source": 8,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.02284722930311166,
                "source": 8,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.1308854145846631,
                "source": 8,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.10190269095364318,
                "source": 8,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.8776191127848836,
                "source": 8,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.15222574248668846,
                "source": 8,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.5924674386911601,
                "source": 8,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.9999999999999998,
                "source": 8,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.016056412159229365,
                "source": 8,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.1914445696237401,
                "source": 8,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.009968899222496589,
                "source": 8,
                "target": 11
            },
            {
                "prerequisite": 0.9881121410228009,
                "similarity": 0.7835569816181909,
                "source": 8,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.5954348240583427,
                "source": 8,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 8,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.07335223164480609,
                "source": 8,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.12033881435737523,
                "source": 8,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.35926178622530575,
                "source": 8,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 8,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.02709122121099447,
                "source": 8,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.11652955092762256,
                "source": 8,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.5909987925335677,
                "source": 8,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.428809889515313,
                "source": 8,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.480098500121797,
                "source": 8,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.03131397750108367,
                "source": 8,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.056484452482087534,
                "source": 8,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.007777395854120164,
                "source": 8,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.11299147846019698,
                "source": 8,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.402337576527928,
                "source": 8,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.37832103448540433,
                "source": 8,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.06610286388431452,
                "source": 9,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.08532508115430716,
                "source": 9,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.29156437901576554,
                "source": 9,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.04065071729523736,
                "source": 9,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.8661557381189413,
                "source": 9,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.04708852846847029,
                "source": 9,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.0016448106161106534,
                "source": 9,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.2733931732606631,
                "source": 9,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.016056412159229365,
                "source": 9,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 9,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.474182561441285,
                "source": 9,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.1949038554897445,
                "source": 9,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 9,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.026965860091609464,
                "source": 9,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.1159009094419806,
                "source": 9,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 9,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 9,
                "target": 16
            },
            {
                "prerequisite": 3.263583882401532,
                "similarity": 0.650836550783718,
                "source": 17,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.09596892127190002,
                "source": 9,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.5072181841881287,
                "source": 9,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 9,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.05731358782188207,
                "source": 9,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.07720358292777645,
                "source": 9,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.061020287344591376,
                "source": 9,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.17972817508140698,
                "source": 9,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.06794237961368646,
                "source": 9,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.5159430350044352,
                "source": 9,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.4692467758201001,
                "source": 9,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.02168653943709922,
                "source": 9,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.06774919033276255,
                "source": 9,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.21713651849267396,
                "source": 10,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.26300990525598095,
                "source": 10,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.3491172210531499,
                "source": 10,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.4028253381496071,
                "source": 10,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.7234056475648785,
                "source": 10,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.20832080661271055,
                "source": 10,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.4365656778990486,
                "source": 10,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.24197071223384858,
                "source": 10,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.1914445696237401,
                "source": 10,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.474182561441285,
                "source": 10,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 10,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.00861823089491644,
                "source": 10,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 10,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.2797290012198885,
                "source": 10,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 10,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.023366739793566807,
                "source": 10,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.46461006919620323,
                "source": 10,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.5453049672215912,
                "source": 10,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.5555515072398343,
                "source": 10,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.2627332272172359,
                "source": 10,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.4884221747769222,
                "source": 10,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.11050919587361535,
                "source": 10,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 10,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.17704394319867844,
                "source": 10,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.027071302690426003,
                "source": 10,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.04883147503036491,
                "source": 10,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.15216796091990706,
                "source": 10,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.3843177625908729,
                "source": 10,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.3478255778124337,
                "source": 10,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.17773123243914907,
                "source": 10,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.011679503794826546,
                "source": 11,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.039519286178216886,
                "source": 11,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.8091531774037911,
                "source": 11,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.021329726813334338,
                "source": 11,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.10554987080030867,
                "source": 11,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.011530063069716979,
                "source": 11,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.0018792400267194458,
                "source": 11,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.052978220961015614,
                "source": 11,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.009968899222496589,
                "source": 11,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.1949038554897445,
                "source": 11,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.00861823089491644,
                "source": 11,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.9999999999999998,
                "source": 11,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 11,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.01992657184833707,
                "source": 11,
                "target": 13
            },
            {
                "prerequisite": 0.8276541360078572,
                "similarity": 0.8386592544334106,
                "source": 11,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 11,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 11,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.01470932091343117,
                "source": 11,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.10501331030243052,
                "source": 11,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.15256868519627115,
                "source": 11,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 11,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.0027310723949616777,
                "source": 11,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.18944570635227204,
                "source": 11,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.012611773677653785,
                "source": 11,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.5443705785564348,
                "source": 11,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0034785234688195837,
                "source": 11,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.22789524966769867,
                "source": 11,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.004938894347784571,
                "source": 11,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.024777450091849933,
                "source": 11,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.012660732914526266,
                "source": 11,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.15170516777820148,
                "source": 12,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.147979125807618,
                "source": 12,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.019911788070772273,
                "source": 12,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.5890720519725503,
                "source": 12,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.7175296133887175,
                "source": 12,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.7835569816181909,
                "source": 12,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 12,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 20
            },
            {
                "prerequisite": 0.3627549492373968,
                "similarity": 0.6976537812750893,
                "source": 21,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 12,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.6317451699214991,
                "source": 13,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.7785803225155303,
                "source": 13,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.0235802012219165,
                "source": 13,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.012545675649384917,
                "source": 13,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.1316367159837516,
                "source": 13,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.652206779135813,
                "source": 13,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.06099603760172451,
                "source": 13,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.02805234026941895,
                "source": 13,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.5954348240583427,
                "source": 13,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.026965860091609464,
                "source": 13,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.2797290012198885,
                "source": 13,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.01992657184833707,
                "source": 13,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 13,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 13,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 13,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 13,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 13,
                "target": 16
            },
            {
                "prerequisite": 1.8599143400518834,
                "similarity": 0.6338787206509366,
                "source": 17,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 13,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.05415193331494822,
                "source": 13,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 13,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.08864466067536775,
                "source": 13,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.5571389652253794,
                "source": 13,
                "target": 22
            },
            {
                "prerequisite": 0.2819808109170519,
                "similarity": 0.7670493606727065,
                "source": 13,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.0625926903869619,
                "source": 13,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.11290529431357017,
                "source": 13,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 13,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.16030575182793658,
                "source": 13,
                "target": 27
            },
            {
                "prerequisite": 0.42588750644636697,
                "similarity": 0.8042220557187817,
                "source": 13,
                "target": 28
            },
            {
                "prerequisite": 0.5688071765375877,
                "similarity": 0.6353693455597001,
                "source": 13,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.8205877741335885,
                "source": 14,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.011208622423944659,
                "source": 14,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.062139599733103394,
                "source": 14,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.1159009094419806,
                "source": 14,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.8386592544334106,
                "source": 14,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 14,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.17993041375408328,
                "source": 14,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.27173759600573694,
                "source": 14,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 14,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.05799988834841276,
                "source": 15,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.07068264849688022,
                "source": 15,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.14065774019325278,
                "source": 15,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.6695277847117147,
                "source": 15,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.015381890191157935,
                "source": 15,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.08684361472604687,
                "source": 15,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.6263274036425202,
                "source": 15,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.19496381338572433,
                "source": 15,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.07335223164480609,
                "source": 15,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.023366739793566807,
                "source": 15,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.9999999999999999,
                "source": 15,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.4550503643811611,
                "source": 15,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.33352088486645215,
                "source": 15,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.11291831001982493,
                "source": 15,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.014878776617687068,
                "source": 15,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 15,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.11691101657644087,
                "source": 16,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.19236647377182992,
                "source": 16,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.058265689984203534,
                "source": 16,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.9622659296018119,
                "source": 16,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.0338026104254994,
                "source": 16,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.11712555236871876,
                "source": 16,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.9758888477162637,
                "source": 16,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.10610699671703082,
                "source": 16,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.12033881435737523,
                "source": 16,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.46461006919620323,
                "source": 16,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.4550503643811611,
                "source": 16,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 1.0000000000000002,
                "source": 16,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 19
            },
            {
                "prerequisite": 4.824374115153655,
                "similarity": 0.9912488499470178,
                "source": 16,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.046774981853937844,
                "source": 16,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.2958405620540029,
                "source": 16,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 16,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.3917380003873816,
                "source": 17,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.4558734951157828,
                "source": 17,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.12808677362683288,
                "source": 17,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.005556551441175929,
                "source": 17,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.630816099134789,
                "source": 17,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.39936834857221204,
                "source": 17,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.045025822723558706,
                "source": 17,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.020707569698201093,
                "source": 17,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.35926178622530575,
                "source": 17,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.650836550783718,
                "source": 17,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.5453049672215912,
                "source": 17,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.01470932091343117,
                "source": 17,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 17,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.6338787206509366,
                "source": 17,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 17,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 17,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 17,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.9999999999999999,
                "source": 17,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 17,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.03997366788802518,
                "source": 17,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 17,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.06543537799980437,
                "source": 17,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.2467600316376843,
                "source": 17,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.4605997218035826,
                "source": 17,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.04620443379545467,
                "source": 17,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0833440001383025,
                "source": 17,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 17,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.1183338893339426,
                "source": 17,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.5936575740806161,
                "source": 17,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.40274710790420554,
                "source": 17,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.015213115532121586,
                "source": 18,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.3120691134217232,
                "source": 18,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.015666801782339035,
                "source": 18,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.37406971573634135,
                "source": 18,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.05935257387648912,
                "source": 18,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.09596892127190002,
                "source": 18,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.5555515072398343,
                "source": 18,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.10501331030243052,
                "source": 18,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 18,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.1145735646923532,
                "source": 18,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.06720220342386002,
                "source": 18,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.19242086930492985,
                "source": 18,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.11535550285145087,
                "source": 18,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.11305722192651856,
                "source": 18,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 18,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.0317399156996447,
                "source": 19,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.07212053593959301,
                "source": 19,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.29099040719913766,
                "source": 19,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.062057475136685164,
                "source": 19,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.5103223073679951,
                "source": 19,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.03133379947241487,
                "source": 19,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.0051069738128681425,
                "source": 19,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.6008663300671946,
                "source": 19,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.02709122121099447,
                "source": 19,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.5072181841881287,
                "source": 19,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.2627332272172359,
                "source": 19,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.15256868519627115,
                "source": 19,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 19,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.05415193331494822,
                "source": 19,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.17993041375408328,
                "source": 19,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 19,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 19,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.03997366788802518,
                "source": 19,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.1145735646923532,
                "source": 19,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 19,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 19,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.07727822275679501,
                "source": 19,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 19,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.03427342808253901,
                "source": 19,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.005240655676199865,
                "source": 19,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.009453144893747512,
                "source": 19,
                "target": 25
            },
            {
                "prerequisite": 2.694486519500092,
                "similarity": 0.9326266033250636,
                "source": 19,
                "target": 26
            },
            {
                "prerequisite": 5.22851504558078,
                "similarity": 0.8795475406848325,
                "source": 19,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0673345538460138,
                "source": 19,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.03440647843111117,
                "source": 19,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.11517641381972245,
                "source": 20,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.19318152429927504,
                "source": 20,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.040834607919994374,
                "source": 20,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.919504441979933,
                "source": 20,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.03350679870948335,
                "source": 20,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.11112762512214411,
                "source": 20,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.9403313397033066,
                "source": 20,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.08343398956311505,
                "source": 20,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.11652955092762256,
                "source": 20,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.4884221747769222,
                "source": 20,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.33352088486645215,
                "source": 20,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.9912488499470178,
                "source": 20,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 1.0000000000000002,
                "source": 20,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.03278152279649028,
                "source": 20,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.3110029254329899,
                "source": 20,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 20,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.6565742375807929,
                "source": 21,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.49377893259214145,
                "source": 21,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.10970985016517756,
                "source": 21,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 21,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.13418361611579724,
                "source": 21,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.7621465888284739,
                "source": 21,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.00835992240732649,
                "source": 21,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.6129950935808289,
                "source": 21,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.5909987925335677,
                "source": 21,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.05731358782188207,
                "source": 21,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.11050919587361535,
                "source": 21,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.0027310723949616777,
                "source": 21,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.6976537812750893,
                "source": 21,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.08864466067536775,
                "source": 21,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 21,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 21,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 21,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.06543537799980437,
                "source": 21,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 21,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.07727822275679501,
                "source": 21,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 21,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 1.0000000000000002,
                "source": 21,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 21,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.46612963916818806,
                "source": 21,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.008578754546607108,
                "source": 21,
                "target": 24
            },
            {
                "prerequisite": 0.525525544673053,
                "similarity": 0.675174096072593,
                "source": 21,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.10239630527115023,
                "source": 21,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.021970995156770597,
                "source": 21,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.11022411042450295,
                "source": 21,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.5708434333373407,
                "source": 21,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.39850687728890927,
                "source": 22,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.6527836869500376,
                "source": 22,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.08501940463445036,
                "source": 22,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.03343783063663706,
                "source": 22,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.15602635748596044,
                "source": 22,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.4384312836594085,
                "source": 22,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.428809889515313,
                "source": 22,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.07720358292777645,
                "source": 22,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.18944570635227204,
                "source": 22,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.5571389652253794,
                "source": 22,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.2467600316376843,
                "source": 22,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.06720220342386002,
                "source": 22,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 22,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.5641922225180818,
                "source": 22,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.34713035326100894,
                "source": 22,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 22,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.35398901972105784,
                "source": 22,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.9564451235537577,
                "source": 23,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.9587270348263298,
                "source": 23,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.027554280616878302,
                "source": 23,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.012704501155746882,
                "source": 23,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.11810431754753048,
                "source": 23,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.7953143378514866,
                "source": 23,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.03860514630020554,
                "source": 23,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.0177546729713054,
                "source": 23,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.480098500121797,
                "source": 23,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.061020287344591376,
                "source": 23,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.17704394319867844,
                "source": 23,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.012611773677653785,
                "source": 23,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 23,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.7670493606727065,
                "source": 23,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 23,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 23,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 23,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.4605997218035826,
                "source": 23,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 23,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.03427342808253901,
                "source": 23,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 23,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.46612963916818806,
                "source": 23,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.5641922225180818,
                "source": 23,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 23,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.039615687587611685,
                "source": 23,
                "target": 24
            },
            {
                "prerequisite": 0.6178146714605373,
                "similarity": 0.6807423655289341,
                "source": 25,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.09457083817258641,
                "source": 23,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.1014594922130969,
                "source": 23,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.5090020817679777,
                "source": 23,
                "target": 28
            },
            {
                "prerequisite": 0.32000813486502455,
                "similarity": 0.9625595475908143,
                "source": 23,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.036687272174412325,
                "source": 24,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.08757670373068235,
                "source": 24,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.22238698664100592,
                "source": 24,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.03908347012048692,
                "source": 24,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.17903612166879782,
                "source": 24,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.036217853896688516,
                "source": 24,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.00590300680169693,
                "source": 24,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.0027148182394263433,
                "source": 24,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.03131397750108367,
                "source": 24,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.17972817508140698,
                "source": 24,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.027071302690426003,
                "source": 24,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.5443705785564348,
                "source": 24,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 24,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0625926903869619,
                "source": 24,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 24,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 24,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 24,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.04620443379545467,
                "source": 24,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.19242086930492985,
                "source": 24,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.005240655676199865,
                "source": 24,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 24,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.008578754546607108,
                "source": 24,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.34713035326100894,
                "source": 24,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.039615687587611685,
                "source": 24,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.9999999999999999,
                "source": 24,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.010926623211697859,
                "source": 24,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 24,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.015513892059190017,
                "source": 24,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.07783010916185212,
                "source": 24,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.03976947672798491,
                "source": 24,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.8073456442237346,
                "source": 25,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.569388848755368,
                "source": 25,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.02046394922900335,
                "source": 25,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 25,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.03119493603637454,
                "source": 25,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.5109501493052815,
                "source": 25,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.010647900196656618,
                "source": 25,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.004897015137635424,
                "source": 25,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.056484452482087534,
                "source": 25,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.06794237961368646,
                "source": 25,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.04883147503036491,
                "source": 25,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.0034785234688195837,
                "source": 25,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 25,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.11290529431357017,
                "source": 25,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 25,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 25,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 25,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.0833440001383025,
                "source": 25,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 25,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.009453144893747512,
                "source": 25,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 25,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.675174096072593,
                "source": 25,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 25,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.6807423655289341,
                "source": 25,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.010926623211697859,
                "source": 25,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 1.0000000000000002,
                "source": 25,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.15215730285061158,
                "source": 25,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.027984107058875805,
                "source": 25,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.1403906962146915,
                "source": 25,
                "target": 28
            },
            {
                "prerequisite": 0.2628350151450211,
                "similarity": 0.8362971408639664,
                "source": 29,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.12106481764813214,
                "source": 26,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.1261523194865118,
                "source": 26,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.26676482549116354,
                "source": 26,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.13426096840066376,
                "source": 26,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.39290943451099664,
                "source": 26,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.07852278248616515,
                "source": 26,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.06670841921717315,
                "source": 26,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.49659989292150963,
                "source": 26,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.007777395854120164,
                "source": 26,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.5159430350044352,
                "source": 26,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.15216796091990706,
                "source": 26,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.22789524966769867,
                "source": 26,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 26,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 26,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.27173759600573694,
                "source": 26,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.11291831001982493,
                "source": 26,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.046774981853937844,
                "source": 26,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 26,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.11535550285145087,
                "source": 26,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.9326266033250636,
                "source": 26,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.03278152279649028,
                "source": 26,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.10239630527115023,
                "source": 26,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 26,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.09457083817258641,
                "source": 26,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 26,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.15215730285061158,
                "source": 26,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 1.0000000000000002,
                "source": 26,
                "target": 26
            },
            {
                "prerequisite": 0.014104491760100535,
                "similarity": 0.8720368382617105,
                "source": 27,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 26,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.11867245581479016,
                "source": 26,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.12782177560168304,
                "source": 27,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.19275782411368864,
                "source": 27,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.029278592118930746,
                "source": 27,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.31093126806923643,
                "source": 27,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.4052406135113653,
                "source": 27,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.12234194962696042,
                "source": 27,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.2763034949215048,
                "source": 27,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.4648722642192295,
                "source": 27,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.11299147846019698,
                "source": 27,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.4692467758201001,
                "source": 27,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.3843177625908729,
                "source": 27,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.004938894347784571,
                "source": 27,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 27,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.16030575182793658,
                "source": 27,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 27,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.014878776617687068,
                "source": 27,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.2958405620540029,
                "source": 27,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.1183338893339426,
                "source": 27,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.11305722192651856,
                "source": 27,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.8795475406848325,
                "source": 27,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.3110029254329899,
                "source": 27,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.021970995156770597,
                "source": 27,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 27,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.1014594922130969,
                "source": 27,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.015513892059190017,
                "source": 27,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.027984107058875805,
                "source": 27,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.8720368382617105,
                "source": 27,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 1.0000000000000002,
                "source": 27,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.1993302107148276,
                "source": 27,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.10185336062837175,
                "source": 27,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.4713763422600251,
                "source": 28,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.4675920332210977,
                "source": 28,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.02303136689482748,
                "source": 28,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 28,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.08808560522014501,
                "source": 28,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.46534502246902204,
                "source": 28,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.0758447709410415,
                "source": 28,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.03488133665315469,
                "source": 28,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.402337576527928,
                "source": 28,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.02168653943709922,
                "source": 28,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.3478255778124337,
                "source": 28,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.024777450091849933,
                "source": 28,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 28,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.8042220557187817,
                "source": 28,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 28,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 28,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 28,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.5936575740806161,
                "source": 28,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 28,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.0673345538460138,
                "source": 28,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 28,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.11022411042450295,
                "source": 28,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 28,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.5090020817679777,
                "source": 28,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.07783010916185212,
                "source": 28,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.1403906962146915,
                "source": 28,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 28,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.1993302107148276,
                "source": 28,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 1.0,
                "source": 28,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.510978041226719,
                "source": 28,
                "target": 29
            },
            {
                "prerequisite": null,
                "similarity": 0.9794532906881677,
                "source": 29,
                "target": 0
            },
            {
                "prerequisite": null,
                "similarity": 0.887571923904389,
                "source": 29,
                "target": 1
            },
            {
                "prerequisite": null,
                "similarity": 0.028420813861484207,
                "source": 29,
                "target": 2
            },
            {
                "prerequisite": null,
                "similarity": 0.00797113772695396,
                "source": 29,
                "target": 3
            },
            {
                "prerequisite": null,
                "similarity": 0.09832292544077537,
                "source": 29,
                "target": 4
            },
            {
                "prerequisite": null,
                "similarity": 0.7619458328940574,
                "source": 29,
                "target": 5
            },
            {
                "prerequisite": null,
                "similarity": 0.03875501249274256,
                "source": 29,
                "target": 6
            },
            {
                "prerequisite": null,
                "similarity": 0.01782359707839874,
                "source": 29,
                "target": 7
            },
            {
                "prerequisite": null,
                "similarity": 0.37832103448540433,
                "source": 29,
                "target": 8
            },
            {
                "prerequisite": null,
                "similarity": 0.06774919033276255,
                "source": 29,
                "target": 9
            },
            {
                "prerequisite": null,
                "similarity": 0.17773123243914907,
                "source": 29,
                "target": 10
            },
            {
                "prerequisite": null,
                "similarity": 0.012660732914526266,
                "source": 29,
                "target": 11
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 29,
                "target": 12
            },
            {
                "prerequisite": null,
                "similarity": 0.6353693455597001,
                "source": 29,
                "target": 13
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 29,
                "target": 14
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 29,
                "target": 15
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 29,
                "target": 16
            },
            {
                "prerequisite": null,
                "similarity": 0.40274710790420554,
                "source": 29,
                "target": 17
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 29,
                "target": 18
            },
            {
                "prerequisite": null,
                "similarity": 0.03440647843111117,
                "source": 29,
                "target": 19
            },
            {
                "prerequisite": null,
                "similarity": 0.0,
                "source": 29,
                "target": 20
            },
            {
                "prerequisite": null,
                "similarity": 0.5708434333373407,
                "source": 29,
                "target": 21
            },
            {
                "prerequisite": null,
                "similarity": 0.35398901972105784,
                "source": 29,
                "target": 22
            },
            {
                "prerequisite": null,
                "similarity": 0.9625595475908143,
                "source": 29,
                "target": 23
            },
            {
                "prerequisite": null,
                "similarity": 0.03976947672798491,
                "source": 29,
                "target": 24
            },
            {
                "prerequisite": null,
                "similarity": 0.8362971408639664,
                "source": 29,
                "target": 25
            },
            {
                "prerequisite": null,
                "similarity": 0.11867245581479016,
                "source": 29,
                "target": 26
            },
            {
                "prerequisite": null,
                "similarity": 0.10185336062837175,
                "source": 29,
                "target": 27
            },
            {
                "prerequisite": null,
                "similarity": 0.510978041226719,
                "source": 29,
                "target": 28
            },
            {
                "prerequisite": null,
                "similarity": 0.9999999999999998,
                "source": 29,
                "target": 29
            }
        ],
        "nodes": [
            {
                "count": 0.28831475000882834,
                "group": 1,
                "index": 0,
                "name": "heap",
                "videos_id": [
                    "t0Cq6tVNRBA"
                ]
            },
            {
                "count": 0.2622208637123659,
                "group": 1,
                "index": 1,
                "name": "language",
                "videos_id": [
                    "z2pjGiaDUPo",
                    "92S4zgXN17o",
                    "jc1t0KFsOcs"
                ]
            },
            {
                "count": 0.1659893391883272,
                "group": 1,
                "index": 2,
                "name": "graph",
                "videos_id": [
                    "z2pjGiaDUPo",
                    "CzZ6KodVKJo",
                    "92S4zgXN17o",
                    "c8P9kB1eun4",
                    "gXgEDyodOJU"
                ]
            },
            {
                "count": 0.14016505757503245,
                "group": 1,
                "index": 3,
                "name": "key",
                "videos_id": [
                    "R-HLU9Fl5ug"
                ]
            },
            {
                "count": 0.11696129392830322,
                "group": 1,
                "index": 4,
                "name": "node",
                "videos_id": [
                    "t0Cq6tVNRBA",
                    "CzZ6KodVKJo",
                    "qH6yxkw0u78",
                    "c8P9kB1eun4",
                    "gXgEDyodOJU",
                    "oSWTXtMglKE"
                ]
            },
            {
                "count": 0.11613047952040793,
                "group": 1,
                "index": 5,
                "name": "type",
                "videos_id": [
                    "qH6yxkw0u78",
                    "92S4zgXN17o"
                ]
            },
            {
                "count": 0.10749267525855942,
                "group": 1,
                "index": 6,
                "name": "vertex",
                "videos_id": [
                    "c8P9kB1eun4",
                    "gXgEDyodOJU"
                ]
            },
            {
                "count": 0.10034772446828201,
                "group": 1,
                "index": 7,
                "name": "edge",
                "videos_id": [
                    "qH6yxkw0u78",
                    "c8P9kB1eun4",
                    "gXgEDyodOJU"
                ]
            },
            {
                "count": 0.09563686548739478,
                "group": 1,
                "index": 8,
                "name": "mean",
                "videos_id": [
                    "bum_19loj9A",
                    "jc1t0KFsOcs"
                ]
            },
            {
                "count": 0.0801299328089822,
                "group": 1,
                "index": 9,
                "name": "dictionary",
                "videos_id": [
                    "R-HLU9Fl5ug",
                    "qH6yxkw0u78",
                    "92S4zgXN17o"
                ]
            },
            {
                "count": 0.06820061340654102,
                "group": 1,
                "index": 10,
                "name": "group",
                "videos_id": [
                    "92S4zgXN17o"
                ]
            },
            {
                "count": 0.06555752876152061,
                "group": 1,
                "index": 11,
                "name": "algorithm",
                "videos_id": [
                    "z2pjGiaDUPo",
                    "bum_19loj9A"
                ]
            },
            {
                "count": 0.06552607954746098,
                "group": 1,
                "index": 12,
                "name": "heapify",
                "videos_id": [
                    "t0Cq6tVNRBA"
                ]
            },
            {
                "count": 0.06444300385246163,
                "group": 1,
                "index": 13,
                "name": "matrix",
                "videos_id": [
                    "c8P9kB1eun4"
                ]
            },
            {
                "count": 0.06393700557865156,
                "group": 1,
                "index": 14,
                "name": "binary search",
                "videos_id": [
                    "qH6yxkw0u78",
                    "oSWTXtMglKE"
                ]
            },
            {
                "count": 0.060649723579730884,
                "group": 1,
                "index": 15,
                "name": "recursion",
                "videos_id": [
                    "F1F2imiOJfk",
                    "qH6yxkw0u78",
                    "oSWTXtMglKE"
                ]
            },
            {
                "count": 0.06036733897050956,
                "group": 1,
                "index": 16,
                "name": "list",
                "videos_id": [
                    "z2pjGiaDUPo",
                    "bum_19loj9A",
                    "R-HLU9Fl5ug",
                    "F1F2imiOJfk",
                    "CzZ6KodVKJo",
                    "qH6yxkw0u78",
                    "92S4zgXN17o",
                    "jc1t0KFsOcs",
                    "c8P9kB1eun4",
                    "oSWTXtMglKE"
                ]
            },
            {
                "count": 0.06024381866139805,
                "group": 1,
                "index": 17,
                "name": "operations",
                "videos_id": [
                    "z2pjGiaDUPo",
                    "bum_19loj9A",
                    "R-HLU9Fl5ug",
                    "F1F2imiOJfk",
                    "CzZ6KodVKJo",
                    "qH6yxkw0u78",
                    "92S4zgXN17o",
                    "oSWTXtMglKE"
                ]
            },
            {
                "count": 0.05912097139220768,
                "group": 1,
                "index": 18,
                "name": "undirected graph",
                "videos_id": [
                    "c8P9kB1eun4",
                    "gXgEDyodOJU"
                ]
            },
            {
                "count": 0.05676821373862508,
                "group": 1,
                "index": 19,
                "name": "tree",
                "videos_id": [
                    "z2pjGiaDUPo",
                    "t0Cq6tVNRBA",
                    "CzZ6KodVKJo",
                    "qH6yxkw0u78",
                    "92S4zgXN17o",
                    "c8P9kB1eun4",
                    "gXgEDyodOJU",
                    "oSWTXtMglKE"
                ]
            },
            {
                "count": 0.053900484789040484,
                "group": 1,
                "index": 20,
                "name": "location",
                "videos_id": [
                    "bum_19loj9A"
                ]
            },
            {
                "count": 0.05295345113574562,
                "group": 1,
                "index": 21,
                "name": "string",
                "videos_id": [
                    "z2pjGiaDUPo",
                    "bum_19loj9A",
                    "R-HLU9Fl5ug",
                    "qH6yxkw0u78"
                ]
            },
            {
                "count": 0.051985477354055044,
                "group": 1,
                "index": 22,
                "name": "form",
                "videos_id": [
                    "CzZ6KodVKJo",
                    "qH6yxkw0u78",
                    "92S4zgXN17o"
                ]
            },
            {
                "count": 0.04566928969903683,
                "group": 1,
                "index": 23,
                "name": "binary search tree",
                "videos_id": [
                    "qH6yxkw0u78",
                    "oSWTXtMglKE"
                ]
            },
            {
                "count": 0.04566928969903683,
                "group": 1,
                "index": 24,
                "name": "search tree",
                "videos_id": [
                    "qH6yxkw0u78",
                    "oSWTXtMglKE"
                ]
            },
            {
                "count": 0.04546707560436068,
                "group": 1,
                "index": 25,
                "name": "work",
                "videos_id": [
                    "92S4zgXN17o"
                ]
            },
            {
                "count": 0.04466556904631074,
                "group": 1,
                "index": 26,
                "name": "level",
                "videos_id": [
                    "CzZ6KodVKJo",
                    "92S4zgXN17o"
                ]
            },
            {
                "count": 0.04434072854415576,
                "group": 1,
                "index": 27,
                "name": "directed graph",
                "videos_id": [
                    "c8P9kB1eun4",
                    "gXgEDyodOJU"
                ]
            },
            {
                "count": 0.04426264976053656,
                "group": 1,
                "index": 28,
                "name": "functions",
                "videos_id": [
                    "R-HLU9Fl5ug"
                ]
            },
            {
                "count": 0.04230775833828988,
                "group": 1,
                "index": 29,
                "name": "height",
                "videos_id": [
                    "CzZ6KodVKJo",
                    "qH6yxkw0u78"
                ]
            }
        ]
    },
    "search_info": {
        "NumOfVideos": 13,
        "key": "data_structure_50",
        "similarity_threshold": 0.6,
        "time_delta": 8.933333333333334,
        "voclist_SelectMethod": 2
    },
    "videos_info": {
        "92S4zgXN17o": {
            "caption_exist": "T",
            "channel_id": "UClEEsT7DkdVO_fkrBw0OTrA",
            "channel_title": "mycodeschool",
            "concepts": [
                [
                    "list",
                    7
                ],
                [
                    "type",
                    7
                ],
                [
                    "data structure",
                    5
                ],
                [
                    "language",
                    4
                ],
                [
                    "form",
                    4
                ],
                [
                    "dictionary",
                    4
                ],
                [
                    "group",
                    3
                ],
                [
                    "operations",
                    3
                ],
                [
                    "work",
                    2
                ],
                [
                    "level",
                    1
                ],
                [
                    "block",
                    1
                ],
                [
                    "graph",
                    1
                ],
                [
                    "power",
                    1
                ],
                [
                    "tree",
                    1
                ],
                [
                    "queue",
                    1
                ],
                [
                    "linked list",
                    1
                ],
                [
                    "sorted list",
                    1
                ],
                [
                    "element",
                    1
                ],
                [
                    "two-dimensional",
                    1
                ]
            ],
            "description": "See complete series of videos in data structures here:\nhttp://www.youtube.com/playlist?list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&feature=view_all\nIn this lesson, we will introduce you to data structures as ways to store and organize data in computer.\n\nFeel free to drop your question, feedback or suggestion in comments section. \n\nYou may also like us on facebook:\nhttp://www.facebook.com/MyCodeSchool\n\nAbout us:\nhttp://blog.mycodeschool.com/2013/01/who-are-you-mycodeschool.html",
            "dislikeCount": "95",
            "duration": "PT6M34S",
            "likeCount": "4390",
            "published_time": "2013-03-25T23:48:32.000Z",
            "tags": [
                "Technology",
                "course",
                "Classes",
                "interview",
                "cs",
                "skills training",
                "amazon",
                "algorithms",
                "clrs",
                "School",
                "compter science",
                "Software",
                "companies",
                "class",
                "mentor",
                "coremen",
                "\\code school\\",
                "University",
                "enterprise",
                "Student",
                "teacher",
                "teaching",
                "Campus",
                "College",
                "Community",
                "lecture",
                "Degree",
                "google",
                "data structures",
                "data",
                "\\my code school\\",
                "Education",
                "microsoft",
                "job ready",
                "facebook",
                "yt:cc=on"
            ],
            "thumbnail": "https://i.ytimg.com/vi/92S4zgXN17o/hqdefault.jpg",
            "title": "Introduction to data structures",
            "transcript": "  in this lesson and in this series of lessons we will introduce you to the concept of data structures data structure is the most fundamental and building block concept in computer science and good knowledge of data structures is a must to design and develop efficient software systems ok so let's get started we deal with data all the time and how we store organize and group our data together matters let's pick up some examples from our day to day life we were organizing data in a particular structure helps us we are able to search a word quickly and efficiently in a language dictionary because the words in the dictionary are sorted what if the words in the dictionary were not sorted it would be impractical and impossible to search for a word among millions of words so dictionary is organized as a sorted list of words let's pick up another example if we have something like a city map the data like position of landmark and road network connections all this data is organized in the form of geometries we show the map data in the form of these geometries on a two-dimensional plane so map data needs to be structured like this so that we have scales and directions and we are effectively able to search for a landmark and and get route from one place to another and I'll pick one more example for something like daily cash in and cash out statement of a business what we also call a cash book in accounts it makes most sense to organize and store the data in the form of a tabular schema it is very easy to aggregate data and extract information if the data is organized in these columns in these tables so different kind of structures are needed to organize different kind of data now computers work with all kind of data computers work with text images videos relational data geospatial data and pretty much any kind of data that we have on this planet how we store group data income in computers matters because computers deal with really really large data and even with the computational power of machines if we do not use the right kind of structures the right kind of logical structures then our software systems will not be formal definition of a data structure would be that a data structure is a way to store and organize data in a computer so that the data can be used efficiently when we study data structures as ways to store and organize data we study them in two ways so I'll say that we talk about data structures as one we talk about them as mathematical and logical models when we talk about them as mathematical and logical models we just look at an abstract view of them we just look at from a high level what all features and what all operations and define that particular data structure example of abstract view from real world can be something like the abstract view of a device named television can be that it is an electrical device that can be turned on and off it can receive signals for satellite programs and play the audio video of the program and as long as I have a device like this I do not bother how circuits are embedded to create this device or which company makes this device so this is an abstract view so when we study data structures or or as mathematical or logical models we just define their abstract view or in other words we have a term for this we define them as abstract data types an example of abstract data type can be I want to define something called a list that should be able to store a group of elements of a particular data type and we should be able to treat the elements by their position in the list and we should be also able to modify element at a particular position in the list I would say store a given number of elements of any data type so we are just defining a model now we can implement this in a programming language in a number of ways so this is a definition of an abstract data type we also call abstract data and data type as ADT and if you see all the high-level languages already have a concrete implementation of such an ADT in the form of arrays so arrays give us all these functionalities so arrays are data types which are concrete implementation so the second way of talking about data structures is talking about their implementation so implementations would be some concrete types and not an abstract data type we can implement the same adt in multiple ways in the same language for example in C or C++ we can implement this list ADT as a data structure named linked list and if you have not heard about it we will be talking about them a lot we will be talking about linked lists a lot in the coming lessons okay so let's define an abstract data type formally because this is one term that we will encounter quite often abstract data types are entities that are definitions of data and operation but do not have implementations so they do not have any implementation details we will be talking about a lot of data structures in this course we will be talking about them as abstract data types and we will also be looking at how to implement them some of the data structures that we will talk about are arrays linked lists stack queue tree graph and the list goes on there are many more to study so when we will study these data structures we will study their logical view will study what operations are available to us with these data structures will study the cost of these operations mostly in terms of time and then definitely we will study the implementation in a programming language so we will be studying all these data structures in the coming lessons and this is all for this introductory lesson thanks for watching",
            "videoid": "92S4zgXN17o",
            "viewCount": "1345290"
        },
        "CzZ6KodVKJo": {
            "caption_exist": "T",
            "channel_id": "UCiV37YIYars6msmIQXopIeQ",
            "channel_title": "Computer Education For all",
            "concepts": [
                [
                    "tree",
                    49
                ],
                [
                    "node",
                    36
                ],
                [
                    "root",
                    17
                ],
                [
                    "data structure",
                    11
                ],
                [
                    "level",
                    10
                ],
                [
                    "parent",
                    10
                ],
                [
                    "height",
                    7
                ],
                [
                    "subtree",
                    4
                ],
                [
                    "range",
                    4
                ],
                [
                    "implies",
                    3
                ],
                [
                    "system",
                    3
                ],
                [
                    "leaf",
                    3
                ],
                [
                    "hierarchy",
                    3
                ],
                [
                    "forest",
                    3
                ],
                [
                    "binary tree",
                    2
                ],
                [
                    "graph",
                    2
                ],
                [
                    "ordered tree",
                    2
                ],
                [
                    "queue",
                    1
                ],
                [
                    "element",
                    1
                ],
                [
                    "subset",
                    1
                ],
                [
                    "ancestor",
                    1
                ],
                [
                    "list",
                    1
                ],
                [
                    "theory",
                    1
                ],
                [
                    "energy",
                    1
                ],
                [
                    "classification",
                    1
                ],
                [
                    "natural",
                    1
                ],
                [
                    "window",
                    1
                ],
                [
                    "head",
                    1
                ],
                [
                    "form",
                    1
                ],
                [
                    "operations",
                    1
                ]
            ],
            "description": "Computer Education for all provides lectures series on types of trees in data structure which covers Introduction to Trees\nDefinitions and Terminology\nClassification of Trees\nApplication of Trees\nData Structures and Applications\nTypes of Trees in Data Structure\nTrees in data structure pdf\nTrees in data structure using c\nTrees in data structure tutorial\nTrees in data structure ppt\nBinary search tree in data structure\nBinary trees in data structure\nTree traversal in data structure\nWhat is Tree in Data Structure \nHave a look this helpful video, for more please subscribe \nhttps://www.youtube.com/channel/UCiV37YIYars6msmIQXopIeQ",
            "dislikeCount": "4",
            "duration": "PT13M21S",
            "likeCount": "24",
            "published_time": "2016-03-30T03:00:01.000Z",
            "tags": [
                "Computer",
                "Education",
                "for",
                "All",
                "Introduction to Trees",
                "Definitions and Terminology",
                "Classification of Trees",
                "Application of Trees",
                "Data Structures and Applications",
                "Types of Trees in Data Structure",
                "Trees in data structure pdf",
                "Trees in data structure using c",
                "Trees in data structure tutorial",
                "Trees in data structure ppt",
                "Binary search tree in data structure",
                "Binary trees in data structure",
                "Tree traversal in data structure",
                "types of trees",
                "what is tree in data structure"
            ],
            "thumbnail": "https://i.ytimg.com/vi/CzZ6KodVKJo/hqdefault.jpg",
            "title": "Types of Trees in Data Structures and Algorithms",
            "transcript": "  into trees a tree is a data structure in which data elements have hierarchical relationship there are several ways of describing the internal structure of a tree formally we can define a tree data structure as a collection of data elements called nodes such that the collection has a special node called root which provides an entry point to the tree data structure the nodes are connected together with edges or paths there is exactly one path from the root to any node in the tree a tree data structure is often depicted by means of a diagram unlike a natural tree a tree data structure is shown to grow from top to bottom with root at the top and leaves at the lowest level a node is represented by a circle oval or rectangle it is usually labeled with the data value contained in the node the edges are shown by the slanted lines by convention tree is portrayed from top to bottom the direction of edges is therefore emitted figure shows an example of three data structure in this structure a is root node II M n g h i j k l are leaves all other nodes are the internal nodes basic definition and terminology the structure and properties of a tree structure are described by using a special vocabulary which is borrowed from mathematical graph theory and family trees most algorithms for trees use this terminology we therefore have a closer look at these terms payment node in the tree hierarchy and no directly above a given node is called parent node C is the parent node of H I and J the only exception is the root node which has no parent chide node a node which is directly below a parent node is called child node or simply a child for example C is the child of fruit and hij are children of C siblings all children which have common parent are collectively known as thus H I J are siblings of C likewise b c and d are siblings of if all siblings appear in definite order say in alphabetical order the tree is called ordered tree the tree shown in this figure is in fact an ordered tree ancestors we call that in a tree structure a node has a unique path to the root node or nodes which appear on the path from a given node to the root node are called ancestors of the given node for example ancestor of M r.fp and ascendant a descendant is a child of a node or a descendent of the child all of the descendants of a node n are called a subtree rooted at n in figure the subtree rooted at b consists of nodes b e f g m and n a subtree may comprise a single leaf node as we shall see later the notion of subtree is of great help in partial processing of data contained in a subset of nodes level of tree obviously the nodes of a tree are organized at different levels by convention the root node is at level 0 the children of fruit are at level 1 the children of children of fruit are at level 2 and so on notice that in Figure the nodes B C and D are at level 1 and nodes e f g h i j k and l are at level 2 the leaves m n are at level 3 height of a tree the maximum level of a node in a tree is called height of a tree thus the tree structure in figure has height 3 as we shall see later the height of a tree plays a crucial role in determining the performance of search algorithms a tree with the shorter height can be searched faster than an equivalent tree with greater height containing the same data elements from the preceding discussion we conclude that a tree data structure has two important characteristics which distinguish it from other data structures first unlike a stack and a queue a tree is a nonlinear structure this implies that a data element in tree has more than one successor which can be depicted in hierarchical fashion in two dimensions second the defining property of a tree is the existence of a unique path from root to any of the three nodes this also implies that any node in the tree has a unique parent except the root node if there is more than one path are more than one parent to a node or there is no path then the structure is not a valid tree data structure it belongs to the data structure called graph figure shows an illustration in which node E has two parent B and C also note that G has two parts to the root namely g e b a and g e CA thus we conclude that data structure is not a tree forest we have seen that a node which has no path to the root of a tree is not considered part of the tree this situation leads to the notion of a forest which is defined as a set of disjoint tree structure the disjoint property implies that there is no explicit part linking one tree to another for example if we remove the root node we have a set of three disjoint trees shown in figure here the forest is a set of three trees classification of trees the three structures are classified on the basis of maximum number of children permissible to be attached to a parent node if in a tree a parent as zero one two and children it is called Emery or anway three a ternary tree for example is the one in which each node can have up to three children if an energy tree contains nodes in specific order the tree is called multi-way 3 in this case each node contains a set of keys which determined range of values held by child nodes for example in eternity tree a node may contain keys a H and T to imply that the fourth child would contain a character in the range A to G second child would contain character in range h2s and third would contain characters in range T to Z monkey ways trees are frequently used in modern database management system to facilitate rapid searching of indexed records in order to improve the performance of search operations the height of tree is capped to be minimum balancing the levels of sub trees the resulting trees are often called as balanced trees the term b3 is often used to describe such trees the plus tree is a variant of b3 in which all the leaves are linked by pointers to facilitate sequential searching in addition to normal random searching indeed B and B plus trees are cornerstones of all modern data file systems and database management system simpler versions of B tree are used in some applications - such variants are known as two three three and two three four tree the former contains two to three nodes per child and later two to four nodes per child figure shows a small two three three a binary tree is the simplest form of each node can have at most two child nodes we shall study in great detail the binary tree structure in the subsequent section of the unit for now let us briefly look at some of the applications of binary trees application of trees many hierarchical data structures analogues to trees are commonly encountered in our daily lives a familiar example is the organization chart of a large department or company in which the hierarchy of the organization is shown the root node shows the head or CEO the children of fruit are usually the senior management which are followed by middle or to executives the line or operation level staffs are generally exhibited at the leaf nodes by systematically scanning the trees from top to bottom we can list all positions at different levels in the another common example of three data structure is table of contents of a book or a document as shown in Figure the title of book is at the root the book is generally organized into several chapters each chapter may be further organized into sections and the sections may in turn be divided into subsections using one of the three algorithms we can print the table of contents of the book with chapters sections and subsections appropriately indented as shown perhaps the most common example of three familiar to computer user is the structure of filing system in operating systems such as yonyx window and Mac information and content of a set of files residing in the computer are organized in a hierarchy of directories and subdirectories as shown the root of the tree represents the root directory the data files are represented at leaf levels by traversing tree we can determine the contents of files in each sub directories and print their size you",
            "videoid": "CzZ6KodVKJo",
            "viewCount": "3640"
        },
        "DuDz6B4cqVc": {
            "caption_exist": "T",
            "channel_id": "UCX6b17PVsYBQ0ip5gyeme-Q",
            "channel_title": "CrashCourse",
            "concepts": [],
            "description": "Today we\u2019re going to talk about on how we organize the data we use on our devices. You might remember last episode we walked through some sorting algorithms, but skipped over how the information actually got there in the first place! And it is this ability to store and access information in a structured and meaningful way that is crucial to programming. From strings, pointers, and nodes, to heaps, trees, and stacks get ready for an ARRAY of new terminology and concepts.\n\nPs. Have you had the chance to play the Grace Hopper game we made in episode 12. Check it out here! http://thoughtcafe.ca/hopper/   \n\nProduced in collaboration with PBS Digital Studios: http://youtube.com/pbsdigitalstudios\n\nWant to know more about Carrie Anne?\nhttps://about.me/carrieannephilbin\n\nThe Latest from PBS Digital Studios: https://www.youtube.com/playlist?list=PL1mtdjDVOoOqJzeaJAV15Tq0tZ1vKj7ZV\n\nWant to find Crash Course elsewhere on the internet?\nFacebook - https://www.facebook.com/YouTubeCrash...\nTwitter - http://www.twitter.com/TheCrashCourse\nTumblr - http://thecrashcourse.tumblr.com \nSupport Crash Course on Patreon: http://patreon.com/crashcourse\n\nCC Kids: http://www.youtube.com/crashcoursekids",
            "dislikeCount": "92",
            "duration": "PT10M7S",
            "likeCount": "5250",
            "published_time": "2017-05-31T22:00:50.000Z",
            "tags": [
                "John Green",
                "Hank Green",
                "vlogbrothers",
                "Crash Course",
                "crashcourse",
                "education",
                "computer science",
                "computers",
                "compsci",
                "data structures",
                "arrays",
                "vectors",
                "index",
                "variables",
                "strings",
                "characters",
                "matrix",
                "struct",
                "pointer",
                "node",
                "fifo",
                "queue",
                "stacks",
                "trees",
                "lifo",
                "root",
                "children node",
                "parent node",
                "red-black trees",
                "heaps"
            ],
            "thumbnail": "https://i.ytimg.com/vi/DuDz6B4cqVc/hqdefault.jpg",
            "title": "Data Structures: Crash Course Computer Science #14",
            "transcript": " Hi, I'm Carrie Ann, and welcome to the intensive computer science lessons!  In the last episode, we discussed a few classical algorithms, such as ordering a list of numbers  And finding the shortest path in a graph.  What we did not talk about much about is how to store program data in a device memory  Computer  You do not want your data to be like John Green's bedroom in college, with eating and dressing  The leaves are scattered everywhere.  Instead, we want our data to be organized, that is, to be arranged, allowing things  Be easy to retrieve and read.  For this, computer scientists use data structure!  an introduction  We have previously provided one of the foundations of structured data, tables or so called lists  Radiology in some languages.  This is a series of values \u200b\u200bstored in memory.  So instead of just one value being saved to a variable, such as' j equals 5, we are  We can define a whole string of numbers, and save that in a tabular variable.  To be able to find a special value in this table, you must specify a serial number.  Almost all programming languages \u200b\u200bstart tables with a serial number of 0, and use as a general shape rectangular brackets  Set to use the table  So, for example, if we want to add values \u200b\u200bin the first and third positions of the table  'J', and save it to variable \"A\", we write a line of code like this.  How a table to be stored in this memory is very clear  Simply put, to say that the translator chose us in the 1000 site memory  The table contains 7 digits and is stored one by one in memory as you can see here  That is, when we write \"j\" with the serial number \"0\", the computer goes to location 1000 in memory with 0  Offset we get the value 5.  If we want to retrieve the \"J serial number 5\", our program goes for 1000 site in memory,  With a displacement of 5 degrees, which in this case we find value 4.  Easy to confuse number V in table with serial number 5.  They are different  Remember that the serial number number 5 is the sixth in the table because the first digit  Is the serial number holder.  Tables as data modifiers are numerous uses, always used and there are several applications  Which makes them do useful things.  For example, almost all programming languages \u200b\u200bare accompanied by prearranged instructions  Once you enter the table, you will receive a salary  So there is no need to write an algorithm from scratch.  Symbol strings are very similar to them, as they are tables of symbols such as letters, numbers  Punctuation marks, and other written symbols.  We talked in Episode 4 about how computers store characters  Most often, to store the string of symbols in memory, you can only put them between \"\".  Although it does not look like a table, but it does  Behind the scenes memory is so  Note that the string ends with zero in memory.  It is not a zero symbol, but the value is 0 in the binary system  This is called an empty symbol, symbolizing the end of the string in memory.  This is important because if you use an instruction such as \"Show Content\" that reveals a string of symbols  On the screen, it shows each character in the order starting from the first location in memory  But he needs to know when he stops!  On the other hand, it shows everything in memory on the basis that it is text  Zero Allows instructions for symbol strings to be defined when to stop  Because computers deal with text often, there are many special applications  By dealing with symbol strings  For example, many programming languages \u200b\u200bhave the function of merging symbol strings, or \"strcat\"  Which takes two strings, then copies the whole second and adds it to the end of the first  We can use tables to make single-dimensional lists, but sometimes you want to use  Two-dimensional data, such as the number grid in the scheduling program, or pixels  On the screen of your computer.  For this, we need matrices.  You can think of a matrix shape as a table of tables!  Even the 3x3 matrix is \u200b\u200breally a table of size 3, with each index storing a table of  Size 3.  We can select the matrix like that  In memory, are intertwined with each other  To access a value, you need to specify two indicators, such as \"J with serial number 2\" with the serial number  1 \"This determines for the computer that we are looking for an item in Table 2 at position 1  This gives us a value of 12  The good thing about matrices is that they are not limited in 3x3, but we can create them any  The size we want - we can also make it from any number of dimensions we want.  For example, we can create and access a five-dimensional matrix  That's right, you now know how to access a five-dimensional matrix - tell your friends!  So far, we've stored numbers and letters on our tables or matrices  But it is often helpful to store a set of variables with some  For example, you can store a bank account number in addition to the balance  Groups of such variables can be grouped together in a single register  Now we can create variables that are not just individual numbers but composite data  Structures are capable of storing several types of data together in one.  We can create tables for the records we know where they are automatically grouped together  in the memory.  If we use, for example, \"C with a serial number of 0\" we get all the records stored there, and  We can withdraw the specific account number and balance data we want  This is a table of trappings like any other table, which is created with a fixed size that you can not  Expand it to add more items.  Also, tables must be arranged in memory, making it difficult to add a new element in the middle  However, structured data structures can be used to build more complex data structures  Where we avoided these restrictions  Let's take a look at this structure that is called \"node\"  It stores a variable, such as a number, and also a pointer  The cursor is a special variable that refers to a location in memory and hence it is called,  Using this structure, lists can be created so that the structure is flexible  Many nodes can be stored.  This is done by having at the end of each node a handle for the next node in the list  Let's imagine we have three nodes reserved in memory, at locations 1000, 1002 and 1008.  May be distant from each other, because it was created at different times, and other data  They can be between them.  Therefore, you see that the first node contains the value 7, and the location is 1008 in the index  Next  This means that the next node in the bound list is located in memory location 1008.  By noting down the bound list, to the pro node, we see that it stores the value 112 and the index  To another node in place 1002.  Accordingly, we find the node containing the value 14 and the index return to the first  Node in place 1000.  And from it make the list bound to annular, but can also be terminated  Using the value of the cursor is 0 - the null value - that would indicate that we have reached  End menu.  When programmers use bound lists they rarely look at the values \u200b\u200bstored in the next of  Indicators.  Alternatively, they can use abstraction for linked lists, which look like this, which is  Much easier to imagine.  Unlike tables that need to be resized in advance, linked lists can be extensible or  Default.  For example, we can customize a new node in memory, and enter it into this list  By changing the following indicators.  Linked lists are easy to rearrange, expand, reverse, and so on.  This is very nice!  It is very useful for algorithms like sorting, which we talked about last week.  Because of this flexibility, many more complex data structures were built on top of the associated lists  The most famous are queues and stacks  Queue - Like the queue in the post office - the order is by arrival.  The person who was waiting longer, gets the service first  No matter how frustrating so that you just want to buy postage and person  Who in front of you seems to want to send 23 packages  However, regardless of this behavior is called first present departures first or FIFO  This is the first part.  It is not about 23 expulsion  Imagine our index, its name (Post Office Queue), which refers to the first node in  Our linked list  Once you finish the Hank service, we can read from your next sign, and update the index  \"Post Office Queue\" refers to the next person in the queue  We've successfully removed Hank from the list, it's gone, it's over  If we want to add a person to the list, this will be added to the string and we must pass each  The linked menu until we reach the end, then change the next cursor to point to  The new person.  With a small change, we are able to link menus as stacks, which are LIFO  That is, the last present, departing first  You can imagine like a bunch of pancakes .. Just as you bring them, you add all the time up  the group  When you want to eat one, take it from the top of the group  Tasty!  Instead of adding and removing, the data is compressed and dragged to and from the collection  Yes, those are the official terms!  If we update the structure of the node, it contains more than one index, ie two, for example, we can make trees  So that it has another data structure that is used in many algorithms  Again, it is rare for programmers to consider the values \u200b\u200bof indicators, rather than perception  Trees like this: The top knot is called the root node.  The contract that goes beyond the other contract is called children contract  As you would expect, the nodes that are above the children are called the mother contract.  Does this example mean Thomas Jefferson is Aaron Pour's father?  I'll leave it to your imagination to make a decision.  Finally, the contract that has no children where the tree ends is called a paper node  In this example, a contract can have two children, and for this reason, a structure  This data is called a binary tree.  You can easily get a tree with three, four, or any number of children with a modification  Data structure depending  You can also get a contract tree that uses the associated lists to store the nodes to which it refers  An important property in trees - whether in fact or in structuring data is that  There is a one-way path from roots to leaves.  It is strange that roots are associated with roots-related leaves,  Data that links randomly, which include things like repetitive instructions, we can use the graph  As a structure instead.  Do you remember our diagram of the cities associated with the ways in the previous episode?  They can be stored as a knot with many indicators, much like the tree but there is no concept  For roots and leaves, children and parents ...  Anything that can point to anything!  This is an overview of many basic data structures  Used in computer science.  On top of these infrastructures, programmers have built all sorts of smart variables, with the  The characteristics are slightly different - data structures such as red-black trees and heaps, and we do not  We have time to cover up  These different data structures have useful properties for certain accounts.  The right choice of data structure makes your work easier, forcing you to think  About how you want to organize your data before you start it  Fortunately, most programming languages \u200b\u200bcome with fully packed libraries with ready-made data structures.  For example, C ++ has a general template library and Java has a Java template library  This means that programmers do not have to waste time programming things from scratch  Alternatively, the enormous capacity of data structures to do more interesting things can be used again  Let us work on a new level of abstraction!  See you next week. ",
            "videoid": "DuDz6B4cqVc",
            "viewCount": "253387"
        },
        "F1F2imiOJfk": {
            "caption_exist": "T",
            "channel_id": "UClEEsT7DkdVO_fkrBw0OTrA",
            "channel_title": "mycodeschool",
            "concepts": [
                [
                    "data structure",
                    9
                ],
                [
                    "operations",
                    6
                ],
                [
                    "list",
                    2
                ],
                [
                    "recursion",
                    2
                ],
                [
                    "link",
                    1
                ],
                [
                    "leaf",
                    1
                ]
            ],
            "description": "See complete series on data structures here:\nhttp://www.youtube.com/playlist?list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P\n\nIn this lesson, we have described stack data structure as abstract data type. \n\nLesson on Dynamic memory allocation:\nhttp://www.youtube.com/watch?v=_8-ht2AKyH4\n\nFor practice problems and more, visit: http://www.mycodeschool.com \n\nLike us on Facebook: https://www.facebook.com/MyCodeSchool\n\nFollow us on twitter: https://twitter.com/mycodeschool",
            "dislikeCount": "20",
            "duration": "PT8M26S",
            "likeCount": "1503",
            "published_time": "2013-10-01T10:24:32.000Z",
            "tags": [
                "Stack",
                "Data Structure (Literature Subject)",
                "yt:cc=on"
            ],
            "thumbnail": "https://i.ytimg.com/vi/F1F2imiOJfk/hqdefault.jpg",
            "title": "Data structures: Introduction to stack",
            "transcript": "  in this lesson we are going to introduce you to stack data structure data structures as we know are ways to store and organize data on computers so far in this series we have discussed some of the data structures we have talked about arrays and linked lists now in this lesson we are going to talk about stacks and we are going to talk about stack as abstract data type or ADT when we talk about a data structure as abstract data type we talk only about the features or operations available with the data structure we do not go into implementation details so basically we define the data structure only as a mathematical or logical model we will go into implementation of stack in later lessons in this lesson we are going to talk only about stack ADT so we are only going to have a look at the logical view of stack stack as a data structure in computer science is not very different from stack as a way of organizing objects in real world here are some examples of stack from real world first figure is of a stack of dinner plates second figure is of a mathematical puzzle called Tower of Hanoi where we have three rods or three pegs and multiple disks and the game is about moving a stack of disks from one peg to another with this constraint that a disk cannot go on top of a smaller disk third figure is of a pack of tennis balls stack basically is a collection with this property that an item in the stack must be inserted or removed from the same end that we call the top of stack in fact this is not just a property this is a constraint or restriction only the top of a stack is accessible and any item has to be inserted or removed from the top a stack is also called last in first out collection most recently added item in a stack has to go out first in the first example you will always pick up a dinner plate from top of the stack and if you will have to up late back into the stack you will always put it back on top of the stack you can argue that I can slip out a plate from in between without actually removing the plates on the top so the constraint that I should take out a plate always from the top is not strictly enforced for the sake of argument this is fine you can say this in other two examples when we have disks in a peg and tennis balls in this box that can open only from one side there is no way you can take out an item from in-between any insertion or removal has to happen from top you cannot slip out an item from in-between you can take out an item but for that you will have to remove all the items on top of that item let's now formally define stack as an abstract data type a stack is a list or collection with the restriction that insertion and deletion can be performed only from one end that we call the top of stack let's now define the interface or operations available with stack ADT there are two fundamental operations available with a stack and insertion is called a push operation push operation can insert or push some item X onto the stack another operation ii operation is called pop pop is removing the most recent item from the stack most recent element from the stack push and pop are the fundamental operations and there can be few more typically there is one operation called top that simply returns the element at top of the stack and there can be an operation to check whether a stack is empty or not so this operation will return true if the stack is empty false otherwise so push is inserting an element on top of stack and pop is removing an element from top of stack we can push or pop only one element at a time all these operations that I have written here can be performed in constant time or in other words the time complexity is big-oh of remember an element that is pushed or inserted last onto a stack is popped or removed first so stack is called last in first out structure what goes in last comes out first last in first out in short is called leaf Oh logically a stack is represented something like this as a three-sided figure as a container open from one side this is a representation of an empty stack let's name this stack s let's say this figure is representing a stack of integers right now the stack is empty I will perform push and pop operations to insert and remove integers from this stack I will first write down the operation here and then show you what will happen in the logical representation let's first perform a push I want to push number 2 on to the stack the stack is empty right now so we cannot pop anything after the push stack will look something like this there is only one integer in the stack so of course it's on top let's push another integer this time I want to push number 10 and now let's say we want to perform a pop the integer at top right now is 10 with a pop it will be removed from the stack let's do a few more push I just pushed 7 and 5 onto the stack at this stage if I will call top operation it will return me number 5 is empty will return me false at this stage a pop will remove 5 from the stack as you can see the element the integer which is coming last is going out first that's why we call stack last in first out data structure we can pop till the stack gets empty one more pop and stack will be empty so this pretty much is stack data structure now one obvious question can be what the real scenarios where stack helps us let's list down some of the applications of stack stack data structure is used for execution of function calls in a program we have talked about this quite a bit in our lessons on dynamic memory allocation and linked lists we can also say that stack is used for recursion because recursion is also a chain of function calls it's just that all the calls are to the same function to know more about this application you can check the description of this video for a link to my course Schools lesson on dynamic memory allocation another application of stack is we can use it to implement undo operation in an editor we can perform undo operation in any text editor or image editor right now I'm pressing ctrl Z and as you can see some of the text that I have written is getting cleared you can implement this using a stack stack is used in a number of important algorithms like for example a compiler verifies whether parenthesis in a source code are balanced or not using stack data structure corresponding to each opening curly brace or opening parenthesis in a source code there must be a closing parenthesis at appropriate position and if parenthesis in a source code are not put properly if they are not balanced compiler should throw error and this check can be performed using a stack we will discuss some of these problems in detail in coming lessons this much is good for an introduction in our next lesson we will discuss implementation of stack this is it for this lesson thanks for watching",
            "videoid": "F1F2imiOJfk",
            "viewCount": "283499"
        },
        "R-HLU9Fl5ug": {
            "caption_exist": "T",
            "channel_id": "UC4Xt-DUAapAtkfaWWkv4OAw",
            "channel_title": "Joe James",
            "concepts": [
                [
                    "list",
                    80
                ],
                [
                    "key",
                    19
                ],
                [
                    "dictionary",
                    19
                ],
                [
                    "operations",
                    6
                ],
                [
                    "functions",
                    6
                ],
                [
                    "string",
                    3
                ],
                [
                    "boolean",
                    3
                ],
                [
                    "in-place sort",
                    2
                ],
                [
                    "union",
                    2
                ],
                [
                    "array",
                    2
                ],
                [
                    "occurrence",
                    2
                ],
                [
                    "superset",
                    1
                ],
                [
                    "sorted list",
                    1
                ],
                [
                    "associative array",
                    1
                ],
                [
                    "iteration",
                    1
                ],
                [
                    "exclusive or",
                    1
                ],
                [
                    "data structure",
                    1
                ],
                [
                    "associative",
                    1
                ]
            ],
            "description": "Tutorial on data structures in Python: Lists, Tuples, Sets and Dictionaries. Also explains sequence and string functions, slicing, concatenating, iterating, sorting, etc. with code examples.",
            "dislikeCount": "15",
            "duration": "PT19M1S",
            "likeCount": "1818",
            "published_time": "2015-05-24T19:52:12.000Z",
            "tags": [
                "Python (Programming Language)",
                "List",
                "Tuple",
                "Set",
                "Data Structure (Literature Subject)",
                "dictionary",
                "dict",
                "array",
                "hashmap",
                "functions",
                "methods",
                "associative array",
                "sequence",
                "string",
                "iterating",
                "slicing",
                "substring",
                "sorting",
                "code"
            ],
            "thumbnail": "https://i.ytimg.com/vi/R-HLU9Fl5ug/hqdefault.jpg",
            "title": "Python: Data Structures - Lists, Tuples, Sets & Dictionaries",
            "transcript": "  hi I'm Joe today I'm going to cover Python lists tuples sets and dictionaries now the list is the most widely used data structure in pythons very general-purpose similar to an array in Java and it covers most of what you would need but Tuffle sets and dictionaries have some advantages and specific areas and are very very useful data structures so the list is a sequence type is sortable the tupple is immutable which means you can't change add or remove items in a tubful once it's been created it's so it's useful for fixed data and tuple is also a sequence type which we'll explain in a second the set you can store non duplicate items so it's good for storing unique items in a set it's also very good for doing mathematical comparisons to set Union intersect those kinds of set operations dictionaries contain key value pairs it's like an associative array somewhere to a job a hash map and both sets and dictionaries are unordered which means they're not sortable and they're in random order there's one amazing thing about these data structures in Python is that they can hold any data type so they can hold integers floating point values strings or other object types and even other lists tuples sets and dictionaries and the data types don't have to be homogeneous so you can mix and match data types within a single list or within a set or within a dictionary now sequences include this tuples and also strings they're a bunch of different functions are applicable to all three of these data types and we're going to go into them in detail so indexing you can access any item in the sequence instantly using its index you have a million items in your list and you want to access an item instantly you can do that if you know it's index so a string is a sequence of letters let's say we want to access one of the items in the word frog we can say print X of three using the square brackets for the three and that gives us the third index starting from index 0 for F the G is going to be index 3 and in our list if we say we want item with index 1 that's going to go Scouse second eye list slicing allows us to slice out sub strings and sub lists and sub couples using indexes and syntax is using square brackets start n plus 1 and step and these are all optional I'll cover some examples of explain that and these are applicable to strings tuples and lists but in this example I'm just going to use the word computer which is a string so let's say we have X from 1 to 4 using a colon and this will return to us items 1 2 3 which is OMP if we want to slice items 1 2 6 this actually cuts off at 5 and it'll give us every other item since we have a step of 2 here so items 1 3 and 5 opt and X with items 3 2 basically no end right we didn't put an item after the colon so that's going to give us 3 onward 2p u ter if we don't put anything before the colon then it starts at 0 so this will give us items 1 through 4 or rather 0 through 4 and if we want to use negative numbers here we can use negative 1 which is the last item in a list or a sequence so X of negative 3 : nothing is going to give us the last three items on a sequence and then if we have X : negative 2 will give us everything except the last two items in it in the sequence adding and concatenating we can do using the plus symbol so we can combine two sequences of the same type only so if we have two strings that we want to combine we can use a plus sign to add them together and if we have two lists we want to merge together we can use the plus sign and will give us one list with 3 items in it multiplying we can use the star sign to multiply sequences again at the same type so if we have a bug it will multiply the word bug three times and give us bug bug bug or if we have a list with an eight and a five in it we want to multiply that by three it will give us eight five three times in our list checking membership test whether or not an item is in or not in a sequence using keywords in and not in so it's very simple to use so if we have x equals bug and we want to print you in x will print true if you is actually an X and O print false if it's not so in our list pig cow horse print cow not and will print true if cow is not an egg however cow is an EXO prints false so that's checking membership using the in and not end keywords iterating we can iterate through the items in a sequence using for loop so if we have list of integers in X we can say for item or in any variable name in X Trinity or whatever we want to do to that variable name it returns to us one list item at a time each loop iteration and if we need both the index and the item we can use the enumerate function so we say for index and item when you basically need two variable names here the first one is going to be index sector is going to be the value or the item in enumerate X and then we can do inside this for loop we can do whatever we want those two variables here I just have a print statement that prints the index followed by the value number of items will count the number of items in a sequence and we do that using the Len function which is short for length and we can do the same thing in a list prints the length of a list three items in this list minimum finds the minimum number lexicographically which means alpha numerically but this only works when all of the items in the list are either alpha or numeric you can mix and match integers and floating point values but you cannot have both strings and integers so if x equals bug we want to find the minimum the minimum is B we have a list of three strings we're going to find the lowest one which is C cow so prints cow maximum is going to find the maximum item in a sequence again lexicographically and they have to be all the same type either numeric or string type so if we take the maximum bug we get u and if we take the maximum of pig cow and horse we're going to get pig because it comes last alphabetically some we can find the sum of the items in a sequence if they're numeric type so five seven and bug is going to give us an error because bug is is not a numeric type but if we take the sum of two five eight and twelve it's going to print 27 or if we want to do a slice we can say hey I just want the sum of the last two items of X and this here will print 20 we can sort the items of the list this sorted function actually returns a new list without changing the original list returns a new list in sorted order so bug will return two letters of bug in a list in sorted order bgu and our list pig cow horse if we call sorted of X it's going to return a cow horse pig and mind you the original X is still unchanged count of item returns the count of a specific item in the sequence so here we're looking for the account X dot count of P will tell us there are two peas in hippo and X dot count of cow will tell us how many times the word cow appears in our list X if we want to find the index of an item the index function actually returns the index of the first occurrence of an item so if the item is in the list or sequence multiple times it returns the index of the first occurrence so here the H is 0 the eye is one the P the first P is 2 so X dot index of P is going to return 2 and here we find the first cow which has an index of 1 unpacking if we want to assign all the items in a sequence to a set of variables we can say a comma B comma C equals x and then all the strings in X will be assigned in order to the variables here on the left so Pig assign to a cow assigned to be in horse assign C but this only works if the number of variables exactly matches the length of your list so here we have 3 items we must have 3 variables so that covers general functions for sequence types now let's talk about specific list functions so there are a few different ways to create lists we can say x equals list parentheses we can say x equals in square brackets whatever list items we want to add to populate the list and again we can mix and match datatypes so we have Center some strings integers floating points and we can say x equals list and then in parentheses a double and we'll get a list from the items in the tuple there's a really cool function called comprehension so we can create a new list using what is returned by the for loop for M in range 8 so M and range 8 returns the values 0 through 7 and here we're saying we'll just take those values in so the resulting list is 0 through 7 here we have a for loop that says Z and range 10 if Z is greater than 4 so in other words item is 4 through 9 but we said hey look instead of adding the item itself Z to our list we want to add Z squared so it's going to take 5 through 9 and it's going to square each one of them and add it to the list so we get 25 36 49 64 81 so list comprehensions you can have fairly complex functions inside of the square brackets to create and populate a new list with whatever values you want delete we can delete an item from a list or we can delete a complete list the item we would delete using the index or we can delete the entire list append we can append an item to the end of the list using the append function extend we can combine to this this is very similar to the plus function that we already showed X extend Y is going to combine both x and y together into list X insert allows us to insert an item into a certain index position so here we want to insert a 7 into position one it will scoot the rest of the items to the right and put the 7 into the list and here we're going to insert a sub list or an embedded list with letters a and M into position 1 which is going to scoot all pop our sub list right in here the pop function pops the last item off the list and returns it so if we want to let's say print an item as we pop it off the list we can say print X dot pop and it will print the last item on the list and the new list will have one less item in it remove is going to remove a specific instance of an item so if we want to remove a 3 from this list we can put X dot remove 3 in order with the first 3 that defines not every 3 just the first 3 so you can see here the first 3 is gone and reverse reverses the current order of the list so the number that is first will become the last the number of the glass is going to become first and so on sort will actually do an in-place sort so a new list you get back our list X here is going to become a sorted list so unlike the sorted function sort is an in-place sort so it actually changes the order of the items in list X now let's talk about tuples so tuples support all the operations for sequences but tuples are immutable so member objects inside a tuple may be mutable for example you may have a list inside of a couple could be one of the items in your tub whole that list is still mutable you can still change an add and delete item from the list but you cannot delete the list itself from your Tuffle so it's a little confusing I'm going to show some examples in a second if the contents of a list shouldn't be changed then you can use a tupple that's what tuples are used for it's useful when you have a constant set of values that are not going to be changed that you want to use throughout your program and tuples are more efficient than lists due to how Python implements them so how do you construct a temple well a new tuple with no values in it is going to just be created using the parentheses and we can say x equals 1 comma 2 comma 3 if we want to create a tough hole with values 1 2 &amp; 3 in it and you don't even need the parentheses actually the parentheses are optional if you want to create a single item tuple you still have to put a comma after that item otherwise it would just sign x equals integer value 2 and X would be an integer not a double so the comma tells it hey this is a tupple but it's a single item tuple and we can create a tuple from all the members of a list just using the tupple function so tuples are immutable as I said if we try to delete an item from a tuple or change the value of an item in a temple we're going to get an error but if we have let's say a list inside of a tuple here we have a two pole called X and our first item is a list with one and two in it and our second item is an integer 3 so we can't change that 3 that's immutable however we can't change the list here we're going to delete the the list which is to the item in index 1 so our new tough ball has a list with just the 1 in it and integer 3 so we can change the list the list itself is mutable but the tuple is not we still have to keep the list in this position let's talk about sets now so there are some constructors how we would create a new set we use the curly braces if we want to populate a set with values and we can create a new empty set using set with parentheses and we can create a set from a list by calling a set function in parentheses the name of the list when we do this though it strips out all the duplicates from our list and returns only unique values to the set and then we also have similar to the list comprehension a set comprehension so we can use a for loop if statements and whatever functions we want to do on those X values X is probably a bad choice of variables here since we're using X for the set name but but we can use the list comprehension to put values into our set and sets our unordered so as we populate set the items are going to be in random order so some basic set operations we can add an item to set X by using X dot add item remove an item set X using X dot remove item get length of set X using a Len function we can check membership in X by simply saying item in X or item not in X that's going to return a boolean true or false we can pop a random item from set X using a pop function we don't know which item is going to be popped it's arbitrary selected and we can delete items from set X by saying X dot clear will completely empty our set some of the standard mathematical functions for sets are very useful we can find the intersection of two sets using the ampersand function and we can find a union of two sets using the vertical bar symmetric difference or exclusive or in other words items that are in set one but not in set two or in set two and not inset one using the up arrow the difference which means items that are in set 1 but not in set 2 we just take set one - set 2 and subsets and supersets a boolean value does set to contain set 1 or 2 set 1 contain set 2 for superset question so there's one set operations now let's take a look at dictionaries so a dictionary again is a key value pair and you can see three different ways here to create a dictionary you can use curly braces with the key first in this case I chose to use strings for a key and floating-point values for my value and they're separated by pullin so this is the most standard way to create a dictionary you can also call the dictionary function to create a dictionary by placing comma separated tuples inside of the set and you can also say key equals value comma separated and called dictionary on that so there's three different ways to create a dictionary I find the first one is more widely used in more standard but the all three work so some basic dictionary operations you can add or change an item in dictionary X by saying X key is equal to value if this key is already existing in the dictionary then it will change the value to this if the key doesn't exist in dictionary it will add this key value pair to the dictionary remove item from dictionary X delete X and then the key get the length of dictionaries and a Len function check membership in X item in ax or item not in X this only looks in the keys it does not compare to values so if we want to look through values I'll show it show you a way on the next slide to do that delete all items from dictionary X we could say X clear and delete the entire dictionary X delete X del X so how do we access the keys and values in the dictionary we can say X dot keys will return a list of the keys in X X values returns a list of values in X and X dot items return a list of key value couple pairs and X so if we want to check membership in values of X we can say item in X values and this will text test the membership in X and return a boolean iterating a dictionary we can use for loops for variable in X print variable right so we say key we used a word key for our variable we can print our key and then if we want access to the value as well we say X and then key in square brackets then we can get both the key and the value display by iterating however if we want to do a lot of operations or use use the value quite frequently inside of our for loop we could use items instead so we can get two separate variables for the key and the value by saying for K comma V in extra item items is going to return both a key and a value and assign them to variables K and V in this case so when we print K and B we print out each key and each value for the entire dictionary that wraps up my video on dictionaries I hope you enjoyed the video please click the like button at the bottom I'm Joe James thanks for watching",
            "videoid": "R-HLU9Fl5ug",
            "viewCount": "86100"
        },
        "bum_19loj9A": {
            "caption_exist": "T",
            "channel_id": "UCxX9wt5FWQUAAz4UrysqK9A",
            "channel_title": "CS Dojo",
            "concepts": [
                [
                    "list",
                    16
                ],
                [
                    "data structure",
                    15
                ],
                [
                    "array",
                    6
                ],
                [
                    "algorithm",
                    5
                ],
                [
                    "linked list",
                    4
                ],
                [
                    "location",
                    3
                ],
                [
                    "shortest path",
                    3
                ],
                [
                    "string",
                    2
                ],
                [
                    "link",
                    2
                ],
                [
                    "insertion sort",
                    1
                ],
                [
                    "walk",
                    1
                ],
                [
                    "mean",
                    1
                ],
                [
                    "shape",
                    1
                ],
                [
                    "hash table",
                    1
                ],
                [
                    "operations",
                    1
                ]
            ],
            "description": "Data structures and algorithms tutorial #1 - let's go!\n\nCheck out Brilliant.org, a website for learning computer science concepts through solving problems: https://brilliant.org/csdojo/\nSpecial thanks to Brilliant for sponsoring this video.",
            "dislikeCount": "40",
            "duration": "PT16M35S",
            "likeCount": "3014",
            "published_time": "2018-03-12T05:19:30.000Z",
            "tags": [
                "data structures and algorithms",
                "data structures and algorithms tutorial",
                "data structures tutorial",
                "algorithms tutorial",
                "linked lists",
                "arrays",
                "hash maps",
                "hash tables",
                "java",
                "python",
                "brilliant sponsor",
                "brilliant.org"
            ],
            "thumbnail": "https://i.ytimg.com/vi/bum_19loj9A/hqdefault.jpg",
            "title": "Data Structures & Algorithms #1 - What Are Data Structures?",
            "transcript": "  hey YouTube just in case you're new here my name is YK and I was formerly a software developer at Google and now I work on this YouTube channel full time and welcome to my data structures and algorithms series number one what are data structures so a one sentence description of what data structures are would be that there are basically different ways of storing data on your computer and this sentence might not be too clear right now so let me give you a more concrete example here let's say you want to make a system that's sort of like Google Maps for your neighborhood now let's say your neighborhood looks like this so your home is here and there's a store here and another store here and so on and there are some streets too so these arrows show that these are one-way streets there are a lot of one-way streets here and so for example you can go from store to store B but not the other way around and all the other lines here there are not arrows show that they are two-way streets and let's say that you already have each place is coordinates there are latitudes and longitudes stored on your computer like this as you can see from this table you can tell that the latitude of home is forty-nine point two and the longitude of home is minus one hundred twenty three point four and so on now from this table like information you can tell where each location is exactly where each point is exactly but you can't tell how these locations are connected with streets and where the streets are exactly so you need to figure a way to store that information somehow on your computer and there are actually a few different options for this one of those options will be to store all possible paths in a list like format so for example one of those paths will be from store a to home and another one will be home to store a and yet another path will be store a to store B and with that method your data might look like this and from this list like information you can tell that as we saw earlier you can go from home to store a and from store a to home and home to store B and so on but you can't go from store B to home because this is a one-way street and so there's no path from store B to home in this list okay so that's just one option another option might be to list each of these places and for each of those places just list all the places you can go from that place and with that method your data might look like this instead as you can see here we have table like information again where on the left hand side we have all the places listed home store a store B school and then intersection this one right here and on the right hand side for each of those places we have all the places you can go from there so from home you can go to store a store B and intersection as you can see here and from store a you can go to home or store B so these two methods are basically two different ways of storing exactly the same set of data and as you can see they have sort of different structures and so these are simplified examples of what data structures look like now if you're already familiar with data structures you might notice that the first method corresponds to the array or a list data structure and the second method corresponds to the hash table or hash map data structure okay so that's one simple example of what data structures are but this video series is called data structures and algorithms so what are algorithms one way to define what they are would be that there are the operations we can perform on different data structures and the sets of instructions for executing them so one example here might be something like this coming back to the previous example we had let's say you want to find the shortest path from home to school so in this problem by hand is pretty easy pretty much right away you can see that there are three potential paths from home to school one of them is this one just go to store a store B and then school another one is this one store B cool and another one the other one is from home to intersection to school and for these three paths just compare the distance that you need to travel for each of these paths and then pick the shortest one and to compute the distance these paths you can for example use the longitudes and latitudes the coordinates of each of these places and find the distance in kilometers so solving this problem by hand is pretty much trivial but if you want to turn this into something a computer can understand you need to be much more systematic about it so to make this strategy something a computer can understand easily you might come up with a set of instructions like this one first of all find all the places you can go from home so in this example that's store a store B and then the intersection and then from each of those places find all the paths you can take from that place so from store a you can go to store B and from store B you can go to school and from intersection you can only go to school and as you go keep track of the distance you've traveled so far for each of those paths and keep repeating this process until you get to the school then if you happen to find multiple paths that allows you to go from home to school then compare the distance that you've traveled for each of those paths and finally find a path with the shortest distance traveled and then pick that as the shortest path okay so that's the result we were looking for in the first place and this is a good example of what an algorithm is basically you have a problem you're going to solve in this case finding the shortest path from home to school and then you have a set of systematic instructions for solving that problem now one thing to note here is that depending on what data structure you're using to store the data that you're performing the algorithm on your algorithm might look slightly differently you might even have in some cases completely different algorithms for solving the same problem depending in this particular example we talked about two different options for storing the information about where the streets are and how they connect different locations the first option was to just list all possible paths and remember that the first step in our algorithm was to find all the possible places you can go from home and to do that with the first stair structure this one right here you might actually need to go through the entire list because in this particular list we have three paths here from home but it's possible that we have another path from home right here at the end of the list so you need to go through the entire list just in case on the other hand if you use the second data structure that we discussed we have home listed right here as a group so as soon as we find the home row in this table you won't need to go through the entire table anymore so in this particular example using the second structure actually makes it slightly easier to implement the algorithm that we discussed now there are structures and algorithms are really important to learn because they'll help you write efficient software as a software developer so for example when I was working at Microsoft as a data science intern I had to write this piece of code to retrieve some data and when I wrote it originally it was taking like seven to ten hours and basically it was too slow because we didn't want we didn't want to wait that long so I rewrote it using my knowledge of data structures and algorithms and after rewriting it the new version only took like five to ten minutes to load that data so that's why learning them is important and it's actually useful in many practical situations that you might encounter as a software developer - okay to give you an even better idea about what data structures are like let me give you another example here let's say you're hosting a party and you're expecting a bunch of people and this example is gonna be a little bit silly but just follow along and you're gonna see why I'm talking about this particular example anyway let's say that each person come to the party we'll bring sort of like a small ball with them like a ball that can fit in their hand and this ball will have their name written on it so when David comes to the party he'll have a ball with David written on it and when Kevin arrives to the party he'll have a ball with Kevin written on it and so on and this is just a silly little system that you came up with for keeping track of who came to the party in which order because writing now each person's name would be a lot of work you're just too busy hosting a party so as someone who's studying computer science let's say you're trying to come up with an efficient system for storing these balls so that you can keep track of who came to the party one idea you have is this one you get a very long box with 100 partitions a lot of partitions and each partition let's say has exactly the same shape you know 10 centimeters by 10 centimeters let's say and every time someone comes to the party you're just gonna put that person's ball with their name written on it in the order they came to the party so David's ball will come in here and Kevin's will come in here and so on and this is actually sort of like a data structure that's realized in real life and this actually corresponds to the data structure called array in computer science and here's another idea you have you get a bunch of boxes and this time instead of getting a long box with many many partitions you want to get individual boxes that are connected with strings so the first box is connected to the second box with a string and that's connected to the third box with a string and so on and just like before you want to put these tokens with participants names written on them in these boxes just one by one in the order they came in so David's token will come in here and Kevin's ball will come in here and so on and this sort of data corresponds to the linked list data structure in computer science okay so the natural question here would be which use for this party well it actually depends because it highly depends on the particular situation and the nature of the party really and each data structure has advantages and disadvantages okay think about this situation let's say 100 people showed up to your party and you're pretty happy about it but suddenly you realize that the 98th person is Paul had been misspelled that person's name had been misspelled so you want to fix that with the array data structure it's actually pretty easy you just need to find the 98th partition and that exact location can be calculated easily because you know that each partition is ten centimeters wide so you just need to find ten centimeters times ninety seven actually which is nine hundred seventy centimeters so you just need to walk over from the beginning nine hundred seventy centimeters and then you can find the 98th person's token pretty easily you just need to replace that with the correct token with the link list data structure though doing the same thing would be slightly more tricky and that's because finding the 98th person or finding the 98th box here would be much harder and the reason for that is because these strings are pretty soft and they can be pretty much any lengths so each box can be in any location relative to the previous box so this first box might be in the living room and the second box might be in the kitchen and so on so to find in 98th box what you need to do is you need to count them one by one so you need to say okay this is the first box and then this is the second box and let's find the third box fourth and so on until you get to the 98th person at this point you might say well the array data structure is a better one then well not necessarily so think about this situation let's say you have 100 people showing up to the party suddenly five more people show up that you didn't expect with the linked list data structure it's pretty easy to deal with that you can just add five more boxes find five more boxes somewhere and then five more strings and just add them to the last box you had in the linked list data structure and then store the five people's tokens in those boxes with the array data structure though it's a little bit more tricky one option here would be to get another box with let's say 100 partitions again and store those people's tokens there and use the two boxes together or you could destroy the first box you had and then get a box with even more partitions let's say 200 partitions and then transfer all the balls you had for the first 100 people to the new box and then after that add the additional five people's tokens in the new box and in general if you have no idea how many people are coming to the party let's say anywhere between 5 to 1,000 people the linked list data structure might be slightly more convenient than the array because linked lists are so much easier to resize than it is to resize a race ok and this was another simplified example of what data structures are like on a computer and this sort of gives you a rough idea about how to actually start thinking about them and throughout this course I'm going to introduce you to even more data structures and this time I'm going to explain them in a much more technical way using concepts like classes objects memory and maybe even some code snippets too now if you're just getting started with data structures and algorithms one thing to keep in mind that's actually really important is to apply what you've learned through solving problems and the reason I say that is because it's so common for beginners to learn these concepts and not actually be able to use them in a real-world situation because they haven't had enough practice and actually this video sponsor brilliant org has an interesting website for learning these concepts in a sort of a new way ok to show you what I mean let's take a look at their computer science fundamentals course right here which I would recommend for you guys and let's go into the intro to algorithms section and you can see that it covers topics like arrays searching insertion sort and Big O notation and in the arrays section they have a bunch of explanations about the topic and as you continue you'll give you a quiz to test your understanding of the topic so it's definitely an interesting way to learn computer science concepts by solving problems okay if you want to check it out for yourself just go to brilliant org slash CS no joke and going to this link will actually help support this channel and the first 200 people will get 20% off the annual subscription and actually I'm super excited about this because they're the first sponsor I have on this YouTube channel and I feel like I'm becoming a professional youtuber finally so thanks for that brilliant ok as always I'm YK from CS dojo thanks for watching and I'll see you guys in the next video",
            "videoid": "bum_19loj9A",
            "viewCount": "111998"
        },
        "c8P9kB1eun4": {
            "caption_exist": "T",
            "channel_id": "UCSX3MR0gnKDxyXAyljWzm0Q",
            "channel_title": "Kevin Drumm",
            "concepts": [
                [
                    "graph",
                    40
                ],
                [
                    "vertex",
                    16
                ],
                [
                    "edge",
                    14
                ],
                [
                    "list",
                    11
                ],
                [
                    "matrix",
                    7
                ],
                [
                    "array",
                    5
                ],
                [
                    "undirected graph",
                    4
                ],
                [
                    "tree",
                    3
                ],
                [
                    "node",
                    3
                ],
                [
                    "directed graph",
                    2
                ],
                [
                    "root",
                    2
                ],
                [
                    "weighted graph",
                    2
                ],
                [
                    "sparse graph",
                    2
                ],
                [
                    "dense graph",
                    2
                ],
                [
                    "mode",
                    1
                ],
                [
                    "digraph",
                    1
                ],
                [
                    "data structure",
                    1
                ],
                [
                    "boolean",
                    1
                ],
                [
                    "one-dimensional",
                    1
                ],
                [
                    "parent",
                    1
                ],
                [
                    "diameter",
                    1
                ],
                [
                    "two-dimensional",
                    1
                ]
            ],
            "description": "This is the first in a series of videos about the graph data structure.  It mentions the applications of graphs, defines various terminology associated with graphs, and describes how a graph can be represented programmatically by means of adjacency lists or an adjacency matrix.",
            "dislikeCount": "0",
            "duration": "PT7M59S",
            "likeCount": "38",
            "published_time": "2016-04-27T05:44:58.000Z",
            "tags": [
                "graph",
                "dynamic data structure",
                "vertex",
                "edge",
                "path",
                "cycle",
                "directed graph",
                "digraph",
                "unordered graph",
                "weighted graph",
                "implementation",
                "adjacency list",
                "adjacency matrix",
                "A Level",
                "Computer Science"
            ],
            "thumbnail": "https://i.ytimg.com/vi/c8P9kB1eun4/hqdefault.jpg",
            "title": "Graph Data Structure 1. Terminology and Representation (algorithms)",
            "transcript": "  the graph data structure has a great many applications in computer science almost invariably to model some type of network travel routes such as road links shipping lanes or aircraft flight paths can be represented including information about distances speed limits wind speed fuel requirements or just about anything of relevance but it doesn't stop there a search engine might model the links between webpages on the internet using a graph the routing of data packets during transmission on a computer network can be represented by a graph the connections between people and groups in social networks the speed and pressure of liquids flowing inside pipes finding the quickest time to complete a project that includes several interdependent steps for example in the field of construction modeling objects in three dimensions usually involves the creation of a mesh which is really just another type of graph the available moves in a strategy game such as chest or the possible scenarios in a computer generated simulation arguably the graph is one of the most versatile data structures in the field of software engineering here's a simple graph it's a collection of interconnected nodes but unlike a tree there are no rules about how these nodes can be connected there's no such thing as a root mode nor are there such things as parent nodes or child nodes in a graph a node is more correctly known as a vertex and vertices are connected by edges typically a graph will have more edges than vertices a graph with lots of edges in relation to the number of vertices is said to be a dense graph while a graph with few edges said to be sparse in some graphs the edges are directional this is known as directed graph it's also known as a digraph a graph in which all of the edges are bi-directional is known as an undirected graph or an unordered graph or simply a graph by default a graph is assumed to be unordered each edge in a graph can have a weight associated with it the weight of each edge is sometimes referred to as the cost what each cost represents depends of course on the application for example each cost could be a speed limit the diameter of a water pipe the number of hours to complete a phase of a project you name it a path is a sequence of vertices in a graph a graph is said to be connected if there is a path from every vertex to every other vertex a cycle is a path in which the starting vertex is also the ending vertex a tree is a special type of graph which includes a path from some starting node the root to every other node but a tree has no cycles so how do we represent a graph or to begin with a graph can be described in mathematical set notation a graph is said to be a set of vertices V and a set of edges e we can list the vertices inside curly brackets and each edge can be listed as a pair of vertices for a weighted graph we can add the cost of each edge to this notation now remember an undirected graph is one in which all of the edges are bi-directional so strictly speaking we should do note each possible direction of an edge separately so what if we want to code up a graph and work with the data it contains there are two ways that a graph class could internally maintain the vertices and edges of a graph these are the adjacency list and the adjacency matrix in essence with an adjacency list system we have a master list of vertices then for each edge each starting vertex maintains a list of ending vertices or to put in another way each vertex maintains a list of its neighbors there are several ways this could be implemented but an object-oriented approach is probably the most suitable we could code up a vertex class that each vertex object would be instantiated from the vertex class would have a property to hold information about the vertex such as the name of a city if we were representing some kind of map another property could be an identifier for the vertex and another an array containing the identifier of its adjacent vertices the master list of vertex objects can also be stored in a simple one-dimensional array to represent a weighted graph the cost of each edge could be stored in the adjacency list to using an adjacency list is a very compact space efficient representation of a graph particularly a sparse graph you don't have to store any more data than necessary however determining if an edge exists between two particular vertices would require searching through the adjacency list of one of them for a dense graph the time taken will increase proportionately with the density of the with an adjacency matrix every vertex is written as a row heading and a column heading in a grid if an edge exists between a pair of vertices then its weight can be indicated at the intersection of the appropriate row and column note that for an undirected graph there is symmetry along the adjacency matrix is diagonal if there's an edge from A to B there must be a corresponding edge from B to a this symmetry wouldn't be present for a directed graph for an unweighted graph we can simply represent each edge with a boolean value an adjacency matrix can be implemented with a two-dimensional array we would still have a vertex class from which we would create each vertex object but the actual connectivity of the graph would be defined by this 2d array of edges one of the advantages of an adjacency matrix over an adjacency list is that determining whether or not an edge exists between two vertices requires a simple array lookup this takes the same amount of time to do regardless of the edge in question however an adjacency matrix is not particularly efficient when it comes to space for a sparse graph much of the adjacency matrix will be empty furthermore for an undirected graph half of the information stored is just duplication which method you use to implement a graph will ultimately depend on the nature of the information it will represent and of course how you plan to process it",
            "videoid": "c8P9kB1eun4",
            "viewCount": "3296"
        },
        "gXgEDyodOJU": {
            "caption_exist": "T",
            "channel_id": "UClEEsT7DkdVO_fkrBw0OTrA",
            "channel_title": "mycodeschool",
            "concepts": [
                [
                    "graph",
                    66
                ],
                [
                    "edge",
                    26
                ],
                [
                    "tree",
                    12
                ],
                [
                    "undirected graph",
                    12
                ],
                [
                    "directed graph",
                    9
                ],
                [
                    "link",
                    9
                ],
                [
                    "node",
                    8
                ],
                [
                    "root",
                    3
                ],
                [
                    "linear",
                    3
                ],
                [
                    "weighted graph",
                    3
                ],
                [
                    "digraph",
                    3
                ],
                [
                    "data structure",
                    3
                ],
                [
                    "parent",
                    2
                ],
                [
                    "array",
                    1
                ],
                [
                    "theta",
                    1
                ],
                [
                    "shortest path",
                    1
                ],
                [
                    "vertex",
                    1
                ],
                [
                    "reachable",
                    1
                ],
                [
                    "queue",
                    1
                ]
            ],
            "description": "See complete series on data structures here:\nhttp://www.youtube.com/playlist?list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P\n\nIn this lesson, we have described Graph data structure as a mathematical model.  We have briefly described the concept of Graph and some of its applications. \n\nFor practice problems and more, visit: http://www.mycodeschool.com \n\nLike us on Facebook: https://www.facebook.com/MyCodeSchool\n\nFollow us on twitter: https://twitter.com/mycodeschool\ufeff",
            "dislikeCount": "50",
            "duration": "PT16M43S",
            "likeCount": "2537",
            "published_time": "2014-09-02T11:25:00.000Z",
            "tags": [
                "Graph",
                "Data Structure (Literature Subject)",
                "Computer",
                "coding",
                "programming",
                "algorithm",
                "yt:cc=on",
                "interview",
                "computer science"
            ],
            "thumbnail": "https://i.ytimg.com/vi/gXgEDyodOJU/hqdefault.jpg",
            "title": "Data structures: Introduction to graphs",
            "transcript": "  hello everyone so far in this series on data structures we have talked about some of the linear data structures like array linked lists stack and queue in all these structures data is arranged in a linear or sequential manner so we can call them linear data structures and we've also talked about tree which is a nonlinear data structure tree is a hierarchical structure now as we understand data structures are ways to store and organize theta and for different kinds of data we use different kinds of data structures in this lesson we are going to introduce you to another nonlinear data structure and that has got its application in a wide number of scenarios in computer science it is used to model and represent a variety of systems and this data structure is graph when we study data structures we often first study them as mathematical or logical models here also we will first study graph as a mathematical or logical model and we will go into implementation details later okay so let's get started a graph just like a tree is a collection of objects or entities that we call nodes or vertices connected to each other through a set of edges but in a tree connections are bound to be in a certain way in a tree there are rules dictating the connection among the nodes in a tree with n nodes we must have exactly n minus 1 edges one edge for each parent-child relationship as we know an edge in a tree is for a parent-child relationship and all nodes in a tree except the root node would have a parent would have exactly one parent and that's why if there are n nodes there must be exactly n minus 1 edges in a tree all nodes must be reachable from the root and there must be exactly one possible path from root to a node now in a graph there are no nodes a graph contains a set of nodes and a set of edges and edges can be connecting nodes in any possible way tree is only a special kind of craf now craf as a concept has been studied extensively in mathematics if you have taken a course on discrete mathematics then you must be knowing about crafts already in computer science we basically study and implement the same concept of craft from mathematics the study of crafts is often referred to as craft theory in pure mathematical terms we can define graph something like this a graph G is an ordered pair of a set V of vertices and a set of edges now I'm using some mathematical jargon here an ordered pair is just a pair of mathematical objects in which the order of objects in the pair matters this is how we write and represent an ordered pair objects separated by comma put within parenthesis now because the order here matters we can say that V is the first object in the pair and E is the second object an ordered pair a B is not equal to B a unless a and B are equal in our definition of graph here first object in the pair must always be a set of vertices and the second object must be a set of edges that's why we are calling the pair an ordered pair we also have concept of unordered pair and an ordered pair is simply a set of two elements order is not important here we write an unordered pair using curly brackets or braces because the order is not important here an ordered pair a B is equal to B a it doesn't matter which object is first and which object is second okay coming back so a graph is an ordered pair of a set of vertices and a set of edges and G equal V E is a formal mathematical notation that we use to define a graph now I have a craft drawn here in the right this graph has 8 vertices and 10 edges what I want to do is I want to give some names to these vertices because each node in a graph must have some identification it can be a name or it can be an index I'm naming these vertices as V 1 V 2 V 3 V 4 V 5 and so on and this naming is not indicative of any order there is no first second and third node here I could give any name to any node so my set of what is e is here is this we have eight elements in the set v1 v2 v3 v4 v5 v6 v7 and v8 so this is my set of vertices for this graph now what's my set of edges to answer this we first need to know how to represent an edge an edge is uniquely identified by its two endpoints so we can just write the names of the two endpoints of an edge as a pair and it can be a representation for the edge but edges can be of two types we can have a directed edge in which connection is one way or we can have an undirected edge in which connection is two way in this example graph that I'm showing here edges are undirected but if you remember the tree that I had shown earlier then we have directed edges in that tree with this directed edge that I'm showing you here we are saying that there is a link or path from vertex u to V but we cannot assume a path from V to u this connection is one way for a directed edge one of the endpoints would be the origin and the other endpoint would be the destination and we draw the edge with an arrowhead pointing towards the destination for our edge here origin is U and destination is V a directed edge can be represented as an ordered pair first element in the pair can be the origin and second element can be the destination so with this directed edge represented as ordered pair UV we have a path from u to V if we want a path from V to u we need to draw another directed edge here with V as origin and U as destination and this edge can be represented as ordered pair vu the upper one here is UV and the below one is vu and they are not same now if the edge is undirected the connection is two-way an undirected edge can be represented as an unordered pair here because the edge is bi-directional origin and destination are not fixed we only need to know what two endpoints are being connected by the edge so now that we know how to represent edges we can write the set of edges for this example graph here we have an undirected edge between v1 and v2 then we have one between v1 and v3 and then we have v1 v4 this is really simple I'll just go ahead and write all of them so this is my set of edges typically in a graph all edges would either be directed or undirected it's possible for a graph to have both directed and undirected edges but we are not going to study such graphs we are only going to study graphs in which all undirected a graph with all directed edges is called a directed graph or digraph and a graph with all undirected edges is called an undirected graph there is no special name for an undirected graph usually if the graph is directed we explicitly say that it's a directed graph or digraph so these are two types of graph directed graph or digraph in which edges are unidirectional or ordered pairs and undirected graph in which edges are bi-directional or unordered pairs now many real-world systems and problems can be modeled using a graph graphs can be used to represent any collection of objects having some kind of pairwise relationship let's have a look at some of the interesting examples a social network like Facebook can be represented as an undirected graph a user would be a node in the graph and if two users are friends there would be an edge connecting them a real social network would have millions and billions of nodes I can show only few in my diagram here because I am short of space now social network is an undirected graph because friendship is a mutual relationship if I'm your friend you are my friend too so connections have to be two-way now once a system is modeled as a graph a lot of problems can easily be solved by applying standard algorithms in graph theory like here in this social network let's say we want to do something like suggest friends to a user let's say we want to suggest some connections to Rama one possible approach to do so can be suggesting friends of friends who are not connected already Rama has three friends Ella Bob and Katie and friends of these three that are not connected to Rama already can be suggested there is no friend of Allah which is not connected to Rama already Bob however has three friends storm Sam and Lea that are not friends with Rama so they can be suggested and Katie has two friends Lee and Swati that are not connected to Rama we have counted Li already so in all we can suggest these four users to Rama now even though we described this problem in context of a social network this is a standard crafts problem the problem here in pure graph terms is finding all nodes having length of shortest path from a given node equal to two standard algorithms can be applied to solve this problem we will talk about concepts like paths in a graph in some time for now just know that the problem that we just described in context of a social network is a standard craft problem okay so a social network like Facebook is an undirected graph now let's have a look at another example interlinked web pages on the internet or the world wide web can be represented as a directed graph of web page that would have a unique address or URL would be a node in the graph and we can have a directed edge if a page contains link to another page now once again there are billions of pages on the web but I can show only few here the edges in this graph are directed because relationship is not mutual this time if page a has a link to page B then it's not necessary that page B will also have a link to page a let's say one of the pages on my code school comm has a tutorial on craft and on this page I have put a link to Wikipedia article on let's assume that in this example graph that I'm showing you here page B is my my code school tutorial on craft with this address or URL my code school comm / videos / craft and let's say page Q is the Wikipedia article on graph with this URL wikipedia.org / wiki / graph now on my page that is page P I have put a link to Wikipedia page and graph if you are on page P you can click on this link and go to page Q but Wikipedia has not reciprocated to my favor by putting a link back to my page so if you are on page Q you cannot click on a link and come to page P connection here is one way and that's why we have drawn a directed edge here okay now once again if we are able to represent web as a directed graph we can apply standard craft theory algorithms to solve problems and perform tasks one of the tasks that search engines like Google perform very regularly is web crawling search engines use a program called web crawler that systematically browses the worldwide web to collect and store data about web pages search engines can then use this data to provide quick and accurate results against search queries now even though in this context we are using a nice and heavy term like web crawling web crawling is basically Draft traversal or in simpler words act of visiting all nodes in a graph and no prizes for guessing that there are standard algorithms for craft traversal and we'll be studying graph traversal algorithms and later lessons okay now the next thing that I want to talk about is concept of a weighted graph sometimes in a graph all connections cannot be treated as equal some connections can be preferable to others like for example we can represent intercity throwed Network that is the network of highways and freeways between cities as an undirected graph I am assuming that all highways would be bi-directional intra-city road network that is road network within a city would definitely have one-way roads and so intra-city road network must be represented as a directed graph but intercity road network in my opinion can now clearly we cannot treat all connections as equal here roads would be of different lengths and to perform a lot of tasks to solve a lot of problems we need to take lengths of roads into account in such cases we associate some weight or cost with every edge we label the edges with their weights in this case weight can be lengths off the roads so what I'll do here is I'll just label these edges with some values for their lens and let's say these values are in kilometers and now edges in this graph are weighted and this graph can be called a weighted graph let's say in this graph we want to pick the best route from City a to city D have a look at these four possible routes I am showing them in different colors now if I would treat all edges as equal then I would say that the green route through B and C and the red route through E and F are equally good both these paths have three edges and this yellow route through E is the best because we have only two edges in this path but with different weights assigned to the connections I need to add up weights of edges in a path to calculate total cost when I'm taking weight into account shortest route is through B and C connections have different weights and this is really important here in this graph actually we can look at all the graphs as weighted graphs an unweighted graph can basically be seen as a weighted graph in which weight of all the edges is same and typically we assume the weight as one okay so we have represented inter-cities road network as a weighted undirected graph social network was an unweighted undirected graph and World Wide Web was an unweighted directed graph and this one is a weighted undirected graph now this was interesting at work I think network within a city can be modeled as a weighted directed graph because in a city there would be some one-ways intersections in intra-city road network would be nodes and Road segments would be our edges and by the way we can also draw an undirected graph as directed it's just that for each undirected edge we'll have two directed edges we may not be able to redraw our directed graph as undirected but we can always redraw an undirected graph as directed okay I'll stop here now this much is good for an introductory lesson in next lesson we will talk about some more properties of graph this is it for this lesson thanks for watching",
            "videoid": "gXgEDyodOJU",
            "viewCount": "337486"
        },
        "jc1t0KFsOcs": {
            "caption_exist": "T",
            "channel_id": "UC59K-uG2A5ogwIrHw4bmlEg",
            "channel_title": "Telusko Learnings",
            "concepts": [
                [
                    "language",
                    7
                ],
                [
                    "list",
                    3
                ],
                [
                    "data structure",
                    3
                ],
                [
                    "mean",
                    2
                ],
                [
                    "link",
                    1
                ],
                [
                    "linked list",
                    1
                ]
            ],
            "description": "This is just an Introduction video.\nMore videos are on the way.\n\n\nData structure is a particular way of organizing and storing data in a computer so that it can be accessed and modified efficiently.\nData structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data.\n\nIn this video we will see :\n- What is Data\n- What is Information\n- What is Data Structure\n- Why we need Data Structure",
            "dislikeCount": "12",
            "duration": "PT4M42S",
            "likeCount": "1217",
            "published_time": "2017-12-16T11:20:25.000Z",
            "tags": [
                "telusko",
                "navin",
                "reddy",
                "tutorial",
                "java"
            ],
            "thumbnail": "https://i.ytimg.com/vi/jc1t0KFsOcs/hqdefault.jpg",
            "title": "#1 What is Data Structure? | Why it is so Important?",
            "transcript": "  before learning any language learn data structures oh-ho-ho I know you're pushing there you might be thinking what is data structures and what is so important let's find out welcome back aliens my name is Ivan 20 and let's get started we are living in an Information Age now what does that mean it simply means that everything around you it's all about information the IT industry which you are working with its IT which is information technology right so what they need is information but we have to store that data somewhere right and that's important avoid data how can you store that data because after that after processing that data you will get information right but how do you store that data no data can be of different type right it can be a normal data it can be a complex data so it's all about how to store it now why is reading is so important we can simply fetch data and put it somewhere right take a file put your data there no it's not that simple it's not just about storing data it's also about how can you fetch that data in efficient way how can you process that data in efficient way so with that data you will do lots of thing so you have to build a solution in such a way or if you have to store your data in such a way that it will be easier for you to fetch it to process it and to you know again shut it somewhere and that's why we have this concept of data structures so before learning a language if you understand what these data structures it will be easier for you to understand how that language works right in fact if you have learned any programming language before maybe C or Python or Java in that we use certain things for us arrays we use least so to understand those concept data so it is very important so data structure is all about how can you structure your data so that you can store it and use it efficiently again there are certain algorithms you can you can implement on that if you heard about this concept of searching techniques we have sorting techniques so we can apply all those techniques only when your data is properly structured now how do we store that data so what we have a concept called as abstract data type it simply means you can store your data in you to work in future example we have a concept of least so if you want to save data in sequential format we can actually use lists we also have a concept of stack so let's say if you want to sort everything sequence format we can cover list maybe you want to you know when you say windows tab or all tab in Windows or in any OS it will show the recent applications right now if you remember the first app it shows you is the last which you have accessed which means last in first out so at that point we use stack some sometimes we have to track each and every note so we simply use linked list all other other concepts one more thing the least fancy which are talking about that's an abstract concept because every language have a different way of implementing it and the actual implementation like link list we have at least in Java we have those two things so data structure is all about how do you store your data now push our eyes why it is so important now I mean of course it was important before as well but nowadays we have this boom of data structures right everyone want you to know data structures in fact if you go for the job interviews as well so initially they used to ask about programming language they used to ask about mathematical things now they talk about data structures they will ask your question based on data structures and talking about all the companies there's a might of Google Facebook or Apple they will start asking you a question on on data structures but why why now it's because the world is changing yeah thanks to this concept of big data every company they have huge amount of data with them how do you process them how do you store them so they we have different frameworks like Hadoop spark to process the data and the base of all those things is data structures if you understand it has structure it will be easier for you to understand the beta beta frameworks thanks to AI you know machine learning how will you implement AI if we don't have data and to store the data we need data structures right so the base app for everything is data structures so it's important for you now to understand data structures if you want to get into big companies and plus there is one more thing here you know the you're learning data structure will be helpful for you when you start learning different languages because every language have their own way of implementing it maybe Python or C or Java so they have some inbuilt things you can use it only when you know how that works so that's how you should be data structures and data structures is all about storing data and using it efficiently right so in the coming upcoming we'll talk about how do we implement some data structures and what are the algorithms available so that you can implement it I hope you like this video let me know in the comments section if you liked it and click the like button if you really enjoyed it and this is Chi power for the videos thanks for watching",
            "videoid": "jc1t0KFsOcs",
            "viewCount": "28889"
        },
        "oSWTXtMglKE": {
            "caption_exist": "T",
            "channel_id": "UCOf7UPMHBjAavgD0Qw5q5ww",
            "channel_title": "HackerRank",
            "concepts": [
                [
                    "node",
                    31
                ],
                [
                    "tree",
                    18
                ],
                [
                    "root",
                    8
                ],
                [
                    "binary search",
                    7
                ],
                [
                    "binary search tree",
                    5
                ],
                [
                    "search tree",
                    5
                ],
                [
                    "walk",
                    4
                ],
                [
                    "binary tree",
                    2
                ],
                [
                    "subtree",
                    2
                ],
                [
                    "operations",
                    2
                ],
                [
                    "list",
                    1
                ],
                [
                    "data structure",
                    1
                ],
                [
                    "boolean",
                    1
                ],
                [
                    "recursion",
                    1
                ],
                [
                    "balanced tree",
                    1
                ]
            ],
            "description": "Learn the basics of trees, data structures. This video is a part of HackerRank's Cracking The Coding Interview Tutorial with Gayle Laakmann McDowell.\nhttp://www.hackerrank.com/domains/tutorials/cracking-the-coding-interview?utm_source=video&utm_medium=youtube&utm_campaign=ctci",
            "dislikeCount": "31",
            "duration": "PT9M57S",
            "likeCount": "1703",
            "published_time": "2016-09-27T19:39:18.000Z",
            "tags": [],
            "thumbnail": "https://i.ytimg.com/vi/oSWTXtMglKE/hqdefault.jpg",
            "title": "Data Structures: Trees",
            "transcript": "  hi I'm Gail Locke McDowell author of Kraft encoding interview in this video I'm going to cover trees a tree is best thought of in this sort of picture you have a root node at the very top and it has child notes and each of those child notes they have child nodes themselves and so on and so on very often when are talking about trees we talked about binary trees a binary tree means that each node has no more than two child nodes that is that each node has a left node and a right node of course one or one or both of those could also be null very often when we're talking about binary trees we actually want to talk about binary search trees a binary search tree is a binary tree which fulfills asa civic ordering property so on any subtree the left nodes are less than the root node which is less than all of the right notes this ordering property makes finding a node very very fast because we have a pretty good idea of where it would be so suppose we're looking for 17 in this tree we can say okay is 17 bigger or smaller than the right than the root node well it's bigger than the root node so let's go to the right now is it bigger or smaller than that next node there well it's smaller than that node so it must be on the left of it and so very very quickly we can start to zoom in on where that node will be because it each operation we've chopped off hopefully about half of the nodes and we do that over and over again and very very quickly we find the node we're looking for so makes finds very very fast but how do those elements get in there in the first place well let's talk about how inserts work inserts work much like finding an element works we start with some element want to insert like say 19 and we say is it bigger or smaller than the root well it's bigger so let's go to the right now note it's smaller so let's go to the left I'm going to this over and over again until we get to an empty spot or no node and then we say okay that's where we should insert our new element now the one problem here is that if we get elements in a particular order we could get really imbalanced suppose we have a new binary search tree and we just follow the properties of insertion so we insert one and then two to its right and then three to its right and four to its right we're going to get this data structure that looks less like a tree and more like a long list and then inserts and finds will no longer be so fast there are some algorithms that can ensure that our tree stays balanced that is that roughly the same number of nodes will be on the left side of the subtree and on the right these algorithms get pretty complicated so we're not going to go into the details here but it's worth knowing that they're built into a lot of programming languages and in a lot of cases and interview questions you'll just assume that you have a balanced tree the last operation to talk about is traversing or walking through a tree so there's three common ways we walk through tree we can do an inorder traversal a pre-order traversal or a post order traversal a pre-order traversal means that you visit the route first and then you visit its left nodes and it's right notes in an inorder traversal you visit the left notes first then the current node and then you go to the right nodes in a post or adverse 'el the root node comes up so you visit the left nodes than the right nodes then the current root node typically in binary search trees we want to do inert reversals because that actually allows the nodes to be printed in order so for example on this tree here it was just a 1 a 2 and a 3 the nodes in an in order traversal will actually print it out in the order one and two and three so typically we'll see in art reversals now that we've covered the basic operations let's take a look at the code for binary search tree to implement a binary search tree we'll need a class node that has pointers to the left node and the right node and then some sort of data presumably and I'm going to give ourselves a constructor just to make our lives a little bit easier okay so the first method I'm going to add is an insert method and this is going to take in I'm going to call it value here this is going to take in a node there tip taken a node value and look to the left and the right to see where we want to insert it so first if value is less than or equal to the actual data of our node then we should insert it on the left side if there is no left node yet then this becomes my new node otherwise then I ask my left to insert it and I push that down the recursion stack and then otherwise if value is bigger than data then myself then it should be inserted on the right side and so if there is no right node put this as my right node otherwise ask my right to insert it okay so that's the basics of insert okay so let's walk through this code on an example so we have the simple tree and we want to insert the value eight so we call ten insert of eight and eight is smaller than ten so we go to the left and call left insert of eight so five dot insert of eight eight is bigger than five so we go and we don't have a right child and so we set 5s right child equal to eight the next method I'll do is find so find is going to operate recursively just like insert in fact it'll be somewhat similar in a lot of ways and it's going to want to return a boolean I'm actually going to call this contains because we're not really finding the nodes much as checking if the tree contains it okay so first of all if I'm their return true otherwise if value is smaller than data that it should be on if there is no left node then I know the answer is false otherwise if there is a left node go ask my left node what the answers okay now I do the same thing on if welcome to student else if right is null if there is no right node the answer is false otherwise go ask my right child and return its answer all right so that's it recursive plantation of contains so let's walk through this function imagining we're trying to find the value eight that we adjust insert it so we call ten that contains of eight eight is smaller than ten so go to the left and then we do five dot contains of eight five is smaller than eight and so we go to the right and then of course we see that eight in fact equals eight and so we return true all the way up the stack final method that'll implement is a inorder traversal typically I'm going to print all of the nodes in the tree so I just call this print in order and this is actually very simple first if my if I have a left child then I do my in order to running first of my left child then I print my own data and then same thing Li right if right is not null then I do right dot print in order so remember the inorder traversal z' do the left child myself and then my right child so that's exactly what the code here does so that's how we do an inorder printing let's walk through what this code does so we're going to first call ten dot print and order ten is going to say left print and order first that's a very first thing that's going to happen then we're going to print the route and then it's going to say write dot print in order so we're going to recurse down and five so we can get five dot print in five is going to say okay print got nothing on the left to print so print me next and then call write dot print in order where eight will get printed and then we're going to go back up to ten and ten is going to get printed and then we're going to go and go down to the right in that third step and print 15 so that's how an inorder traversal works if we want to do a pre or post order traversal we do a very very similar thing to send a slightly different order a pre order traversal means that the route gets printed first so we'd print the route then print the left sub-tree then print the right in a post order traversal the route gets printed last so we'd print the left then print the right and then we print the root note so it's a pretty natural translation of the algorithmic concepts a lot of times in interviews people get kind of intimidated by the idea of implanting a binary search tree they just assume it's something really challenging but if you understand the concept pretty well you can just take that and just translate it fairly directly into the code just be really careful about the null pointer checks so now that we've gone through the basic operations while you try out these concepts on a new problem good luck",
            "videoid": "oSWTXtMglKE",
            "viewCount": "160958"
        },
        "qH6yxkw0u78": {
            "caption_exist": "T",
            "channel_id": "UClEEsT7DkdVO_fkrBw0OTrA",
            "channel_title": "mycodeschool",
            "concepts": [
                [
                    "node",
                    59
                ],
                [
                    "tree",
                    50
                ],
                [
                    "root",
                    25
                ],
                [
                    "height",
                    14
                ],
                [
                    "data structure",
                    14
                ],
                [
                    "parent",
                    13
                ],
                [
                    "leaf",
                    10
                ],
                [
                    "link",
                    10
                ],
                [
                    "depth",
                    9
                ],
                [
                    "sibling",
                    6
                ],
                [
                    "element",
                    5
                ],
                [
                    "subtree",
                    5
                ],
                [
                    "binary tree",
                    4
                ],
                [
                    "list",
                    4
                ],
                [
                    "edge",
                    4
                ],
                [
                    "hierarchy",
                    4
                ],
                [
                    "type",
                    3
                ],
                [
                    "binary search",
                    3
                ],
                [
                    "linear",
                    3
                ],
                [
                    "cell",
                    3
                ],
                [
                    "binary search tree",
                    2
                ],
                [
                    "array",
                    2
                ],
                [
                    "name",
                    2
                ],
                [
                    "string",
                    2
                ],
                [
                    "search tree",
                    2
                ],
                [
                    "walk",
                    2
                ],
                [
                    "operations",
                    2
                ],
                [
                    "queue",
                    1
                ],
                [
                    "ancestor",
                    1
                ],
                [
                    "recursion",
                    1
                ],
                [
                    "system",
                    1
                ],
                [
                    "recursive data structure",
                    1
                ],
                [
                    "form",
                    1
                ],
                [
                    "dictionary",
                    1
                ]
            ],
            "description": "See complete series on data structures here:\nhttp://www.youtube.com/playlist?list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P\n\nIn this lesson, we have described tree data structure as a logical model in computer science.  We have briefly discussed tree as a non-linear hierarchical data structure, its vocabulary and applications. \n\nFor practice problems and more, visit: http://www.mycodeschool.com \n\nLike us on Facebook: https://www.facebook.com/MyCodeSchool\n\nFollow us on twitter: https://twitter.com/mycodeschool\ufeff",
            "dislikeCount": "86",
            "duration": "PT15M50S",
            "likeCount": "3911",
            "published_time": "2014-01-12T08:06:59.000Z",
            "tags": [
                "software",
                "class",
                "training",
                "school",
                "university",
                "College",
                "Student",
                "univeristy",
                "hiring",
                "job",
                "Campus",
                "data structure",
                "computer science",
                "yt:cc=on",
                "my code school",
                "c++",
                "java",
                "coding",
                "programming",
                "C (Programming Language)",
                "college",
                "degree",
                "technology",
                "information",
                "Information Technology (Industry)",
                "recruitment",
                "interview",
                "programming interview",
                "tree computer science"
            ],
            "thumbnail": "https://i.ytimg.com/vi/qH6yxkw0u78/hqdefault.jpg",
            "title": "Data structures: Introduction to Trees",
            "transcript": "  hello everyone in this lesson we'll introduce you to an interesting data structure that has got its application in a wide number of scenarios in computer science and this data structure is tree so far in this series we have talked about what we can call linear data structures array linked lists stack and queue all of these are linear data structures all of these are basically collections of different kinds in which data is arranged in a sequential manner in all these structures that I'm showing here we have a logical start and a logical end and then an element in any of these collections can have one next element and a previous element so all in all we have linear or sequential arrangement now as we understand these data structures are ways to store and organize data in computers for different kinds of data we use different kinds of data structure our choice of data structure depends upon a number of factors first of all it's about what needs to be stored a certain data structure can be best fit for a particular kind of data then we may care for the cost of operations quite often we want to minimize the cost of most frequently performed operations for example let's say we have a simple list and we are searching for an element in the list most of the time then we may want to store the list or collection as an array in sorted order so we can perform something like binary search really fast another factor can be memory consumption sometimes we may want to minimize the memory usage and finally we may also choose a data structure for ease of implementation although this may not be the best strategy tree is one data structure that's quite often used to represent hierarchical data for example let's say we want to show employees in an organization and their positions in organizational hierarchy then we can show it something like this let's say this is organizational hierarchy of some company in this company John is CEO and John has two direct reports Steve and Rama then Steve has three direct reports Steve is manager of Lee Bob and la they may be having some designation Rama also has two direct reports then bob has two direct reports and then tom has one direct report this particular logical structure that I have drawn here is a tree well you have to look at look at this structure upside down and then it will resemble a real tree the root here is at top and we are branching out in downward direction logical representation of tree data structure is always like this root at top and okay so tree is an efficient way of storing and organizing data that is naturally hierarchical but this is not the only application of tree in computer science we will talk about other applications and some of the implementation details like how we can create such a logical structure in computer's memory later first I want to define tree as a logical model tree data structure can be defined as a collection of entities called nodes linked together to simulate a hierarchy tree is a nonlinear data structure it's a hierarchical structure the topmost node in the tree is called root of the tree each node will contain some data and this can be data of any type in the tree that I am showing in right here data is name of employee and designation so we can have an object with two string fields one to store name and another to store designation okay so each node will contain some data and may contain link or reference to some other nodes that can be called it's children now I am introducing you to some vocabulary that we use for tree data structure what I'm going to do here is I'm going to number these nodes in the left trace so I can refer to these nodes using these numbers I'm numbering these nodes only for my convenience it's not to show any order okay coming back as I had said each node will have some data we can fill in some data in these circles it can be data of any type it can be an integer or a character or a string or we can simply assume that there is some data filled inside these nodes and we are not showing it okay as we were discussing a node may have link or reference to some other nodes that will be called its children each arrow in this structure here is a link okay now as you can see the root node which is numbered one by me and once again this number is not indicative of any order I could have called the root node node number ten also so root node has linked to these two nodes number two and three so two and three will be called children of one and node one will be called parent of nodes 2 &amp; 3 I'll write down all these terms that I am talking about we mentioned root children and parent industry one is a parent of one is parent of two and three two is child of one and now four five and six are children off to so no 2 is child off node one but parent off nodes four five and six children of same parent are called sibling I'm showing siblings in same color here two and three are siblings then four five and six are sibling then seven eight are sibling and finally nine and 10 are sibling I hope you are clear with these terms now the root would be the only node without a parent and then if a node has a direct link to some other node then we have a parent-child relationship between the nodes any node in the tree that does not have a child is called leaf node all these nodes mugged in black here are reliefs so leaf is one more term all other nodes with at least one child can be called internal nodes and we can have some more relationships like parent of parent can be called grandparent so one is grandparent of four and four is grandchild of one in general if we can grow go from node a to be walking through the links and remember these links are not bi-directional we have a link from 1 to 2 so we can go from 1 to 2 but we cannot go from 2 to 1 when we are walking the tree we can walk in only one direction ok so if we can go from node a to node B then a can be called ancestor of B and B can be called descendant of a let's pick up this node number 10 1 2 and 5 are all ancestors of 10 and 10 is a descendant of all of these nodes we can walk from any of these nodes to 10 okay let me now ask you some questions to make sure you understand things what are the common ancestors of 4 and 9 ancestors of 4 are one and two and ancestors of 9 are 1 2 and 5 so common ancestors will be 1 and 2 ok next question are 6 and 7 sibling sibling must have same parent 6 and 7 do not have same parent they have same grandparent one is grandparent of both nodes not having same parent but having same grandparent can be called cousins so 6 and 7 are cousins and these relationships are really interesting we can also say that node number 3 is uncle of node number 6 because because it's sibling of 2 which is father of 6 or I should say parent of 6 so we have quite some terms in vocabulary of tree ok now I will talk about some properties of tree tree can be called a recursive data structure we can define tree recursively as a structure that consists of a distinguished node called root and some sub trees and the arrangement is such that root of the tree contains link to roots of all the sub trees T 1 T 2 and T 3 in this figure are sub trees in the tree that I have drawn in left here we have two sub trees for our root node I am showing the root node in red the left subtree in brown and the right subtree in yellow we can further split the left subtree and look at it like node number two is root of this subtree and this particular tree with node number two as root has three sub trees I am showing the three sub trees in three different colors recursion basically is reducing something in a self-similar manner this recursive property of tree will be used everywhere in all implementation and users of tree the next property that I want to talk about is in a tree with n nodes there will be exactly n minus 1 links or edges each arrow in this figure can be called a link or an edge all nodes except the root node will have exactly one incoming edge if you can see I'll pick this node number two there is only one incoming link this is incoming link and these three are outgoing links there will be one link for each parent-child relationship so in a valid tree if there are n nodes there will be exactly n minus 1 edges one incoming edge for each node except the root okay now I want to talk about these two properties called depth and height depth of some node X in a tree can be defined as length of the path from root to node X each edge in the path will contribute 1 unit to the length so we can also say number of edges in path from root to X the depth of root node will be 0 let's pick some other node for this node number at 5 we have 2 edges in the path from root so the depth of this node is 2 in this tree here depth of nodes 2 &amp; 3 is 1 depth of nodes 4 5 6 7 &amp; 8 is 2 and the depth of nodes 9 10 and 11 is 3 ok now height of a node in tree can be defined as number of edges in longest path from that node to a leaf node so height of some node X will be equal to number of edges in longest path from X to a leaf in this figure for node 3 the longest path from this node to any leaf is 2 so height of node 3 is 2 node 8 is also a leaf node I'll mark all the leaf nodes here a leaf node is a node with 0 child the longest path from node 3 to any of the leaf nodes is 2 so the height of node 3 is 2 height of leaf nodes will be 0 so what will be the height of root node in this tree we can reach all the Leafs from root node number of edges in longest path is 3 so height of the root node here is 3 we also define height of a tree height of tree is defined as height of root node height of this tree that I'm showing here is tree height and depth are different properties and height and depth of a node may or may not be same we often confuse between the two based on properties trees are classified into various categories there are different kinds of trees that are used in different scenarios simplest and most common kind of tree is a tree with this property that any node can have at most two children in this figure note 2 has 3 children I'm getting rid of some nodes and now this is a binary tree binary trees most famous and throughout this series we will mostly be talking about binary trees the most common way of implementing tree is dynamically created nodes linked using pointers or references just the way we do for linked lists we can look at the tree like this in this structure that I have drawn in right here node has three fields one of the fields is to store data let's say middle cell is to store data the left cell is to store the address of the left child and the right cell is to store address of right because this is a binary tree we cannot have more than two children we can call one of the children left child and another right child programmatically in C or C++ we can define node as a structure like this we have three fields here one to store data let's say data type is integer I have filled in some data in these nodes so in each node we have three fields we have an integer variable to store the data and then we have two pointers to node one to store the address of the left child that will be the root of the left subtree and another to store the address of the we have kept only two pointers because because we can have at most two children in binary tree this particular definition of node can be used only for a binary tree for generic trees that can have any number of children we use some other structure and I will talk about it in later lessons in fact we will discuss implementation in detail in later lessons this is just to give you a brief idea of how things will be like in implementation okay so this is cool we understand what a tree data structure is but in the beginning we had said that storing naturally hierarchical data is not the only application of tree so let's quickly have a look at some of the applications of tree in computer science first application of course is storing naturally hierarchical data for example the file system on your disk drive the file and folder hierarchy is naturally hierarchical data it's stored in the form of tree next application is organizing data organizing collections for quick search insertion and deletion for example binary search tree that we'll be discussing a lot in next couple of lessons can give us order of log n time for searching an element in it or special kind of tree called tri is used is used to store dictionary it's really fast and efficient and is used for dynamic spell checking tree data structure is also used in network routing algorithms and this list goes on we'll talk about different kinds of trees and their applications in later lessons I'll stop here now this is good for an introduction in next couple of lessons we'll talk about binary search tree and its implementation this is it for this lesson thanks for watching",
            "videoid": "qH6yxkw0u78",
            "viewCount": "546454"
        },
        "t0Cq6tVNRBA": {
            "caption_exist": "T",
            "channel_id": "UCOf7UPMHBjAavgD0Qw5q5ww",
            "channel_title": "HackerRank",
            "concepts": [
                [
                    "heap",
                    22
                ],
                [
                    "array",
                    13
                ],
                [
                    "root",
                    10
                ],
                [
                    "parent",
                    8
                ],
                [
                    "node",
                    6
                ],
                [
                    "heapify",
                    5
                ],
                [
                    "tree",
                    5
                ],
                [
                    "walk",
                    4
                ],
                [
                    "head",
                    3
                ],
                [
                    "min heap",
                    3
                ],
                [
                    "max heap",
                    2
                ],
                [
                    "heap property",
                    2
                ],
                [
                    "data structure",
                    1
                ],
                [
                    "min-heap",
                    1
                ]
            ],
            "description": "Learn about heaps. This video is a part of HackerRank's Cracking The Coding Interview Tutorial with Gayle Laakmann McDowell. http://www.hackerrank.com/domains/tutorials/cracking-the-coding-interview?utm_source=video&utm_medium=youtube&utm_campaign=ctci",
            "dislikeCount": "71",
            "duration": "PT10M32S",
            "likeCount": "1823",
            "published_time": "2016-09-27T19:39:16.000Z",
            "tags": [],
            "thumbnail": "https://i.ytimg.com/vi/t0Cq6tVNRBA/hqdefault.jpg",
            "title": "Data Structures: Heaps",
            "transcript": "  hi I'm Gail Locke McDowell off of crack and coding interview today we talk about topics that a lot of candidates forget about heaps heaps come in one of two forms a min heap or max heap will just focus on min heaps today because a max heap essentially at verse in a min heap the elements are all smaller than their children so the root node will be the very smallest element and then looking down the tree down the heap the elements get bigger and bigger and bigger so that's the basics of what a heap is but how do we actually create and maintain such a data structure so let's start with just insertion so we insert an element it always goes in the next empty spot looking top to bottom left to right so we go first we insert an element here and then here and then here and then here and so on through the tree through the heap so that's how insertion works but then of course what happens if that's not really where the element should go well what we can do is we can insert the element there and then bubble it up too until we get to the right spot so we take the inserted element we compare it with its parent if it's out of order swap them and then keep going up the tree in this process now what about removing the minimum element so so we know the minimum element will always be at the root node and so that's easy to find but then if we want to remove it we might have an empty spot so so what we do here is we remove the min element there so we take out the root and then we swap that value at the root with the last element added and then of course that element might not be at the right spot so we take the root element and bubble it down to the next spot so we compare the root with the it's children it's left child and the right child and then swap it with the smaller of the two and then we keep going down the tree until the heap property is restored so that's how a tree operates let's think about influent how a heap operates let's talk about implementation now so implementation is kind of interesting you might have assumed that we've implemented as a simple class node with a left node and a right node and certainly we could do it that way but and even there's an even better way of employing it note that when we add elements to the heap they're always going to add it in a very particular spot there aren't going to be any gaps in the heap so we have the zeroth element here and then the first second third fourth etc and so that means that we can actually use it an array instead to store these values and that makes it very compact and a simple simple equation can map from an index to its left child it's right child or to its parent and so we can still get to the left and right child but we don't need to have this overhead of a node class so now that we've covered the basics of what a heap is let's turn to the actual code for this well implant a min-heap with a simple class that wraps this items are right this is going to be an array of a fixed length but if it gets too big we'll increase the capacity now I'm going to get a little bit of a head start and cheat a little bit by just adding in a whole bunch of filler simple helper methods so these are just simple methods that get the left and right child or the parent index actually you know check if they exist we actually get the values themselves so I'm just getting a little bit of a head start here and I'll get another little bit of a head start by adding in two extra methods here one is a swap method that swaps the values of two indices and then another one is an ensure extra capacity method now this does is it checks if the array is full and if so it creates a new array of double dot size and it copies all the elements and this by the way is the basics of how an ArrayList operates now let's turn to the real code the first method method all implement is a peek method and this first it checks if the array is empty if so we turns an exception because there's nothing at the front otherwise it just returns the first element in the array which will always be the minimum element and essentially the root of the heap this method will do is a pull method now this does is actually extract the minimum element and actually so it actually removes it from the array so first we'll check if the array is empty if so throw an exception otherwise I need to actually get the value so item is items of zero then I need to take the very last element in the array and move it into the very first element then I need to shrink my array or shrink essentially the size of it and then I need to go and actually re heapify so I removed the root element so I need to keep a fied down and I'll go fill this in this method in shortly so in this case if we remove the ten the minimum element it's going to get deleted then the 17 is going to get moved up to where the tennis so see in the array that's like this so the 17 gets put in here and then we go and adjust the heap to shift elements down as needed my next method is going to actually add an element in here so first thing I want to do is we want to make sure there is capacity so in calm I ensure extra capacity method then I'm going to add my element into the very last spot so items of size equals this new item then increase my size and then I need to actually keep if I up so I need to fix the heap looking upwards swapping each element with its parent as necessary so in this case if we want to add an element say 8 we don't add at the very last element and then we'd go and adjust our heap moving things up as necessary now for the real fun I need to actually implement these heapify methods so heapify up is going to start with the very last element added which is that size minus 1 and then it's going to walk up as long as there's a parent item and as long as essentially I'm out of order so as long as my parent item is bigger than me then hey things are out of order so swap my parent index swap my value with my parent and then walk upwards so let's walk through this on the 8 that was inserted so what we do here is we'll compare 8 to this 15 it's out of order so we'll need to swap those values so 15 goes down here and 8 goes up here or on the array it'll look like this then we compare this 8 to the 10 and then that's still out of order and so we'll go and move the 10 down and swap the 8 up there and now we've returned to the root prep to the heat properties we have a at the top 10 and 20 below it then 17 and 15 below that heapify down is a little bit more complicated but it's still quite manageable first we're going to start off with our root element which that index 0 and then we're going to say well as long as I have children keep walking down and trying to fix up my heap now I only need to check if there's a left child because if there's no left child then there's certainly no right child then I'm gonna set this smaller child index equal to the smaller of the left and the right child so I'm going to stake it guess with set it equal to the left child and then I'm going to say hey if there's a right child and my right child is even smaller than my left child smaller child index should equal my right child now what I'm going to say remember I'm looking downwards on the heap so now I must say is hey if items of index if I'm smaller than the smaller of my two children then everything's good and everything's back in order here and I can just exit if that's not the case then our heap is still out of order and then I need to swap my value with my smaller child and then move down to my I'll just actually move this out here alright so that's the basics of how heapify down works let's walk through this on an example I'll make this example slightly larger so if we do an extract min such that 2010 gets removed then we move ten we replace it with 25 I'll do it on the array to shouldn't see what's going on there then we compare 25 the route and replace it with the smaller of its left and right child so we swap the 25 and the 15 so 25 comes down here 15 comes up there and we can do it down here too so 15 goes here 25 goes here then we compare 25 to 17 it's still out of Orsat order since 25 is bigger than 17 so we do 17 comes up here we swap those and 25 goes down here so now we have a heap again that looks like 15 17 20 and 25 and as you can see our min heap property has been restored so now that you understand what if he bids and how it works why don't you try out using a heap on a new problem good luck",
            "videoid": "t0Cq6tVNRBA",
            "viewCount": "217383"
        },
        "z2pjGiaDUPo": {
            "caption_exist": "T",
            "channel_id": "UCiV37YIYars6msmIQXopIeQ",
            "channel_title": "Computer Education For all",
            "concepts": [
                [
                    "data structure",
                    14
                ],
                [
                    "operations",
                    10
                ],
                [
                    "string",
                    6
                ],
                [
                    "array",
                    6
                ],
                [
                    "boolean",
                    4
                ],
                [
                    "language",
                    3
                ],
                [
                    "linear",
                    3
                ],
                [
                    "graph",
                    2
                ],
                [
                    "algorithm",
                    2
                ],
                [
                    "queue",
                    1
                ],
                [
                    "tree",
                    1
                ],
                [
                    "linked list",
                    1
                ],
                [
                    "list",
                    1
                ],
                [
                    "implies",
                    1
                ],
                [
                    "link",
                    1
                ],
                [
                    "arithmetic",
                    1
                ],
                [
                    "substring",
                    1
                ]
            ],
            "description": "Computer Education for all provides Introduction to Data Structures. In Computer Science Data Structures is a Study of various ways of organizing data in a computer. Information is manipulated by systematic and step-by-step procedure called algorithm. Data Structure and its Application having Data Types are primitive and composite. Briefly tells about what are linear and nonlinear data structures?  \nComputer Education For All, intro to data structures, data structures and algorithms lectures , Introduction to data structures and algorithms, introduction to data structures mit , types of data structures , what are data structures , Introduction to Data Structures, What are Data Structures and its Applications, what are linear and nonlinear data structures, Linear Data Structures, Non-Linear, linear and nonlinear data structure with example, data structures lectures, MCS, PGD, MSCS, Mphil, PHD \nHave a look this helpful video, for more please subscribe \nhttps://www.youtube.com/channel/UCiV37YIYars6msmIQXopIeQ",
            "dislikeCount": "12",
            "duration": "PT13M22S",
            "likeCount": "91",
            "published_time": "2016-03-28T06:00:00.000Z",
            "tags": [
                "Computer",
                "Education",
                "for",
                "All",
                "Computer Education For All",
                "intro to data structures",
                "data structures and algorithms lectures",
                "Introduction to data structures and algorithms",
                "introduction to data structures mit",
                "types of data structures",
                "what are data structures",
                "Introduction to Data Structures",
                "What are Data Structures and its Applications",
                "Linear Data Structures",
                "Non-Linear",
                "linear and nonlinear data structure with example",
                "data structures lectures",
                "MCS",
                "PGD",
                "MSCS",
                "Mphil",
                "PHD"
            ],
            "thumbnail": "https://i.ytimg.com/vi/z2pjGiaDUPo/hqdefault.jpg",
            "title": "What is Data Structure and Its Types",
            "transcript": "  in computer science data structure is a study of various ways of organizing data in a computer so that it can be used efficiently invariably the information contained in a data structure is manipulated by a systematic and step-by-step process which is called algorithm the manipulation of data structure may involve such operations as adding an item searching for a particular item deleting an item rearranging data items in different ways thus data structures and algorithms are closely linked together and play a complementary role in many applications over the years data structures have gained significant importance because of their usage in several disciplines data structures are an integral part of modern operating systems compilers database management systems data communication and assistant software likewise algorithm together with associated data structures have widespread use in several applications including image processing digital signal processing simulations numerical computations cryptography data compressions and genetic studies in this introductory unit we shall introduce basic terminologies and concepts concerning data structures data types all programming languages provides some built-in data types which are useful for efficient coding of programs the predefined data elements are separated into two classes which are known as primitive and composite a primitive data type defines a set of values and operations that can be performed on these values the familiar primitive data types are integers real numbers characters and boolean which is supported by almost all programming languages a boolean type can have only two values two or false the basic operations on these values are and or and not an integer type can assume different set of values depending on implementation in a particular language the set of basic permissible operations on an integer type are for example arithmetic operations and comparisons operations the primitive data types are also called atomic are irreducible because these can not be expressed in any other basic types the primitive data types are always supported by the underlying hardware features and to a lesser extent by the compiler systems this means that the range of values and allowed operations depend primarily on the hardware circuitry in general the number of bits allocated to each type decides the range of values for example an integer type is often implemented using a 32-bit storage representation with one bit reserved for sign in this way the integer type can have a range of values over a billion characters are implemented by using 8-bit for ASCII and app stick representation and sixteen bits for Unicode the late representation allows a range of values of a 65,000 for encoding characters the operations on primitive data types are often included in CPU instruction set when such support is lacking the compiler depends on built-in software routines a notable example is the implementation of floating-point operations on small computers which do not have floating-point circuitry the real numbers are manipulated using software instructions of course this approach considerably reduces the computational speed often by a factor of 100 mm different programming languages provide a variety of primitive data types which are identified by language specific keywords for example Java defines 8 primitives an important feature of Java primitives is that each data type is made up of a fixed number of bits which is independent of a particular implementations for example an int type always consists of 32 bits and character of 16 bits on all platforms C C++ provides an assortment identified by the syntax int float character double the numeric type may be further qualified as short or long signed or unsigned C does not support boolean data type instead numeric 0 and known 0 values are interpreted as false or to further the size of C C++ data type varies with platform dependent Visual Basic provides supports for all basic types identified by the keywords integer long single double byte and boolean the primitive types can be created as local or global with each type preceded with the word public or dem composite data types are larger and more complex data types which are defined using combinations of primitive types the common examples of composite types are arrays vectors and strings an array is a collection of homogeneous data almost all programming languages support arrays as built-in data types we shall explain the detailed properties and uses the phrase in a subsequent unit vectors are essentially a mathematical representation of arrays they differ from ordinary arrays in their implementation for example Java provides vectors as an array of flexible sized strings are combinations of characters the support for strings as a built-in datatype varies a great deal with the programming languages if string is defined as a primitive data type string data is stowed in an array of characters with a special delimiter this is the approach followed by C C++ adder and Pascal in C C++ for instance a string is represented as array of characters with the null character in the last position Foton 90 and visual basic provides support for strings as primitive datatype with associated operations of assignment join comparison and substring references in java strings are supported as built-in type of string class data structure the built-in data types provided by programming languages are adequate for solving simple problems in fact all computer applications in early days dependent exclusively on the built-in elements of the host programming languages for disturbing and processing of different data types this was particularly true of numerical or scientific oriented problems with the dramatic increase in the use of computers in various disciplines it was realized that the primitive data types were not sufficient or powerful enough to solve advanced problems involving complex structural relationship among data items the need for new data types was further exacerbated by the recent paradigm of object oriented approach to problem solving data structures are meant to serve these needs simply stated a data structure is a programming construct that Stowe's a collection of data items at first sight data structures might appear as an extension of composite data type this is true in a limited sense actually there are two subtle differences first the term data structure and campuses composite data type defined in a programming language it may even be a user-defined type to serve a particular application need second and more importantly a data structure implies some kind of organization or relationship among the constituent data items for example a character string whether defined as an array of character are treated as primitive type has a definite order of organized characters and alteration in the order changes the memory and characteristics of the original string on the basis of structural relationship the data structures are classified into two types linear and nonlinear a data structure which organizes data elements in a sequence that is one after the other is referred to as linear array is a common example of linear data structure that exhibit linearity other examples are linked lists stack and queue we shall dwell at length on these data structures in later units here we briefly introduce these types a linked list consists of data items called nodes each item contains an information field and a link field pointing to another a stack is a data structure which works on the principle that last item added to the collection becomes the first item that can be taken off like a pile of trays it is also called lympho last in first out data structure Accu is a data structure in which an item can be added at one end and an existing item in the collection can be removed from the other end it works on the principle FIFO first-in first-out in a nonlinear data structures the relationship between the elements is more complex it can be for example hierarchical that is one element may be linked to more than one element in the collection further the linkage may be single or bi-directional the nonlinear types are also referred to graph data structure common examples of nonlinear data structures are trees and graphs a tree is a data structure consisting of a set of data items called nodes which contain an information field and linkage to one or moded items in a hierarchical order there are several variations of trees some useful types are referred to as binary trees AVL trees red and black trees splash trees B trees and heaps we shall study their properties in a later unit a graph is a set of data items called vertices are nodes connected by lengths edges or arcs you",
            "videoid": "z2pjGiaDUPo",
            "viewCount": "16947"
        }
    }
}